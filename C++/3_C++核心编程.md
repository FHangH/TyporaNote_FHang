

#  C++核心编程



### 1. 内存分区模型

C++程序在执行时，内存大方向划分为4个区域

- 代码区：存放函数的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
-  栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若不释放，程序执行结束后会系统回收



内存分区的意义：

- 不同区域存放的数据，赋予不同的生命周期



#### 1.1 程序运行前

程序编译后，生成可执行的 .exe 文件 未执行前，分成两个区域

代码区：

- 存放CPU执行的机器指令
- 代码区是共享的，目的是对于频繁的执行程序，只需在内存中存放一份即可
- 代码区是只读的，目的是防止程序意外的修改了它的指令

全局区：

- 全局变量和静态变量存放其中
- 全局区还包括了常量区，字符串常量和其他常量也存放其中
- 该区域的数据在程序结束后由操作系统释放



分类：

- 全局区：全局变量，静态变量，常量
- 常量区：const修饰的全局变量，字符串常量
- 局部区：局部变量，const修饰的局部变量和常量

代码：

```c++
#include <iostream>

using namespace std;

//Global variable outside Function
int g_a = 10;
int g_b = 20;

//Global constant variable outside Function
const int g_c_a = 10;
const int g_c_b = 20;

int main()
{
    //Local variable inside Function
    int l_a = 10;
    int l_b = 20;

    //Static variable
    static int s_a = 10;
    static int s_b = 20;

    //Constant Local variable inside Function
    const int l_c_a = 10;
    const int l_c_b = 20;

    //Debug local variable
    cout << "Local Area_Local variable l_a: " << (int) &l_a << endl;
    cout << "Local Area_Local variable l_b: " << (int) &l_b << endl;

    //Debug constant local variable
    cout << "Local Area_Constant local variable l_c_a:" << (int) &l_c_a << endl;
    cout << "Local Area_Constant local variable l_c_b:" << (int) &l_c_b << endl;

    //Debug global variable
    cout << "Global Area_Global variable g_a: " << (int) &g_a << endl;
    cout << "Global Area_Global variable g_b: " << (int) &g_b << endl;

    //Debug static variable
    cout << "Global Area_Static variable s_a: " << (int) &s_a << endl;
    cout << "Global Area_Static variable s_b: " << (int) &s_b << endl;

    //Debug string constant
    cout << "Global Area_String constant str_c_a:" << (int) &"Hello World" << endl;

    //Debug global constant variable
    cout << "Global Area_global constant variable g_c_a:" << (int) &g_c_a << endl;
    cout << "Global Area_global constant variable g_c_b:" << (int) &g_c_b << endl;

    return 0;
}
```





#### 1.2 程序运行后

- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等

- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  //定义一个返回值int类型的函数
  int *demoFunc()
  {
      //定义一个局部变量，存在栈区中
      int a = 10;
      //返回一个局部变量的地址
      return &a;
  }
  
  int main()
  {
      //接受局部变量传来的地址
      int *p_a = demoFunc();
  
      cout << *p_a << endl; //第一次能正常的解析地址对应的值，函数执行结束，系统回收了数据
      cout << *p_a << endl; //第二次，无法正常解析到对应的值，因为函数执行一次结束后，没有返回值了
  }
  ```
  
- 堆区：由程序员释放，若不释放，程序结束时由操作系统回收

- 方式：C++通过 new 在堆区中开辟内存

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int *demoFunc()
  {
      //通过指针地址存放 new 关键字对int类型的值在堆中开辟的内存所在的地址
      //这个 int的值存放在堆中，改函数执行结束后，依然存在
      int *p_a = new int(10);
      return p_a;
  }
  
  int main()
  {
      int *p_a = demoFunc();
      cout << *p_a << endl;
      cout << *p_a << endl; //函数执行结束后，指针指向的指针内存空间依然存在，所以可以正常得到内存中的值
      return 0;
  }
  ```





1.3 new操作符

- C++ 通过 new 在堆区开辟数据
- 堆区的数据，由程序员手动开辟，手动释放，利用 delet 操作符
- 语法：new 数据类型（）；
- 利用new创建的数据，会返回该数据对应的类型的指针地址

示例：

```c++
#include <iostream>

using namespace std;

//创建一个返回int类型的地址函数
int *newKeyDemo()
{
    //new操作符开辟的数据会返回一个指针
    int *p_a = new int(10);
    //返回指针
    return p_a;
}

void printDemo1Info()
{
    //创建一个指针接受返回值
    int *Info1 = newKeyDemo();
    cout << *Info1 << endl;
    //delete 操作符会释放 new在堆中的数据
    delete Info1;
    cout << *Info1 << endl;
}

//利用new操作符创建数组
void printDemo2Info()
{
    int *p_arr = new int[10];

    for (int i = 0; i < 10; i++)
    {
        p_arr[i] = i + 1;
    }

    for (int j = 0; j < 10; j++)
    {
        cout << p_arr[j] << " ";
    }

    delete[] p_arr;
}

int main()
{
    printDemo1Info();
    printDemo2Info();
    return 0;
}
```





### 2. 引用



#### 2.1 引用的基本使用

- 作用：给变量起别名

- 语法：数据类型 &别名 = 原名；

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int main()
  {
      int a = 10;
      int &b = a;
  
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
  
      b = 20;
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
      return 0;
  }
  ```





#### 2.2 引用注意事项

- 引用必须初始化

- 引用在初始化后不可以改变

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int main()
  {
      int a = 10;
      int c = 10;
      //int &b; 引用必须初始化
      int &b = a;
      //int &b = c; 引用初始化后不可更改
      return 0;
  }
  ```

  



#### 2.3 引用做函数参数

- 作用：函数传参时，可以利用引用的技术让形参修饰实参

- 优点：可以简化指针修改实参

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void swap01(int a, int b)
  {
      int temp = a;
      a = b;
      b = temp;
  }
  
  void swap02(int *p_a, int *p_b)
  {
      int temp = *p_a;
      *p_a = *p_b;
      *p_b = temp;
  }
  
  void swap03(int &a, int &b)
  {
      int temp = a;
      a = b;
      b = temp;
  }
  
  int main()
  {
      int a = 10;
      int b = 20;
  
  //    swap01(a, b); 值传递，形参不修饰实参
  //    swap02(&a, &b); 地址传递，形参修饰实参
      swap03(a, b); // 引用传递，形参修饰实参
  
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
      return 0;
  }
  ```





#### 2.4 引用做函数的返回值

- 作用：引用可以作为函数的返回值

- 注意：不要返回局部变量引用

- 用法：函数调用作为左值

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int &demo1()
  {
      int a = 10; //函数体内定义的局部变量，函数执行完后，系统自动回收
      return a;
  }
  
  int &demo2()
  {
      static int b = 20; //static 修饰的静态变量，存储在全局区，整个程序执行完后，系统自动回收
      return b;
  }
  
  int main()
  {
      int &ref_a = demo1();
      int &ref_b = demo2();
      cout << "ref_a = " << ref_a << endl;
      cout << "ref_a = " << ref_a << endl;
  
      cout << "ref_b = " << ref_b << endl;
      cout << "ref_b = " << ref_b << endl;
  
      demo2() = 1000; //函数的调用是引用，可以作为左值
      cout << "ref_b = " << ref_b << endl;
      cout << "ref_b = " << ref_b << endl;
  
      return 0;
  }
  ```

  



#### 2.5 引用的本质

- 本质：在C++内部实现一个指针常量

- 示例：

  ```c++
  #include <iostream>
  using namespace std;
  // 转换为 int *const ref_b = &a
  void demo1(int &ref_b)
  {
      ref_b = 100;
  }
  
  int main()
  {
      int a = 10;
      // 自动转换为 int *const ref_a = &a; << = >> 指针常量；因为指针的指向（地址）不可改变，所以引用的初始化后不可更改
      int &ref_a = a;
      // ref是引用，自动转换成 *ref = 20；
      ref_a = 20;
    
      cout << "a = " << a << endl;
      cout << "ref_a = " << ref_a << endl;
    
      demo1(ref_a);
    
      return 0;
  }
  ```

- 结论：引用本质是指针，使用方便






#### 2.6 常量引用

- 作用：常量引用一般用来修饰形参，防止误操作

- 使用：在函数形参列表中，可以加 const 修饰形参，防止形参被实参修改

- 示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  void printInfo(const int &ref_b)
  {
      //常量引用的值不可以修改
      //ref_b = 1000;
      cout << "ref_b = " << ref_b << endl;
  }
  
  int main()
  {
      // 编辑器 转换为 int temp = 10;   const int &a = temp;
      //const int &ref_a = 10;
      // ref_a 用 const 修饰后值不能被修改
      //ref_a = 20;
  	int a = 100;
  	printInfo(a);
  	cout << "a = " << a << endl;
  	return 0;
  }
  ```







### 3. 函数进阶



#### 3.1 函数默认参数

- 在C++中，函数的形参列表中的形参可以有默认值

- 语法：返回值类型 函数名 （参数 = 默认值）{}

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 无默认值参数，通过调用函数传入参数值
  int func01(int a, int b, int c)
  {
      return a + b + c;
  }
  
  // 有默认值参数，可以通过调用函数传入参数值，也可以不传参数值
  int func02(int a = 10, int b = 20, int c = 30)
  {
      return a + b + c;
  }
  
  // 当函数定义中，有默认参数值的一项形参，其之后的其他形参也要有形参
  //int func03(int a = 10, int b, int c)
  //{
  //    return a + b + c;
  //}
  
  // 函数在声明时，形参有默认值，定义时，形参不得定义默认值
  int func04(int a = 10, int b = 20);
  
  //int func04(int a = 20, int b = 10)
  //{
  //    return a + b;
  //}
  
  
  int main()
  {
      cout << "Func01: " << func01(10, 20, 30) << endl;
      cout << "Func02: " << func02() << endl;
      return 0;
  }
  ```

  



#### 3.2 函数占位参数

- C++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

- 占位参数可以有默认值

- 语法：返回值类型 函数名 （数据类型）{}；

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 占位参数可以有默认值
  void func1(int a, int = 10)
  {
      cout << "Func1 Test" << endl; 
  }
  
  int main()
  {
      // 有默认值可以不传实参，否则占位参数也要传实参
      func1(10, 10);
      return 0;
  }
  ```





#### 3.3 函数重载



##### 1. 函数重载概述

- 作用：函数名可以重复，提高复用性

- 条件：

  1. 同一作用域下
  2. 函数名相同
  3. 函数参数类型不同 或 个数不同 或 顺序不同

- 注意：函数的返回值不可以作为函数重载的条件

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void func()
  {
      cout << "func()" << endl;
  }
  
  void func(int a)
  {
      cout << "func(int a)" << endl;
  }
  
  void func(int a, int b)
  {
      cout << "func(int a, int b)" << endl;
  }
  
  void func(int a, double b)
  {
      cout << "func(int a, double b)" << endl;
  }
  
  // 返回值不可以作为函数重载的条件
  //int func()
  //{
  //    cout << "func()" << endl;
  //}
  
  int main()
  {
      func();
      func(10);
      func(10, 20);
      func(10, 20.20);
      return 0;
  }
  ```

  



##### 2. 函数重载注意事项

- 引用作为重载条件

- 函数重载碰到函数默认参数

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void func()
  {
      cout << "func()" << endl;
  }
  
  void func(int &a)
  {
      cout << "func(int &a)" << endl;
  }
  
  void func(const int &a)
  {
      cout << "func(const int &a)" << endl;
  }
  
  void func(int &a, int &b)
  {
      cout << "func(int &a, int &b)" << endl;
  }
  
  void func2(int a)
  {
      cout << "func2(int a)" << endl;
  }
  
  void func2(int a, int b = 10)
  {
      cout << "func(int a, int b = 10)" << endl;
  }
  
  
  int main()
  {
      int a = 10;
      int b = 20;
  
      func();
      func(a);
      func(10);
      func(a, b);
  
      // func2 函数有重载，且其中一个参数有默认值
      //func2(a);
  
      return 0;
  }
  ```





### 4. 类和对象

- C++面向对象的三大特性：封装，继承，多态



#### 4.1 封装



##### 1. 封装的意义

- 意义一：

  1. 将属性和行为作为一个整体，表现生活中的事物
  2. 将属性和行为加以权限控制
  3. 在设计类时，属性和行为写在一起，表现事物

- 语法：class 类名 { 访问权限：属性 / 行为 }；

- 示例1：设计一个圆，求圆的周长

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 类名 （圆）
  class Circle
  {
      // 权限（公开）
  public:
      // 属性
      const double Pi = 3.14;
      double cir_R;
  
      // 计算圆周长的函数
      double calculatePerimeter()
      {
          return  2 * Pi * cir_R;
      }
  };
  
  int main()
  {
      // 通过Circle类创建一个实例（对象） c1
      Circle c1;
      // 通过对象，对类中的属性 cir_R 进行赋值 
      c1.cir_R = 10.0;
      double value = c1.calculatePerimeter();
      cout << "Circle perimeter : " << value << endl;
  
      return 0;
  }
  ```

- 示例2：设计一个学生类，属性有姓名和学号，对属性进行赋值，并显示属性信息（两种写法）

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Student
  {
  public:
      string stu_Name;
      int stu_ID;
  
      void printStudentInfo()
      {
          cout << "Student Info : " << endl;
          cout << "Name: " << stu_Name << "  ID: " << stu_ID << endl;
      }
  };
  
  
  int main()
  {
      Student s1;
      s1.stu_ID = 123456;
      s1.stu_Name = "FH";
      s1.printStudentInfo();
  
      return 0;
  }
  ```

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Student
  {
  public:
      string stu_Name;
      int stu_ID;
  
      void setName(string name)
      {
          stu_Name = name;
      }
  
      void setID(int id)
      {
          stu_ID = id;
      }
  
      void printStudentInfo()
      {
          cout << "Student Info : " << endl;
          cout << "Name: " << stu_Name << "  ID: " << stu_ID << endl;
      }
  };
  
  
  int main()
  {
      Student s1;
      s1.setName("FH");
      s1.setID(123456);
      s1.printStudentInfo();
  
      Student s2;
      s2.setName("CYL");
      s2.setID(666666);
      s2.printStudentInfo();
  
      return 0;
  }
  ```

- 意义二：不属性和行为放在不同的权限下，加以控制

- 访问权限三种：

  | public 公开    | 成员类内可访问，类外可访问   | 子类可访问           |
  | -------------- | ---------------------------- | -------------------- |
  | protected 保护 | 成员类内可访问，类外不可访问 | 子类可访问保护内容   |
  | private 私有   | 成员类内可访问，类外不可访问 | 子类不可访问私有内容 |

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      string name;
  
  protected:
      string car;
  
  private:
      int password;
  
  private:
      void func()
      {
          name = "FH";
          car = "XXX";
          password = 123456;
      }
  };
  
  
  int main()
  {
      Person p1;
      p1.name = "CYL";
  
      //p1.car = "YYY"; // 保护权限内容，类外不可访问和修改
      //p1.password = 999999; // 私有权限内容，类外不可访问和修改
      return 0;
  }
  ```

  



##### 2. struct和class区别

- 区别：struct 默认权限为公开；class默认权限为私有

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class C1
  {
      int a;
  };
  
  struct C2
  {
      int a;
  };
  
  int main()
  {
      C1 c1;
      C2 c2;
      
      //c1.a = 10; // class默认私有，无法访问
      c2.a = 10; // struct默认公开，可以访问
      
      return 0;
  }
  ```





##### 3. 成员属性私有化

- 优点：

  1. 将所有成员属性设置为私有，可以自己控制读写权限
  2. 对于写权限，可以检测数据的有效性

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      void setName(string name)
      {
          p_Name = name;
      }
      string getName()
      {
          return p_Name;
      }
  
      int getAge()
      {
          p_Age = 24;
          return p_Age;
      }
  
      void setID(int id)
      {
          p_ID = id;
      }
  
  private:
      string p_Name; // 可读可写
      int p_Age; // 可读
      int p_ID; // 可写
  };
  
  int main()
  {
      Person p;
      p.setName("FH");
      p.setID(123455);
      cout << "Name: " << p.getName() << endl;
      cout << "Age: " << p.getAge() << endl;
  
      return 0;
  }
  ```





##### 4. 案例：设计立方体

- 要求：设计立法体类（cube），求面积和体积，分别用全局函数和成员函数判断两个立方体是否相等

- 代码：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Cube
  {
  private:
      float c_Length = 1.0;
      float c_Width = 1.0;
      float c_Height = 1.0;
  
  public:
      void setLength(float length)
      {
          c_Length = length;
      }
  
      float getLength() const
      {
          return c_Length;
      }
  
      void setWidth(float width)
      {
          c_Width = width;
      }
  
      float getWidth() const
      {
          return c_Width;
      }
  
      void setHeight(float height)
      {
          c_Height = height;
      }
  
      float getHeight() const
      {
          return c_Height;
      }
  
      float calculateArea() const
      {
          return 2 * c_Length * c_Width + 2 * c_Length * c_Height + 2 * c_Width * c_Height;
      }
  
      float calculateVolume() const
      {
          return c_Height * c_Width * c_Length;
      }
  
      // 成员函数判断两个立方体是否相等
      string calculateSameFromClass(Cube &c) const
      {
          if (c.getLength() == c_Length && c.getWidth() == c_Width && c.getHeight() == c_Height)
          {
              return "Class_Same!!!";
          }
          return "Class_No Same!!!";
      }
  };
  
  // 全局函数判断两个立方体是否相等
  string calculateSameFromGlobal(Cube &c1, Cube &c2)
  {
      if (c1.getHeight() == c2.getHeight() && c1.getWidth() == c2.getWidth() && c1.getLength() == c2.getLength())
      {
          return "Global_Same!!!";
      }
      return "Global_No Same!!!";
  }
  
  int main()
  {
      Cube c1;
      Cube c2;
      Cube c3;
  
      c1.setHeight(10.0);
      c1.setLength(10.0);
      c1.setWidth(10.0);
  
      c2.setHeight(10.0);
      c2.setLength(10.0);
      c2.setWidth(10.0);
  
      c3.setHeight(20.0);
      c3.setLength(20.0);
      c3.setWidth(20.0);
  
      // 存储立方体的面积以及体积返回的值
      float cube_Area = c1.calculateArea();
      float cube_Volume = c1.calculateVolume();
  
      // 存储两种函数等到的判断返回结果
      string global_Same = calculateSameFromGlobal(c1, c2);
      string class_Same = c1.calculateSameFromClass(c3);
  
      cout << "Cube Area: " << cube_Area << endl;
      cout << "Cube Volume: " << cube_Volume << endl;
  
      cout << "Global_Same: " << global_Same << endl;
      cout << "Class_Same: " << class_Same << endl;
  
      return 0;
  }
  ```





##### 5. 案例：点圆的关系

- 要求：设计圆类（Circle）设计点类（Point），计算点和圆的包含关系（圆外）（圆上）（圆内）（圆心）

- 代码：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 点类
  class Point
  {
  private:
      // 点X坐标
      double p_X;
      // 点Y坐标
      double p_Y;
  
  public:
      void set_X(double x)
      {
          p_X = x;
      }
      double get_X() const
      {
          return p_X;
      }
  
      void set_Y(double y)
      {
          p_Y = y;
      }
      double get_Y() const
      {
          return p_Y;
      }
  };
  
  // 圆类
  class Circle
  {
  private:
      // 圆的半径
      double c_Radius;
      // 圆心的坐标
      Point c_Center;
  
  public:
      void setRadius(double radius)
      {
          c_Radius = radius;
      }
      double getRadius() const
      {
          return c_Radius;
      }
  
      void setCenter(Point &center)
      {
          c_Center = center;
      }
      Point getCenter()
      {
          return c_Center;
      }
  };
  
  // 计算圆与点之间的关系
  void calculateCircleAndPoint(Circle &c, Point &p)
  {
      // 圆心点X - 点X
      double ppDistanceX = c.getCenter().get_X() - p.get_X();
      // 圆心点Y - 点Y
      double ppDistanceY = c.getCenter().get_Y() - p.get_X();
      // 圆的半径
      double rDistanceR = c.getRadius();
  
      // 分别计算：圆心X到点X的平方值，圆心Y到点Y的平方值，圆半径的平方值
      double powX = pow(ppDistanceX, 2);
      double powY = pow(ppDistanceY, 2);
      double powR = pow(rDistanceR, 2);
  
      // 等到判断关系值 （x - x1）^2 + (y - y1)^2 = r^2
      double ppDistance = powX + powY;
      double rDistance = powR;
  
  
      if (ppDistance == rDistance)
      {
          cout << "Point On The Circle" << endl;
      }
      else if (ppDistance < rDistance)
      {
          cout << "Point Within The Circle" << endl;
      }
      else if (ppDistance > rDistance)
      {
          cout << "Point Outside The Circle" << endl;
      }
  }
  
  int main()
  {
      // 实例化一个圆
      Circle c{};
      // 实例化一个圆心的坐标 和 点的坐标
      Point p_center{};
      Point p{};
  
      p_center.set_X(10.0);
      p_center.set_Y(0);
      p.set_X(10.0);
      p.set_Y(10.0);
      c.setRadius(10.0);
      c.setCenter(p_center);
  
      calculateCircleAndPoint(c, p);
  
      return 0;
  }
  ```

  



#### 4.2 对象初始化和清理

- C++中每个对象都有初始设置以及对象销毁前的清理数据的设置



##### 1. 构造函数和析构函数

问题：

- 对象的初始化和清理是两个很重要的安全问题
- 一个对象或者变量没有初始化状态，使用的后果是未知的
- 使用完一个对象或变量，没有及时清理，也会造成安全问题

解决：

- C++利用构造函数和析构函数解决问题，这两个函数被编译器自动调用，完成对象的初始化和清理工作
- 对象的初始化和清理工作是编译器强制要求的，如果不提供构造函数和析构函数，编译器会提供编译器提供的构造函数和析构函数是空实现

含义：

- 构造函数：主要为创建对象时为对象的成员属性赋值，构造函数由编译器自动调用
- 析构函数：主要为对象销毁前系统自动调用，执行清理工作

构造函数语法：类名（）{};

1. 构造函数，没有返回值和void
2. 函数名称和类名相同
3. 构造函数可以有参数，所以可以重载
4. 程序在调用对象时，会自动调用构造函数，且只调用一次

析构函数语法：~ 类名（）{};

1. 析构函数，没有返回值和void
2. 函数名称和类名不相同，在前面加 ~
3. 构造函数部可以有参数，所以不可以重载
4. 程序在调用对象时，会自动调用析构函数，且只调用一次

示例：

```c++
#include <iostream>

using namespace std;

class Test
{
public:
    Test()
    {
        cout << "Test构造函数" << endl;
    }
    ~Test()
    {
        cout << "Test析构函数" << endl;
    }
};

void demo()
{
    Test t1;
}

int main()
{
    demo(); // 函数执行时调用构造函数，结束时调用析构函数
    Test t2; // 函数执行时调用构造函数
    system("pause"); // 程序在此处暂停，析构函数为被调用，按任意键后执行析构函数
    return 0;
}
```





##### 2. 构造函数分类及调用

- 分类：

  1. 按参数分为：有参构造，无参构造
  2. 按类型分为：普通构造，拷贝构造

- 调用：

  1. 括号法
  2. 显示法
  3. 隐式转换法

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  
  public:
      // 创建构造函数
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a)
      {
          age = a;
          cout << "Person有参构造函数" << endl;
      }
  
      Person(const Person &p) // 将对象的属性拷贝进来
      {
          age = p.age;
          cout << "Person拷贝构造函数" << endl;
      }
  
      ~Person()
      {
          cout << "Person无参析构函数" << endl;
      }
  
      int age;
  };
  
  // 调用构造函数
  void demo()
  {
      // 括号法调用
      // 注意：无参构造函数不用括号：Person p1(); 编译器会作为 void func(); 声明来处理，调用空实现的构造函数
      Person p1; // 无参构造函数
      Person p2(10); // 有参构造函数
      Person p3(p2); // 拷贝构造函数
  
      cout << "p2 age: " << p2.age << endl;
      cout << "p3 age: " << p3.age << endl;
  
      // 显示法调用
      Person p4;
      Person p5 = Person(20);
      Person p6 = Person(p5);
      // 注意 Person(20) 单独写出来为匿名对象，程序中无法使用，执行完会被系统立即回收
      // 注意 不用拷贝函数初始化匿名对象，Person(p6) 编译器等价于 Person p6 , 而 Person p6 已经作为对象被实例化了
  
      // 隐式转换法调用
      Person p7 = 10; // 等价于 Person p7 = Person(10);
      Person p8 = p7;
  
      system("pause");
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  



##### 3. 拷贝构造函数调用时机

- C++中拷贝构造函数调用时机三种情况	

  1. 使用一个已经创建的对象来初始化一个新对象
  2. 值传递的方式给函数参数传值
  3. 以值方式返回局部对象

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_age;
  
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a)
      {
          p_age = a;
          cout << "Person有参构造函数" << endl;
      }
  
      Person(const Person &person)
      {
          p_age = person.p_age;
          cout << "Person拷贝构造函数" << endl;
      }
  
      ~Person()
      {
          cout << "Person无参析构函数" << endl;
      }
  };
  
  //1. 使用一个已经创建的对象来初始化一个新对象
  void demo1()
  {
      Person p1(10); // 有参构造
      Person p2(p1); // 拷贝构造
      cout << "p2 age: " << p2.p_age << endl;
  }
  
  //2. 值传递的方式给函数参数传值
  void test2(Person person)
  {
  
  }
  
  void demo2()
  {
      Person p3; // 默认构造
      test2(p3); // 拷贝构造 - 此处 p3 为p3对象的副本（拷贝）
  }
  
  //3. 以值方式返回局部对象
  Person test3()
  {
      Person p4; // 默认构造
      cout << "p4 address: " << (int *) &p4 << endl;
      return p4; // 此处 p4 为p4对象的副本（拷贝）
  }
  
  void demo3()
  {
      Person p5 = test3(); // 拷贝构造 - 得到 p4 的对象副本
      cout << "p5 address: " << (int *) &p5 << endl;
  }
  
  int main()
  {
      //demo1();
      //demo2();
      demo3();
      return 0;
  }
  ```





##### 4. 构造函数调用规则

- 默认情况下，C++编译器至少给一个类添三个函数

  1. 默认构造函数（无参，函数体为空）
  2. 默认析构函数（无参，函数体为空）
  3. 默认拷贝构造函数 对类实例化的对象的属性值拷贝

- 调用规则：

  1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数
  2. 如果自定义拷贝构造函数，编译器不提供其他构造函数

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_age;
  
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a)
      {
          p_age = a;
          cout << "Person有参构造函数" << endl;
      }
  
      Person(const Person &person)
      {
          p_age = person.p_age;
          cout << "Person拷贝构造函数" << endl;
      }
  
      ~Person()
      {
          cout << "Person无参析构函数" << endl;
      }
  };
  
  //1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数
  void demo1() // 默认构造函数不会被调用
  {
      Person p1(10);
      Person p2(p1);
  }
  
  //2. 如果自定义拷贝构造函数，编译器不提供其他构造函数
  void demo2() // 自定义拷贝构造函数后，其他构造函数需自己添加
  {
   Person p3;
   Person p4(p3);
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```

  



##### 5. 深拷贝和浅拷贝

- 深拷贝：在堆区重新申请空间，进行拷贝操作

- 浅拷贝：简单的赋值拷贝（编译器默认提供的拷贝构造函数就是浅拷贝）

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_age;
      int *p_height;
  
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a, int height)
      {
          cout << "Person有参构造函数" << endl;
          p_age = a;
          p_height = new int(height);
      }
  
      // 通过深拷贝的方法解决浅拷贝带来的问题 深拷贝定义后，编译器默认执行该构造函数
      Person(const Person &person)
      {
          cout << "Person拷贝构造函数" << endl;
          p_age = person.p_age;
          p_height = new int(*person.p_height); // 自定义的赋值方式，堆中开辟空间
          //p_height = person.p_height; // 编译器默认的赋值方式
      }
  
  // 浅拷贝时，p2 内的 p_height 被释放，p1 无可释放，程序执行非法操作（报错）
  // 深拷贝时，p2 内的 p_height 是单独的堆区空间被释放，不影响 p1 的 p_height 内存释放（正确）
      ~Person()
      {
          cout << "Person析构函数" << endl;
          if (p_height != NULL)
          {
              delete p_height;
              p_height = NULL;
          }
      }
  };
  
  void demoTest() // 栈区内存释放的顺序是先进后出，所以析构函数 释放内存是从 p2 开始
  {
      Person p1(10, 170);
      cout << "p1 age: " << p1.p_age << " p1 height: " << *p1.p_height << endl;
      Person p2(p1); // 编译器提供的浅构造函数，解析的是p1指针指向的内存空间
      cout << "p2 age: " << p2.p_age << " p2 height: " << *p2.p_height << endl;
  }
  
  int main()
  {
      demoTest();
      return 0;
  }
  ```

  



##### 6. 初始化列表

- 作用：C++提供初始化列表，用来初始化属性

- 语法：构造函数（）：属性1（值1），属性2（值2）... {}

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_a;
      int p_b;
  
      // 通过有参构造函数初始化属性值
  //    Person(int a, int b)
  //    {
  //        p_a = a;
  //        p_b = b;
  //    }
  
  // 通过初始化列表来初始化属性值
      Person(int a, int b) : p_a(a), p_b(b)
      {
  
      }
  };
  
  int main()
  {
      Person p1(10, 20);
      cout << "p1 a: " << p1.p_a << endl;
      cout << "p1 b: " << p1.p_b << endl;
  
      return 0;
  }
  ```

  



##### 7. 类对象作为类成员

- C++类中的成员可以说另一个类的对象，称为：对象成员

- 例如：

  ```c++
  class A {}
  class B
  {
      A a;
  }
  ```

- B类中有对象作为成员，A为对象成员

- 程序执行时，先构造A，再构造B

- 程序结束时，先析构B，再析构A

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Phone
  {
  public:
      string p_Name;
  
      Phone(string name)
      {
          cout << "Phone 构造函数调用 (先构造)" << endl;
          p_Name = name;
      }
  
      ~Phone()
      {
          cout << "Phone 析构函数调用" << endl;
      }
  };
  
  class Human
  {
  public:
      string h_Name;
      Phone h_Phone;
  
      Human(string name, string phone) : h_Name(name), h_Phone(phone)
      {
          cout << "Human 构造函数调用" << endl;
      }
  
      ~Human()
      {
          cout << "Human 析构函数调用 (先析构)" << endl;
      }
  
  };
  
  void demo()
  {
      Human h("FH", "Apple");
      cout << "Name: " << h.h_Name << " Phone: " << h.h_Phone.p_Name << endl;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  



##### 8. 静态成员

- 定义：在成员变量和成员函数前加关键字static，称为静态成员

- 分类：

  1. 静态成员变量
     - 所有对象共享一份数据
     - 在编译阶段分配内存
     - 类内声明，类外初始化
  2. 静态成员函数
     - 所有对象共享一个函数
     - 静态成员函数只能访问静态成员变量

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      static int p_num; // 静态成员变量 类内声明
  
      static void func() // 静态成员函数
      {
          p_num = 100;
          cout << "num: " << p_num << endl;
      }
  
  private: // 静态成员变量的访问权限可以为私密 类外无法访问
      static void func2()
      {
          cout << "private func2" << endl;
      }
  };
  
  int Person::p_num = 0; // 静态成员变量 类外初始化
  
  int main()
  {
      // 通过对象访问
      Person p;
      p.func();
  
      // 通过类名访问 （静态成员函数可以直接通过类的作用域直接调用）
      Person::func();
  
      return 0;
  }
  ```

  





#### 4.3 对象模型和this指针



##### 1. 成员变量和成员函数分开存储

- C++中，类内的成员变量和成员函数分开存储

- 只有非静态成员变量才属于类的对象上

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class demo1
  {
      // 空对象 默认 占内存空间 1
  };
  
  class demo2
  {
      int num = 0; // 非空对象 占内存空间 依据成员变量
  };
  
  class demo3
  {
      int num3 = 0;
      static int s_num; // 静态成员变量 不在类的对象上
  
      void func()
      {
          // 成员函数 不在类的对象上 (无论是否静态)
      }
  };
  
  int demo3::s_num = 0;
  
  void Test1()
  {
      cout << "Size of demo1: " << sizeof(demo1) << endl;
  }
  
  void Test2()
  {
      cout << "Size of demo2: " << sizeof(demo2) << endl;
  }
  
  void Test3()
  {
      cout << "Size of demo3: " << sizeof(demo3) << endl;
  }
  
  int main()
  {
      Test1();
      Test2();
      Test3();
  
      return 0;
  }
  ```

  



##### 2. this指针概念

- 作用：this指针指向被调用的成员函数所属对象

- this指针是隐含每个非静态成员函数的一种指针

- this指针不需定义，直接使用

- 用途：

  1. 当形参和成员变量同名时，可用this指针来区分
  2. 在类的非静态成员函数返回对象本身，可使用 return *this；

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int age;
  
      Person(int age)
      {
          // this可以区分相同名称的变量
          this->age = age;
      }
  
      //返回的是Person对象的引用
      Person &addPersonAge(Person &p)
      {
          this->age += p.age;
          return *this; // 返回对象为 *this
      }
  };
  
  void func1()
  {
      Person p1(10);
      cout << "p1 Age: " << p1.age << endl;
  }
  
  void func2()
  {
      Person p2(20);
      Person p3(20);
      // 链式编程思想
      // p3.addPersonAge(p2) 的执行结果是返回 对象的本身，所以可以链式调用成员函数
      p3.addPersonAge(p2).addPersonAge(p2).addPersonAge(p2);
      cout << "p3 Age: " << p3.age << endl;
  }
  
  int main()
  {
      func1();
      func2();
      return 0;
  }
  ```





##### 3. 空指针访问成员函数

- C++中空指针可以调用成员函数，但要注意是否用到this

- 如果用到this，需要加上判断，保证代码的安全

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Demo
  {
  public:
      int age = 10;
  
      void func1()
      {
          cout << "func1" << endl;
      }
  
      void func2()
      {
          // 为保证安全性，防止传入的空指针调用成员变量导致崩溃
          if (this == NULL)
          {
              return;
          }
          // 此处的this 《==》 this.age this是空的，无实际对象，无法调用
          cout << "func2 " << age << endl;
      }
  };
  
  void test()
  {
      // 创建一个对象的地址为空
      Demo *d = NULL;
      d->func1();
      d->func2();
  }
  
  int main()
  {
      test();
      return 0;
  }
  ```






##### 4. const修饰成员函数

- 常函数：

  1. 成员函数后加const，该函数称为常函数
  2. 常函数内不可以修改成员属性
  3. 成员属性声明时加关键字mutable，在常函数中依然可以修改

- 常对象

  1. 声明对象前加const，则称为常对象
  2. 常对象只能调用常函数

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int age;
      // mutable 修饰的成员变量
      mutable int id;
  
      // this指针是指针常量，指针的指向不可修改
      // const Person *const this；
      // 常量函数的const 修饰的this指针 让this指针指向的值也不可修改
      void printAge() const
      {
          // this->age = 10;
  
          // 常函数可以修改 mutable的值
          this->id = 10;
      }
  
      void printID()
      {
  
      }
  };
  
  void demo()
  {
      // 常对象
      const Person p{};
  
      p.printAge();
      //p.printID(); // 常对象只能调用 常函数
  
      //p.age = 100; // 常对象内的成员变量属性值不能修改
      p.id = 100; // 常对象内的mutable成员变量属性值能修改
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```







#### 4.4 友元

- 作用：目的是让一个函数或者类访问另一个类中的私有成员
- 关键字：friend
- 实现：
  1. 全局函数做友元
  2. 类做友元
  3. 成员函数做友元
  
  



##### 1. 全局函数做友元

```c++
#include <iostream>

using namespace std;

class Room
{
    // 将一个全局函数 在类中 通过friend关键在修饰 声明后，该全局函数可以访问 类中私有的成员变量属性
    friend void Func_Friend(Room *room);
private:
    string privateRoom;

public:
    string publicRoom;

    Room()
    {
        privateRoom = "privateRoom Access Succeeded";
        publicRoom = "publicRoom Access Succeeded";
    }
};

void Func_Friend(Room *room)
{
    cout << "Friend Function Access: " << room->publicRoom << endl;
    // 声明友元后，可以正常访问类中的私有成员变量
    cout << "Friend Function Access: " << room->privateRoom << endl;
}

void Test()
{
    Room room;
    Func_Friend(&room);
}

int main()
{
    Test();
    return 0;
}
```





##### 2. 类做友元

```c++
#include <iostream>

using namespace std;

// 先声明一个 Service类
class Service;

class User
{
private:
    // 定义一个 私有 Service类对象的指针
    Service *service;

public:
    // 构造函数和成员函数写在类外
    User();
    void access();
};

class Service
{
    // 将 User类 声明为 Service类的友元类 使得User类的对象是 Service类得到友元对象，可以访问私有成员变量的属性
    friend class User;
private:
    string priContent;

public:
    string pubContent;

    // 构造函数声明在外
    Service();
};

// 通过User类的作用域创建一个User类的构造函数，初始化User类中的成员变量的属性值
User::User()
{
    // 创建一个Service类的对象指针
    service = new Service;
}

// 通过User类的作用域创建一个User类的成员函数
void User::access()
{
    cout << "User Access Service: " << service->pubContent << endl;
    // 当User类成为Service类的友元后，可以在User的函数内访问 Service类中的私有成员变量属性
    cout << "User Access Service: " << service->priContent << endl;
}

// 通过Service类的作用域创建一个Service类的构造函数
Service::Service()
{
    this->priContent = "priContent";
    this->pubContent = "pubContent";
}

void demo()
{
    User user;
    user.access();
}

int main()
{
    demo();
    return 0;
}
```





##### 3.成员函数做友元

```c++
#include <iostream>

using namespace std;

class Service;

class User
{
public:
    Service *service;

    User();

    void access1();
    void access2();
};

class Service
{
    // 通过friend关键字 声明User类中的成员函数access2() 是Service类的友元函数
    friend void User::access2();
private:
    string priContent;

public:
    string pubContent;

    Service();
};

// User类和Service类的构造函数和成员函数在类外创建，类内声明
User::User()
{
    service = new Service;
}

void User::access1()
{
    cout << "Access pubContent: " << service->pubContent << endl;
}

// 访问Service类中的私有成员变量的属性
void User::access2()
{
    cout << "Access priContent: " << service->priContent << endl;
}

Service::Service()
{
    priContent = "priContent";
    pubContent = "pubContent";
}

void demo()
{
    User user;
    user.access1();
    user.access2();
}

int main()
{
    demo();

    return 0;
}
```





#### 4.5 运算符重载

- 概念：对已有的运算符进行重新的定义，赋予另一种功能，以适应不同的数据类型



##### 1. 加号运算符重载

- 作用：实现两个自定义数据类型相加的运算

- 编辑器提供了通用名称：operator+

- 内置的不能使用运算符重载，只有自定义类型的可以使用

  ```c++
  //
  // Created by FHang on 2020/8/11.
  //
  #include <iostream>
  
  using namespace std;
  
  class Num
  {
  public:
      int num1;
      int num2;
  
      // 类中 成员函数 实现的 重载运算‘+’
      Num operator+(Num &n) const
      {
          Num my_n{};
          my_n.num1 = this->num1 + n.num1;
          my_n.num2 = this->num2 + n.num2;
          return my_n;
      }
  };
  
  // 全局函数 运算符重载的默认写法
  Num operator+(Num &n1, Num &n2)
  {
      Num my_n{};
      my_n.num1 = n1.num1 + n2.num1;
      my_n.num2 = n1.num2 + n2.num2;
      return my_n;
  }
  
  // 运算符函数 重载
  Num operator+(Num &n, int num)
  {
      Num my_n{};
      my_n.num1 = n.num1 + num;
      my_n.num2 = n.num2 + num;
      return my_n;
  }
  
  void demo1()
  {
      Num n1{};
      n1.num1 = 10;
      n1.num2 = 10;
  
      Num n2{};
      n2.num1 = 5;
      n2.num2 = 5;
  
      Num n3{};
      // 重载后的简化写法
      n3 = n1 + n2;
  
      // 成员函数 重载的默认写法
      // n3 = n1.operator+(n2);
  
      // 全局函数 重载的默认写法
      // n3 = operator+(n1, n2);
  
      cout << "Operator: n3 = n1 + n2 = " << n3.num1 << endl;
      cout << "Operator: n3 = n1 + n2 = " << n3.num2 << endl;
  }
  
  void demo2()
  {
      Num n4{};
      n4.num1 = 20;
  
      int num2 = 10;
  
      // 重载运算符函数的 重载写法 （Num类型 + int类型）
      Num n5 = n4 + num2;
  
      cout << "Operator: n5 = n4 + num2 = " << n5.num1 <<endl;
      cout << "Operator: n5 = n4 + num2 = " << n5.num2 <<endl;
  }
  
  int main()
  {
      demo1();
      demo2();
  
      return 0;
  }
  ```



##### 2. 左移运算符重载

- 作用：输出自定义的数据类型

- 左移运算符重载 最好在声明为全局函数

- 配合友元使用

  ```c++
  //
  // Created by Admin on 2021/4/29.
  //
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
      friend ostream &operator<<(ostream &c, Person &p);
  private:
      string name;
      int age{};
  
  public:
      Person(string name, int age);
  };
  
  Person::Person(string newName, int newAge)
  {
      name = newName;
      age = newAge;
  }
  
  ostream &operator<<(ostream &c, Person &p)
  {
      cout << "Person Name: " << p.name << endl;
      cout << "Person Age: " << p.age << endl;
      return c;
  }
  
  void demo()
  {
      Person p("FHang", 24);
      cout << p << endl;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  

##### 3. 递增运算符重载

- 需要配合 全局左移运算符 重载

- 配合使用 友元

- 前置重载 返回引用

- 后置重载 返回类内值

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class MyInt
  {
      friend ostream &operator<<(ostream &c, MyInt myInt);
  private:
      int my_num;
  
  public:
      MyInt()
      {
          my_num = 0;
      }
  
      // 重载 前置 ++ 运算符
      // 返回引用的目的是 仅对当前的对象进行计算，若是返回对象，则一次计算后，生成另一个新对象
      MyInt &operator++()
      {
          my_num++;
          return *this;
      }
  
      // 重载 后置 ++ 运算符
      // MyInt &operator++(int) => int 是 占位参数，告诉编译器，用于区分，前后置重载
      // 此处 返回值 不返回自身引用，该函数内 自身的引用指向的值 是临时变量，一次操作后，被回收，若是连续多次使用 后置 ++，便是访问NULL，非法操作
      MyInt operator++(int)
      {
          MyInt tempInt = *this;
          my_num++;
          return tempInt;
      }
  };
  
  // 全局重载 左移运算符
  ostream &operator<<(ostream &c, MyInt myInt)
  {
      cout << myInt.my_num;
      return c;
  }
  
  void demo1()
  {
      cout << "<---------demo1----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
  }
  
  void demo2()
  {
      cout << "<---------demo2----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
      cout << ++myInt << endl;
      cout << ++(++myInt) << endl;
      cout << myInt++ << endl;
      cout << myInt << endl;
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```



##### 4. 递减运算符重载

- 基本情况 同 递增运算符重载

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class MyInt
  {
      friend ostream &operator<<(ostream &c, MyInt myInt);
  private:
      int my_num;
  
  public:
      MyInt()
      {
          my_num = 10;
      }
  
      // 重置 前置 -- 返回引用
      MyInt &operator--()
      {
          my_num--;
          return *this;
      }
  
      // 重置 后置 -- 返回值
      MyInt operator--(int)
      {
          MyInt tempInt = *this;
          my_num--;
          return tempInt;
      }
  };
  
  // 全局重载 左移运算符
  ostream &operator<<(ostream &c, MyInt myInt)
  {
      cout << myInt.my_num;
      return c;
  }
  
  void demo1()
  {
      cout << "<---------demo1----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
  }
  
  void demo2()
  {
      cout << "<---------demo2----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
      cout << --myInt << endl;
      cout << --(--myInt) << endl;
      cout << myInt-- << endl;
      cout << myInt << endl;
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```



##### 5. 赋值运算符重载

- C++ 编译器至少给一个类添加4个函数

  1. 默认构造函数（无参，函数体为空）
  2. 默认析构函数（无参，函数体为空）
  3. 默认拷贝构造函数，对属性值进行值拷贝
  4. 赋值运算符 operator=，对属性值进行值拷贝

- 如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int *my_Age;
  
      explicit Person(int age)
      {
          my_Age = new int(age);
      }
  
      ~Person()
      {
          if (my_Age != nullptr)
          {
              delete my_Age;
              my_Age = nullptr;
          }
      }
  
      // 重载 赋值运算符 让每一个对象 都各自对应一块堆区，避免浅拷贝带来的多个对象指向同一堆区，在析构函数的作用下，重复释放堆区
      Person &operator=(Person &person)
      {
          // 编译器 默认 浅拷贝
          // my_Age = person.my_Age;
  
          // 1. 在 p2 = p1 中，p2在堆区中已有属性值，所以在进行深拷贝之前，先释放 p2 堆区
          if (my_Age != nullptr)
          {
              delete my_Age;
              my_Age = nullptr;
          }
  
          // 2. 进行 深拷贝
          my_Age = new int(*person.my_Age);
  
          return *this;
      }
  };
  
  void demo1()
  {
      Person p1(18);
      Person p2(24);
  
      // 该 赋值操作 为 浅拷贝
      p2 = p1;
  
      // 浅拷贝时 堆区 my_Age 占有 的内存 被析构函数 重复释放
      cout << *p1.my_Age << endl;
      cout << *p2.my_Age << endl;
  }
  
  void demo2()
  {
      Person p1(18);
      Person p2(24);
      Person p3(36);
  
      p3 = p2 = p1;
  
      cout << *p1.my_Age << endl;
      cout << *p2.my_Age << endl;
      cout << *p3.my_Age << endl;
  }
  
  int main()
  {
      // demo1();
      demo2();
      return 0;
  }
  ```



##### 6. 关系运算符重载

- 让自定义的两个对象类型进行比较操作

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      string my_Name;
      int my_Age;
  
      Person(string name, int age)
      {
          my_Name = std::move(name);
          my_Age = age;
      }
  
      // 重载 关系运算符 返回值类型可以为：int类型 0/1；或者 bool类型
      // 此次 重载的关系运算符为 ==，其他例如：!=, <, > ...同理
      int operator==(Person &person) const
      {
          if (this->my_Name == person.my_Name && this->my_Age == person.my_Age)
          {
              return 1;
          }
          return 0;
      }
  };
  
  void demo1()
  {
      Person p1("FH", 24);
      Person p2("HF", 24);
  
      // 此处 的 p1 == p2 是 p1.operator==(p2), 返回一个 bool类型 或者 0/1的int类型，进行if语句判断
      if (p1 == p2)
      {
          cout << "P1 = P2" << endl;
      }
      else
      {
          cout << "P1 != P2" << endl;
      }
  
      // 此次 得到的返回值为 int类型的 0/1，所以亦可采用 switch语句来xie
      switch (p1 == p2)
      {
          case 0:
              cout << "P1 != P2" << endl;
              break;
  
          case 1:
              cout << "P1 = P2" << endl;
      }
  }
  
  int main()
  {
      demo1();
      return 0;
  }
  ```



##### 7. 函数调用运算符重载

- 函数调用运算符（）也可重载

- 重载后使用的方式，类似函数的调用，被称为 “仿函数”

- 仿函数 的写法灵活，没有固定写法

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class FPrint
  {
  public:
      void operator()(const string &text)
      {
          cout << text << endl;
      }
  };
  
  class FAdd
  {
  public:
      void operator()(int num1, int num2)
      {
          cout << num1 + num2 << endl;
      }
  };
  
  void demo1()
  {
      FPrint fPrint;
      fPrint("Hello World !");
  }
  
  void demo2()
  {
      FAdd fAdd;
      fAdd(10, 20);
  
      // 匿名函数对象
      FAdd()(20, 40);
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```





#### 4.6 继承



##### 1. 继承的基本使用

- 继承的作用：减少编写重复的代码

- 继承的语法：

  ```c++
  class 子类 : 继承方式 父类 
  1. 子类 也叫 派生类 （derived class）
  2. 父类 也叫 基类 (base class)
  3. 继承方式：public
  ```

- 继承的演示：

  ```c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  // 公共页面 是 其子类页面 公用拥有的属性
  class BasePage
  {
  public:
      void pageHeader()
      {
          cout << " -首页 公开课 登陆 注册 (公共)" << endl;
      }
  
      void pageLeft()
      {
          cout << " -Java C# C/C++ Php Golang (公共)" << endl;
      }
  
      void pageFoot()
      {
          cout << " -帮助中心 交流合作 友链 (公共)" << endl;
      }
  };
  
  // 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容
  class JavaPage : public BasePage
  {
  public:
      JavaPage()
      {
          cout << "<<-- Java Web Page -->>" << endl;
      }
      
      ~JavaPage()
      {
          cout << endl;
      }
  
      void pageBody()
      {
          cout << " -Java_demo1 Java_demo2 Java_demo3 (Java)" << endl;
      }
  };
  
  // 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容
  class CPP : public BasePage
  {
  public:
      CPP()
      {
          cout << "<<-- C/C++ Web Page -->>" << endl;
      }
      
      ~CPP()
      {
          cout << endl;
      }
  
      void pageBody()
      {
          cout << " -C/C++_demo1 C/C++_demo2 C/C++_demo3 (C/C++)" << endl;
      }
  };
  
  void java_demo()
  {
      JavaPage javaPage;
      javaPage.pageHeader();
      javaPage.pageLeft();
      javaPage.pageBody();
      javaPage.pageFoot();
  }
  
  void cpp_demo()
  {
      CPP cpp;
      cpp.pageHeader();
      cpp.pageLeft();
      cpp.pageBody();
      cpp.pageFoot();
  }
  
  int main()
  {
      java_demo();
      cpp_demo();
      return 0;
  }
  ```



##### 2. 继承的方式

- 继承语法: class 子类 : 继承方式 父类

- 继承方式：

  1. 公共继承：public
  2. 保护继承：protected
  3. 私有继承：private

- 继承方式演示：

  ```c++
  // 父类中的 private 可以被 子类  任何继承方式 继承；但 ！ 子类 无法 访问 和 使用
  class Father
  {
  public:
      int a;
  protected:
      int b;
  private:
      int c;
  };
  
  class Son : public Father
  {
  // public继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 无改动；
  public:
      int a;
  protected:
      int b;
  };
  
  class Son : protected Father
  {
  // protected继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 protected
  protected:
      int a;
      int b;
  };
  
  class Son : private Father
  {
  // private继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 private
  private:
      int a;
      int b;
  };
  
  // 总结：
  // 父类的 private 可以被 任何 继承方式 继承；但 ！ 子类 无法 访问 和 使用
  // 子类通过某个 继承方式 继承 父类 后，父类中的 public，protected 中的成员变量 在子类中 以某种继承方式出现；
  ```

  

##### 3. 继承中的对象模型



###### 1. 验证子类模型

- 父类中的所有成员变量(非静态)，无论是什么权限保护的成员，都会被子类继承，但子类无法访问和使用

  ``` c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      int base_A;
  protected:
      int base_B;
  private:
      int base_C;
  };
  
  class Derived_1 : public Base
  {
  public:
      int derived_A;
  };
  
  void demo1()
  {
      Derived_1 derived1{};
      cout << sizeof(derived1) << endl;
  }
  
  int main()
  {
      demo1();
      return 0;
  }
  ```



###### 2. Developer Powershell - VS

- Visual Studio 提供的工具

- 使用方式：

  1. 首先找到上面的案例代码的所在文件位置
  2. 打开 Visual Studio 提供的 Developer Powershell
  3. 将工作路径切换到案例代码的所在文件路径
  4. 通过开发命令，查看案例代码中，子类对象的结构

- 使用步骤：

  ``` powershell
  # 切换路径 和 查看路径下 是否存在 案例代码 cpp 文件
  
  **********************************************************************
  ** Visual Studio 2019 Developer PowerShell v16.9.4
  ** Copyright (c) 2021 Microsoft Corporation
  **********************************************************************
  PS C:\Users\Admin\source\repos> D:
  PS D:\DevelopmentTool\VisualStudio\IDE> cd D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> ls
  
  
      目录: D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  
  
  Mode                 LastWriteTime         Length Name
  ----                 -------------         ------ ----
  -a----         2021/6/22     15:09           1515 Inherit_Base.cpp
  -a----         2021/6/22     15:42            397 Inherit_ObjectModel.cpp
  ```

  ``` powershell
  # 通过开发命令，查看案例代码中，子类对象的结构
  
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> cl /d1 reportSingleClassLayoutDerived_1 ".\Inherit_ObjectModel.cpp"
  用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
  版权所有(C) Microsoft Corporation。保留所有权利。
  
  Inherit_ObjectModel.cpp
  
  class Derived_1 size(16): # 此处可以看到 子类Derived_1对象的大小 和 之前的案例代码的打印结果一致
          +---
   0      | +--- (base class Base) # 子类Derived_1完全继承父类中所有成员 中的 base_A base_B  base_C
   0      | | base_A
   4      | | base_B
   8      | | base_C
          | +---
  12      | derived_A # 同时 子类Derived_1 自身的成员也在 derived_A
          +---
  
  # 总结：子类 Derived_1中 四个int类型的成员变量，占内存大小为16字节
  ```

  ``` powershell
  # 用到的指令
  
  # 切换盘符 到 案例代码 所在 的 盘
  D:
  
  # 切换到具体的路径地址
  cd D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  
  # 查看路径下 的 案例代码文件 Inherit_ObjectModel.cpp
  ls
  
  # 指定 报告单个类的布局 ：子类Deriverd_1
  # cl /d1 reportSingleClassLayout需要查看的类 "类所在的具体文件"
  cl /d1 reportSingleClassLayoutDerived_1 ".\Inherit_ObjectModel.cpp"
  ```



##### 4. 继承中构造和析构顺序

- 子类继承父类之后，当创建子类对象时，也会调用父类的构造和析构函数

- 案例验证，子类和父类的构造和析构函数的调用先后顺序

  ``` c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      Base()
      {
          cout << "Base Constructor Transfer" << endl;
      }
  
      ~Base()
      {
          cout << "Base Destructor Transfer" << endl;
      }
  };
  
  class Derived : public Base
  {
  public:
      Derived()
      {
          cout << "Derived Constructor Transfer" << endl;
      }
  
      ~Derived()
      {
          cout << "Derived Destructor Transfer" << endl;
      }
  };
  
  void demo()
  {
      Derived derived;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  ```powershell
  # 案例结果
  D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\cmake-build-debug\Code9_3.exe
  Base Constructor Transfer
  Derived Constructor Transfer
  Derived Destructor Transfer
  Base Destructor Transfer
  ```

- 由 案例结果 可以 看出

- 当创建子类时，子类和父类 的 构造和析构函数的调用 顺序

  1. 子类构造
  2. 父类构造
  3. 父类析构
  4. 子类析构



##### 5. 继承同名成员处理方式

- 继承时的问题：当子类和父类出现同名成员，如何通过子类对象，访问子类或父类的同名数据

  1. 访问子类同名成员，直接访问
  2. 访问父类同名成员，添加作用域

  ```c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      int num;
  
      Base()
      {
          num = 100;
      }
  
      void FPrint()
      {
          cout << "Base Print" << endl;
      }
  
      void FPrint(int n)
      {
          cout << "Base Print (int n) : Overload Function" << endl;
      }
  };
  
  class Derived : public Base
  {
  public:
      int num;
  
      Derived()
      {
          num = 200;
      }
  
      void FPrint()
      {
          cout << "Derived Print" << endl;
      }
  };
  
  void demo()
  {
      Derived derived;
      cout << "Derived num = " << derived.num << endl;
      cout << "Base num = " << derived.Base::num << endl;
      derived.FPrint();
      derived.Base::FPrint();
  
      // 当父类和子类中，存在同名成员时，会默认隐藏父类的成员，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用
      // derived.FPrint(10); // 父类被隐藏，所以直接传参也无法找到 重载的函数，因为子类没有 FPrint的重载函数
      derived.Base::FPrint(10); // 加上 父类作用域后 可调用
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

- 解决方法：

  1. 子类对象可以直接访问到子类同名成员
  2. 子类对象加上作用域可以访问到父类同名成员
  3. 当子类和父类拥有同名的成员函数，子类会隐藏父类同名成员函数，子类加作用域可以访问到父类中同名函数