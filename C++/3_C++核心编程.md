

#  C++核心编程



### 1. 内存分区模型

C++程序在执行时，内存大方向划分为4个区域

- 代码区：存放函数的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
-  栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若不释放，程序执行结束后会系统回收



内存分区的意义：

- 不同区域存放的数据，赋予不同的生命周期



#### 1.1 程序运行前

程序编译后，生成可执行的 .exe 文件 未执行前，分成两个区域

代码区：

- 存放CPU执行的机器指令
- 代码区是共享的，目的是对于频繁的执行程序，只需在内存中存放一份即可
- 代码区是只读的，目的是防止程序意外的修改了它的指令

全局区：

- 全局变量和静态变量存放其中
- 全局区还包括了常量区，字符串常量和其他常量也存放其中
- 该区域的数据在程序结束后由操作系统释放



分类：

- 全局区：全局变量，静态变量，常量
- 常量区：const修饰的全局变量，字符串常量
- 局部区：局部变量，const修饰的局部变量和常量

代码：

```c++
#include <iostream>

using namespace std;

//Global variable outside Function
int g_a = 10;
int g_b = 20;

//Global constant variable outside Function
const int g_c_a = 10;
const int g_c_b = 20;

int main()
{
    //Local variable inside Function
    int l_a = 10;
    int l_b = 20;

    //Static variable
    static int s_a = 10;
    static int s_b = 20;

    //Constant Local variable inside Function
    const int l_c_a = 10;
    const int l_c_b = 20;

    //Debug local variable
    cout << "Local Area_Local variable l_a: " << (int) &l_a << endl;
    cout << "Local Area_Local variable l_b: " << (int) &l_b << endl;

    //Debug constant local variable
    cout << "Local Area_Constant local variable l_c_a:" << (int) &l_c_a << endl;
    cout << "Local Area_Constant local variable l_c_b:" << (int) &l_c_b << endl;

    //Debug global variable
    cout << "Global Area_Global variable g_a: " << (int) &g_a << endl;
    cout << "Global Area_Global variable g_b: " << (int) &g_b << endl;

    //Debug static variable
    cout << "Global Area_Static variable s_a: " << (int) &s_a << endl;
    cout << "Global Area_Static variable s_b: " << (int) &s_b << endl;

    //Debug string constant
    cout << "Global Area_String constant str_c_a:" << (int) &"Hello World" << endl;

    //Debug global constant variable
    cout << "Global Area_global constant variable g_c_a:" << (int) &g_c_a << endl;
    cout << "Global Area_global constant variable g_c_b:" << (int) &g_c_b << endl;

    return 0;
}
```





#### 1.2 程序运行后

- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等

- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  //定义一个返回值int类型的函数
  int *demoFunc()
  {
      //定义一个局部变量，存在栈区中
      int a = 10;
      //返回一个局部变量的地址
      return &a;
  }
  
  int main()
  {
      //接受局部变量传来的地址
      int *p_a = demoFunc();
  
      cout << *p_a << endl; //第一次能正常的解析地址对应的值，函数执行结束，系统回收了数据
      cout << *p_a << endl; //第二次，无法正常解析到对应的值，因为函数执行一次结束后，没有返回值了
  }
  ```
  
- 堆区：由程序员释放，若不释放，程序结束时由操作系统回收

- 方式：C++通过 new 在堆区中开辟内存

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int *demoFunc()
  {
      //通过指针地址存放 new 关键字对int类型的值在堆中开辟的内存所在的地址
      //这个 int的值存放在堆中，改函数执行结束后，依然存在
      int *p_a = new int(10);
      return p_a;
  }
  
  int main()
  {
      int *p_a = demoFunc();
      cout << *p_a << endl;
      cout << *p_a << endl; //函数执行结束后，指针指向的指针内存空间依然存在，所以可以正常得到内存中的值
      return 0;
  }
  ```





1.3 new操作符

- C++ 通过 new 在堆区开辟数据
- 堆区的数据，由程序员手动开辟，手动释放，利用 delet 操作符
- 语法：`new 数据类型（）；`
- 利用new创建的数据，会返回该数据对应的类型的指针地址

示例：

```c++
#include <iostream>

using namespace std;

//创建一个返回int类型的地址函数
int *newKeyDemo()
{
    //new操作符开辟的数据会返回一个指针
    int *p_a = new int(10);
    //返回指针
    return p_a;
}

void printDemo1Info()
{
    //创建一个指针接受返回值
    int *Info1 = newKeyDemo();
    cout << *Info1 << endl;
    //delete 操作符会释放 new在堆中的数据
    delete Info1;
    cout << *Info1 << endl;
}

//利用new操作符创建数组
void printDemo2Info()
{
    int *p_arr = new int[10];

    for (int i = 0; i < 10; i++)
    {
        p_arr[i] = i + 1;
    }

    for (int j = 0; j < 10; j++)
    {
        cout << p_arr[j] << " ";
    }

    delete[] p_arr;
}

int main()
{
    printDemo1Info();
    printDemo2Info();
    return 0;
}
```





### 2. 引用



#### 2.1 引用的基本使用

- 作用：给变量起别名

- 语法：`数据类型 &别名 = 原名；`

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int main()
  {
      int a = 10;
      int &b = a;
  
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
  
      b = 20;
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
      return 0;
  }
  ```





#### 2.2 引用注意事项

- 引用必须初始化

- 引用在初始化后不可以改变

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int main()
  {
      int a = 10;
      int c = 10;
      //int &b; 引用必须初始化
      int &b = a;
      //int &b = c; 引用初始化后不可更改
      return 0;
  }
  ```

  



#### 2.3 引用做函数参数

- 作用：函数传参时，可以利用引用的技术让形参修饰实参

- 优点：可以简化指针修改实参

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void swap01(int a, int b)
  {
      int temp = a;
      a = b;
      b = temp;
  }
  
  void swap02(int *p_a, int *p_b)
  {
      int temp = *p_a;
      *p_a = *p_b;
      *p_b = temp;
  }
  
  void swap03(int &a, int &b)
  {
      int temp = a;
      a = b;
      b = temp;
  }
  
  int main()
  {
      int a = 10;
      int b = 20;
  
  //    swap01(a, b); 值传递，形参不修饰实参
  //    swap02(&a, &b); 地址传递，形参修饰实参
      swap03(a, b); // 引用传递，形参修饰实参
  
      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
      return 0;
  }
  ```





#### 2.4 引用做函数的返回值

- 作用：引用可以作为函数的返回值

- 注意：不要返回局部变量引用

- 用法：函数调用作为左值

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  int &demo1()
  {
      int a = 10; //函数体内定义的局部变量，函数执行完后，系统自动回收
      return a;
  }
  
  int &demo2()
  {
      static int b = 20; //static 修饰的静态变量，存储在全局区，整个程序执行完后，系统自动回收
      return b;
  }
  
  int main()
  {
      int &ref_a = demo1();
      int &ref_b = demo2();
      cout << "ref_a = " << ref_a << endl;
      cout << "ref_a = " << ref_a << endl;
  
      cout << "ref_b = " << ref_b << endl;
      cout << "ref_b = " << ref_b << endl;
  
      demo2() = 1000; //函数的调用是引用，可以作为左值
      cout << "ref_b = " << ref_b << endl;
      cout << "ref_b = " << ref_b << endl;
  
      return 0;
  }
  ```

  



#### 2.5 引用的本质

- 本质：在C++内部实现一个指针常量

- 示例：

  ```c++
  #include <iostream>
  using namespace std;
  // 转换为 int *const ref_b = &a
  void demo1(int &ref_b)
  {
      ref_b = 100;
  }
  
  int main()
  {
      int a = 10;
      // 自动转换为 int *const ref_a = &a; << = >> 指针常量；因为指针的指向（地址）不可改变，所以引用的初始化后不可更改
      int &ref_a = a;
      // ref是引用，自动转换成 *ref = 20；
      ref_a = 20;
    
      cout << "a = " << a << endl;
      cout << "ref_a = " << ref_a << endl;
    
      demo1(ref_a);
    
      return 0;
  }
  ```

- 结论：引用本质是指针，使用方便






#### 2.6 常量引用

- 作用：常量引用一般用来修饰形参，防止误操作

- 使用：在函数形参列表中，可以加 const 修饰形参，防止形参被实参修改

- 示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  void printInfo(const int &ref_b)
  {
      //常量引用的值不可以修改
      //ref_b = 1000;
      cout << "ref_b = " << ref_b << endl;
  }
  
  int main()
  {
      // 编辑器 转换为 int temp = 10;   const int &a = temp;
      //const int &ref_a = 10;
      // ref_a 用 const 修饰后值不能被修改
      //ref_a = 20;
  	int a = 100;
  	printInfo(a);
  	cout << "a = " << a << endl;
  	return 0;
  }
  ```







### 3. 函数进阶



#### 3.1 函数默认参数

- 在C++中，函数的形参列表中的形参可以有默认值

- 语法：`返回值类型 函数名 （参数 = 默认值）{}`

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 无默认值参数，通过调用函数传入参数值
  int func01(int a, int b, int c)
  {
      return a + b + c;
  }
  
  // 有默认值参数，可以通过调用函数传入参数值，也可以不传参数值
  int func02(int a = 10, int b = 20, int c = 30)
  {
      return a + b + c;
  }
  
  // 当函数定义中，有默认参数值的一项形参，其之后的其他形参也要有形参
  //int func03(int a = 10, int b, int c)
  //{
  //    return a + b + c;
  //}
  
  // 函数在声明时，形参有默认值，定义时，形参不得定义默认值
  int func04(int a = 10, int b = 20);
  
  //int func04(int a = 20, int b = 10)
  //{
  //    return a + b;
  //}
  
  
  int main()
  {
      cout << "Func01: " << func01(10, 20, 30) << endl;
      cout << "Func02: " << func02() << endl;
      return 0;
  }
  ```

  



#### 3.2 函数占位参数

- C++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

- 占位参数可以有默认值

- 语法：`返回值类型 函数名 （数据类型）{}；`

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 占位参数可以有默认值
  void func1(int a, int = 10)
  {
      cout << "Func1 Test" << endl; 
  }
  
  int main()
  {
      // 有默认值可以不传实参，否则占位参数也要传实参
      func1(10, 10);
      return 0;
  }
  ```





#### 3.3 函数重载



##### 3.3.1 函数重载概述

- 作用：函数名可以重复，提高复用性

- 条件：

  1. 同一作用域下
  2. 函数名相同
  3. 函数参数类型不同 或 个数不同 或 顺序不同

- 注意：函数的返回值不可以作为函数重载的条件

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void func()
  {
      cout << "func()" << endl;
  }
  
  void func(int a)
  {
      cout << "func(int a)" << endl;
  }
  
  void func(int a, int b)
  {
      cout << "func(int a, int b)" << endl;
  }
  
  void func(int a, double b)
  {
      cout << "func(int a, double b)" << endl;
  }
  
  // 返回值不可以作为函数重载的条件
  //int func()
  //{
  //    cout << "func()" << endl;
  //}
  
  int main()
  {
      func();
      func(10);
      func(10, 20);
      func(10, 20.20);
      return 0;
  }
  ```

  



##### 3.3.2 函数重载注意事项

- 引用作为重载条件

- 函数重载碰到函数默认参数

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void func()
  {
      cout << "func()" << endl;
  }
  
  void func(int &a)
  {
      cout << "func(int &a)" << endl;
  }
  
  void func(const int &a)
  {
      cout << "func(const int &a)" << endl;
  }
  
  void func(int &a, int &b)
  {
      cout << "func(int &a, int &b)" << endl;
  }
  
  void func2(int a)
  {
      cout << "func2(int a)" << endl;
  }
  
  void func2(int a, int b = 10)
  {
      cout << "func(int a, int b = 10)" << endl;
  }
  
  
  int main()
  {
      int a = 10;
      int b = 20;
  
      func();
      func(a);
      func(10);
      func(a, b);
  
      // func2 函数有重载，且其中一个参数有默认值
      //func2(a);
  
      return 0;
  }
  ```





### 4. 类和对象

- C++面向对象的三大特性：封装，继承，多态



#### 4.1 封装



##### 4.1.1 封装的意义

- 意义一：

  1. 将属性和行为作为一个整体，表现生活中的事物
  2. 将属性和行为加以权限控制
  3. 在设计类时，属性和行为写在一起，表现事物

- 语法：`class 类名 { 访问权限：属性 / 行为 }；`

- 示例1：设计一个圆，求圆的周长

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 类名 （圆）
  class Circle
  {
      // 权限（公开）
  public:
      // 属性
      const double Pi = 3.14;
      double cir_R;
  
      // 计算圆周长的函数
      double calculatePerimeter()
      {
          return  2 * Pi * cir_R;
      }
  };
  
  int main()
  {
      // 通过Circle类创建一个实例（对象） c1
      Circle c1;
      // 通过对象，对类中的属性 cir_R 进行赋值 
      c1.cir_R = 10.0;
      double value = c1.calculatePerimeter();
      cout << "Circle perimeter : " << value << endl;
  
      return 0;
  }
  ```

- 示例2：设计一个学生类，属性有姓名和学号，对属性进行赋值，并显示属性信息（两种写法）

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Student
  {
  public:
      string stu_Name;
      int stu_ID;
  
      void printStudentInfo()
      {
          cout << "Student Info : " << endl;
          cout << "Name: " << stu_Name << "  ID: " << stu_ID << endl;
      }
  };
  
  
  int main()
  {
      Student s1;
      s1.stu_ID = 123456;
      s1.stu_Name = "FH";
      s1.printStudentInfo();
  
      return 0;
  }
  ```

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Student
  {
  public:
      string stu_Name;
      int stu_ID;
  
      void setName(string name)
      {
          stu_Name = name;
      }
  
      void setID(int id)
      {
          stu_ID = id;
      }
  
      void printStudentInfo()
      {
          cout << "Student Info : " << endl;
          cout << "Name: " << stu_Name << "  ID: " << stu_ID << endl;
      }
  };
  
  
  int main()
  {
      Student s1;
      s1.setName("FH");
      s1.setID(123456);
      s1.printStudentInfo();
  
      Student s2;
      s2.setName("CYL");
      s2.setID(666666);
      s2.printStudentInfo();
  
      return 0;
  }
  ```

- 意义二：不属性和行为放在不同的权限下，加以控制

- 访问权限三种：

  | public 公开    | 成员类内可访问，类外可访问   | 子类可访问           |
  | -------------- | ---------------------------- | -------------------- |
  | protected 保护 | 成员类内可访问，类外不可访问 | 子类可访问保护内容   |
  | private 私有   | 成员类内可访问，类外不可访问 | 子类不可访问私有内容 |

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      string name;
  
  protected:
      string car;
  
  private:
      int password;
  
  private:
      void func()
      {
          name = "FH";
          car = "XXX";
          password = 123456;
      }
  };
  
  
  int main()
  {
      Person p1;
      p1.name = "CYL";
  
      //p1.car = "YYY"; // 保护权限内容，类外不可访问和修改
      //p1.password = 999999; // 私有权限内容，类外不可访问和修改
      return 0;
  }
  ```

  



##### 4.1.2 struct和class区别

- 区别：struct 默认权限为公开；class默认权限为私有

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class C1
  {
      int a;
  };
  
  struct C2
  {
      int a;
  };
  
  int main()
  {
      C1 c1;
      C2 c2;
      
      //c1.a = 10; // class默认私有，无法访问
      c2.a = 10; // struct默认公开，可以访问
      
      return 0;
  }
  ```





##### 4.1.3 成员属性私有化

- 优点：

  1. 将所有成员属性设置为私有，可以自己控制读写权限
  2. 对于写权限，可以检测数据的有效性

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      void setName(string name)
      {
          p_Name = name;
      }
      string getName()
      {
          return p_Name;
      }
  
      int getAge()
      {
          p_Age = 24;
          return p_Age;
      }
  
      void setID(int id)
      {
          p_ID = id;
      }
  
  private:
      string p_Name; // 可读可写
      int p_Age; // 可读
      int p_ID; // 可写
  };
  
  int main()
  {
      Person p;
      p.setName("FH");
      p.setID(123455);
      cout << "Name: " << p.getName() << endl;
      cout << "Age: " << p.getAge() << endl;
  
      return 0;
  }
  ```





##### 4.1.4 案例：设计立方体

- 要求：设计立法体类（cube），求面积和体积，分别用全局函数和成员函数判断两个立方体是否相等

- 代码：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Cube
  {
  private:
      float c_Length = 1.0;
      float c_Width = 1.0;
      float c_Height = 1.0;
  
  public:
      void setLength(float length)
      {
          c_Length = length;
      }
  
      float getLength() const
      {
          return c_Length;
      }
  
      void setWidth(float width)
      {
          c_Width = width;
      }
  
      float getWidth() const
      {
          return c_Width;
      }
  
      void setHeight(float height)
      {
          c_Height = height;
      }
  
      float getHeight() const
      {
          return c_Height;
      }
  
      float calculateArea() const
      {
          return 2 * c_Length * c_Width + 2 * c_Length * c_Height + 2 * c_Width * c_Height;
      }
  
      float calculateVolume() const
      {
          return c_Height * c_Width * c_Length;
      }
  
      // 成员函数判断两个立方体是否相等
      string calculateSameFromClass(Cube &c) const
      {
          if (c.getLength() == c_Length && c.getWidth() == c_Width && c.getHeight() == c_Height)
          {
              return "Class_Same!!!";
          }
          return "Class_No Same!!!";
      }
  };
  
  // 全局函数判断两个立方体是否相等
  string calculateSameFromGlobal(Cube &c1, Cube &c2)
  {
      if (c1.getHeight() == c2.getHeight() && c1.getWidth() == c2.getWidth() && c1.getLength() == c2.getLength())
      {
          return "Global_Same!!!";
      }
      return "Global_No Same!!!";
  }
  
  int main()
  {
      Cube c1;
      Cube c2;
      Cube c3;
  
      c1.setHeight(10.0);
      c1.setLength(10.0);
      c1.setWidth(10.0);
  
      c2.setHeight(10.0);
      c2.setLength(10.0);
      c2.setWidth(10.0);
  
      c3.setHeight(20.0);
      c3.setLength(20.0);
      c3.setWidth(20.0);
  
      // 存储立方体的面积以及体积返回的值
      float cube_Area = c1.calculateArea();
      float cube_Volume = c1.calculateVolume();
  
      // 存储两种函数等到的判断返回结果
      string global_Same = calculateSameFromGlobal(c1, c2);
      string class_Same = c1.calculateSameFromClass(c3);
  
      cout << "Cube Area: " << cube_Area << endl;
      cout << "Cube Volume: " << cube_Volume << endl;
  
      cout << "Global_Same: " << global_Same << endl;
      cout << "Class_Same: " << class_Same << endl;
  
      return 0;
  }
  ```





##### 4.1.5 案例：点圆的关系

- 要求：设计圆类（Circle）设计点类（Point），计算点和圆的包含关系（圆外）（圆上）（圆内）（圆心）

- 代码：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  // 点类
  class Point
  {
  private:
      // 点X坐标
      double p_X;
      // 点Y坐标
      double p_Y;
  
  public:
      void set_X(double x)
      {
          p_X = x;
      }
      double get_X() const
      {
          return p_X;
      }
  
      void set_Y(double y)
      {
          p_Y = y;
      }
      double get_Y() const
      {
          return p_Y;
      }
  };
  
  // 圆类
  class Circle
  {
  private:
      // 圆的半径
      double c_Radius;
      // 圆心的坐标
      Point c_Center;
  
  public:
      void setRadius(double radius)
      {
          c_Radius = radius;
      }
      double getRadius() const
      {
          return c_Radius;
      }
  
      void setCenter(Point &center)
      {
          c_Center = center;
      }
      Point getCenter()
      {
          return c_Center;
      }
  };
  
  // 计算圆与点之间的关系
  void calculateCircleAndPoint(Circle &c, Point &p)
  {
      // 圆心点X - 点X
      double ppDistanceX = c.getCenter().get_X() - p.get_X();
      // 圆心点Y - 点Y
      double ppDistanceY = c.getCenter().get_Y() - p.get_X();
      // 圆的半径
      double rDistanceR = c.getRadius();
  
      // 分别计算：圆心X到点X的平方值，圆心Y到点Y的平方值，圆半径的平方值
      double powX = pow(ppDistanceX, 2);
      double powY = pow(ppDistanceY, 2);
      double powR = pow(rDistanceR, 2);
  
      // 等到判断关系值 （x - x1）^2 + (y - y1)^2 = r^2
      double ppDistance = powX + powY;
      double rDistance = powR;
  
  
      if (ppDistance == rDistance)
      {
          cout << "Point On The Circle" << endl;
      }
      else if (ppDistance < rDistance)
      {
          cout << "Point Within The Circle" << endl;
      }
      else if (ppDistance > rDistance)
      {
          cout << "Point Outside The Circle" << endl;
      }
  }
  
  int main()
  {
      // 实例化一个圆
      Circle c{};
      // 实例化一个圆心的坐标 和 点的坐标
      Point p_center{};
      Point p{};
  
      p_center.set_X(10.0);
      p_center.set_Y(0);
      p.set_X(10.0);
      p.set_Y(10.0);
      c.setRadius(10.0);
      c.setCenter(p_center);
  
      calculateCircleAndPoint(c, p);
  
      return 0;
  }
  ```

  



#### 4.2 对象初始化和清理

- C++中每个对象都有初始设置以及对象销毁前的清理数据的设置



##### 4.2.1 构造函数和析构函数

问题：

- 对象的初始化和清理是两个很重要的安全问题
- 一个对象或者变量没有初始化状态，使用的后果是未知的
- 使用完一个对象或变量，没有及时清理，也会造成安全问题

解决：

- C++利用构造函数和析构函数解决问题，这两个函数被编译器自动调用，完成对象的初始化和清理工作
- 对象的初始化和清理工作是编译器强制要求的，如果不提供构造函数和析构函数，编译器会提供编译器提供的构造函数和析构函数是空实现

含义：

- 构造函数：主要为创建对象时为对象的成员属性赋值，构造函数由编译器自动调用
- 析构函数：主要为对象销毁前系统自动调用，执行清理工作

构造函数语法：`类名（）{};`

1. 构造函数，没有返回值和void
2. 函数名称和类名相同
3. 构造函数可以有参数，所以可以重载
4. 程序在调用对象时，会自动调用构造函数，且只调用一次

析构函数语法：`~ 类名（）{};`

1. 析构函数，没有返回值和void
2. 函数名称和类名不相同，在前面加 ~
3. 构造函数部可以有参数，所以不可以重载
4. 程序在调用对象时，会自动调用析构函数，且只调用一次

示例：

```c++
#include <iostream>

using namespace std;

class Test
{
public:
    Test()
    {
        cout << "Test构造函数" << endl;
    }
    ~Test()
    {
        cout << "Test析构函数" << endl;
    }
};

void demo()
{
    Test t1;
}

int main()
{
    demo(); // 函数执行时调用构造函数，结束时调用析构函数
    Test t2; // 函数执行时调用构造函数
    system("pause"); // 程序在此处暂停，析构函数为被调用，按任意键后执行析构函数
    return 0;
}
```





##### 4.2.2 构造函数分类及调用

- 分类：

  1. 按参数分为：有参构造，无参构造
  2. 按类型分为：普通构造，拷贝构造

- 调用：

  1. 括号法
  2. 显示法
  3. 隐式转换法

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  
  public:
      // 创建构造函数
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a)
      {
          age = a;
          cout << "Person有参构造函数" << endl;
      }
  
      Person(const Person &p) // 将对象的属性拷贝进来
      {
          age = p.age;
          cout << "Person拷贝构造函数" << endl;
      }
  
      ~Person()
      {
          cout << "Person无参析构函数" << endl;
      }
  
      int age;
  };
  
  // 调用构造函数
  void demo()
  {
      // 括号法调用
      // 注意：无参构造函数不用括号：Person p1(); 编译器会作为 void func(); 声明来处理，调用空实现的构造函数
      Person p1; // 无参构造函数
      Person p2(10); // 有参构造函数
      Person p3(p2); // 拷贝构造函数
  
      cout << "p2 age: " << p2.age << endl;
      cout << "p3 age: " << p3.age << endl;
  
      // 显示法调用
      Person p4;
      Person p5 = Person(20);
      Person p6 = Person(p5);
      // 注意 Person(20) 单独写出来为匿名对象，程序中无法使用，执行完会被系统立即回收
      // 注意 不用拷贝函数初始化匿名对象，Person(p6) 编译器等价于 Person p6 , 而 Person p6 已经作为对象被实例化了
  
      // 隐式转换法调用
      Person p7 = 10; // 等价于 Person p7 = Person(10);
      Person p8 = p7;
  
      system("pause");
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  



##### 4.2.3 拷贝构造函数调用时机

- C++中拷贝构造函数调用时机三种情况	

  1. 使用一个已经创建的对象来初始化一个新对象
  2. 值传递的方式给函数参数传值
  3. 以值方式返回局部对象

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_age;
  
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a)
      {
          p_age = a;
          cout << "Person有参构造函数" << endl;
      }
  
      Person(const Person &person)
      {
          p_age = person.p_age;
          cout << "Person拷贝构造函数" << endl;
      }
  
      ~Person()
      {
          cout << "Person无参析构函数" << endl;
      }
  };
  
  //1. 使用一个已经创建的对象来初始化一个新对象
  void demo1()
  {
      Person p1(10); // 有参构造
      Person p2(p1); // 拷贝构造
      cout << "p2 age: " << p2.p_age << endl;
  }
  
  //2. 值传递的方式给函数参数传值
  void test2(Person person)
  {
  
  }
  
  void demo2()
  {
      Person p3; // 默认构造
      test2(p3); // 拷贝构造 - 此处 p3 为p3对象的副本（拷贝）
  }
  
  //3. 以值方式返回局部对象
  Person test3()
  {
      Person p4; // 默认构造
      cout << "p4 address: " << (int *) &p4 << endl;
      return p4; // 此处 p4 为p4对象的副本（拷贝）
  }
  
  void demo3()
  {
      Person p5 = test3(); // 拷贝构造 - 得到 p4 的对象副本
      cout << "p5 address: " << (int *) &p5 << endl;
  }
  
  int main()
  {
      //demo1();
      //demo2();
      demo3();
      return 0;
  }
  ```





##### 4.2.4 构造函数调用规则

- 默认情况下，C++编译器至少给一个类添三个函数

  1. 默认构造函数（无参，函数体为空）
  2. 默认析构函数（无参，函数体为空）
  3. 默认拷贝构造函数 对类实例化的对象的属性值拷贝

- 调用规则：

  1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数
  2. 如果自定义拷贝构造函数，编译器不提供其他构造函数

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_age;
  
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a)
      {
          p_age = a;
          cout << "Person有参构造函数" << endl;
      }
  
      Person(const Person &person)
      {
          p_age = person.p_age;
          cout << "Person拷贝构造函数" << endl;
      }
  
      ~Person()
      {
          cout << "Person无参析构函数" << endl;
      }
  };
  
  //1. 如果自定义有参构造函数，编译器不提供默构造函数，但提供默认拷贝构造函数
  void demo1() // 默认构造函数不会被调用
  {
      Person p1(10);
      Person p2(p1);
  }
  
  //2. 如果自定义拷贝构造函数，编译器不提供其他构造函数
  void demo2() // 自定义拷贝构造函数后，其他构造函数需自己添加
  {
   Person p3;
   Person p4(p3);
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```

  



##### 4.2.5 深拷贝和浅拷贝

- 深拷贝：在堆区重新申请空间，进行拷贝操作

- 浅拷贝：简单的赋值拷贝（编译器默认提供的拷贝构造函数就是浅拷贝）

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_age;
      int *p_height;
  
      Person()
      {
          cout << "Person无参构造函数" << endl;
      }
  
      Person(int a, int height)
      {
          cout << "Person有参构造函数" << endl;
          p_age = a;
          p_height = new int(height);
      }
  
      // 通过深拷贝的方法解决浅拷贝带来的问题 深拷贝定义后，编译器默认执行该构造函数
      Person(const Person &person)
      {
          cout << "Person拷贝构造函数" << endl;
          p_age = person.p_age;
          p_height = new int(*person.p_height); // 自定义的赋值方式，堆中开辟空间
          //p_height = person.p_height; // 编译器默认的赋值方式
      }
  
  // 浅拷贝时，p2 内的 p_height 被释放，p1 无可释放，程序执行非法操作（报错）
  // 深拷贝时，p2 内的 p_height 是单独的堆区空间被释放，不影响 p1 的 p_height 内存释放（正确）
      ~Person()
      {
          cout << "Person析构函数" << endl;
          if (p_height != NULL)
          {
              delete p_height;
              p_height = NULL;
          }
      }
  };
  
  void demoTest() // 栈区内存释放的顺序是先进后出，所以析构函数 释放内存是从 p2 开始
  {
      Person p1(10, 170);
      cout << "p1 age: " << p1.p_age << " p1 height: " << *p1.p_height << endl;
      Person p2(p1); // 编译器提供的浅构造函数，解析的是p1指针指向的内存空间
      cout << "p2 age: " << p2.p_age << " p2 height: " << *p2.p_height << endl;
  }
  
  int main()
  {
      demoTest();
      return 0;
  }
  ```

  



##### 4.2.6 初始化列表

- 作用：C++提供初始化列表，用来初始化属性

- 语法：`构造函数（）：属性1（值1），属性2（值2）... {}`

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int p_a;
      int p_b;
  
      // 通过有参构造函数初始化属性值
  //    Person(int a, int b)
  //    {
  //        p_a = a;
  //        p_b = b;
  //    }
  
  // 通过初始化列表来初始化属性值
      Person(int a, int b) : p_a(a), p_b(b)
      {
  
      }
  };
  
  int main()
  {
      Person p1(10, 20);
      cout << "p1 a: " << p1.p_a << endl;
      cout << "p1 b: " << p1.p_b << endl;
  
      return 0;
  }
  ```

  



##### 4.2.7 类对象作为类成员

- C++类中的成员可以说另一个类的对象，称为：对象成员

- 例如：

  ```c++
  class A {}
  class B
  {
      A a;
  }
  ```

- B类中有对象作为成员，A为对象成员

- 程序执行时，先构造A，再构造B

- 程序结束时，先析构B，再析构A

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Phone
  {
  public:
      string p_Name;
  
      Phone(string name)
      {
          cout << "Phone 构造函数调用 (先构造)" << endl;
          p_Name = name;
      }
  
      ~Phone()
      {
          cout << "Phone 析构函数调用" << endl;
      }
  };
  
  class Human
  {
  public:
      string h_Name;
      Phone h_Phone;
  
      Human(string name, string phone) : h_Name(name), h_Phone(phone)
      {
          cout << "Human 构造函数调用" << endl;
      }
  
      ~Human()
      {
          cout << "Human 析构函数调用 (先析构)" << endl;
      }
  
  };
  
  void demo()
  {
      Human h("FH", "Apple");
      cout << "Name: " << h.h_Name << " Phone: " << h.h_Phone.p_Name << endl;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  



##### 4.2.8 静态成员

- 定义：在成员变量和成员函数前加关键字static，称为静态成员

- 分类：

  1. 静态成员变量
     - 所有对象共享一份数据
     - 在编译阶段分配内存
     - 类内声明，类外初始化
  2. 静态成员函数
     - 所有对象共享一个函数
     - 静态成员函数只能访问静态成员变量

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      static int p_num; // 静态成员变量 类内声明
  
      static void func() // 静态成员函数
      {
          p_num = 100;
          cout << "num: " << p_num << endl;
      }
  
  private: // 静态成员变量的访问权限可以为私密 类外无法访问
      static void func2()
      {
          cout << "private func2" << endl;
      }
  };
  
  int Person::p_num = 0; // 静态成员变量 类外初始化
  
  int main()
  {
      // 通过对象访问
      Person p;
      p.func();
  
      // 通过类名访问 （静态成员函数可以直接通过类的作用域直接调用）
      Person::func();
  
      return 0;
  }
  ```

  





#### 4.3 对象模型和this指针



##### 4.3.1 成员变量和成员函数分开存储

- C++中，类内的成员变量和成员函数分开存储

- 只有非静态成员变量才属于类的对象上

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class demo1
  {
      // 空对象 默认 占内存空间 1
  };
  
  class demo2
  {
      int num = 0; // 非空对象 占内存空间 依据成员变量
  };
  
  class demo3
  {
      int num3 = 0;
      static int s_num; // 静态成员变量 不在类的对象上
  
      void func()
      {
          // 成员函数 不在类的对象上 (无论是否静态)
      }
  };
  
  int demo3::s_num = 0;
  
  void Test1()
  {
      cout << "Size of demo1: " << sizeof(demo1) << endl;
  }
  
  void Test2()
  {
      cout << "Size of demo2: " << sizeof(demo2) << endl;
  }
  
  void Test3()
  {
      cout << "Size of demo3: " << sizeof(demo3) << endl;
  }
  
  int main()
  {
      Test1();
      Test2();
      Test3();
  
      return 0;
  }
  ```

  



##### 4.3.2 this指针概念

- 作用：this指针指向被调用的成员函数所属对象

- this指针是隐含每个非静态成员函数的一种指针

- this指针不需定义，直接使用

- 用途：

  1. 当形参和成员变量同名时，可用this指针来区分
  2. 在类的非静态成员函数返回对象本身，可使用 return *this；

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int age;
  
      Person(int age)
      {
          // this可以区分相同名称的变量
          this->age = age;
      }
  
      //返回的是Person对象的引用
      Person &addPersonAge(Person &p)
      {
          this->age += p.age;
          return *this; // 返回对象为 *this
      }
  };
  
  void func1()
  {
      Person p1(10);
      cout << "p1 Age: " << p1.age << endl;
  }
  
  void func2()
  {
      Person p2(20);
      Person p3(20);
      // 链式编程思想
      // p3.addPersonAge(p2) 的执行结果是返回 对象的本身，所以可以链式调用成员函数
      p3.addPersonAge(p2).addPersonAge(p2).addPersonAge(p2);
      cout << "p3 Age: " << p3.age << endl;
  }
  
  int main()
  {
      func1();
      func2();
      return 0;
  }
  ```





##### 4.3.3 空指针访问成员函数

- C++中空指针可以调用成员函数，但要注意是否用到this

- 如果用到this，需要加上判断，保证代码的安全

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Demo
  {
  public:
      int age = 10;
  
      void func1()
      {
          cout << "func1" << endl;
      }
  
      void func2()
      {
          // 为保证安全性，防止传入的空指针调用成员变量导致崩溃
          if (this == NULL)
          {
              return;
          }
          // 此处的this 《==》 this.age this是空的，无实际对象，无法调用
          cout << "func2 " << age << endl;
      }
  };
  
  void test()
  {
      // 创建一个对象的地址为空
      Demo *d = NULL;
      d->func1();
      d->func2();
  }
  
  int main()
  {
      test();
      return 0;
  }
  ```






##### 4.3.4 const修饰成员函数

- 常函数：

  1. 成员函数后加const，该函数称为常函数
  2. 常函数内不可以修改成员属性
  3. 成员属性声明时加关键字mutable，在常函数中依然可以修改

- 常对象

  1. 声明对象前加const，则称为常对象
  2. 常对象只能调用常函数

- 示例：

  ```c++
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int age;
      // mutable 修饰的成员变量
      mutable int id;
  
      // this指针是指针常量，指针的指向不可修改
      // const Person *const this；
      // 常量函数的const 修饰的this指针 让this指针指向的值也不可修改
      void printAge() const
      {
          // this->age = 10;
  
          // 常函数可以修改 mutable的值
          this->id = 10;
      }
  
      void printID()
      {
  
      }
  };
  
  void demo()
  {
      // 常对象
      const Person p{};
  
      p.printAge();
      //p.printID(); // 常对象只能调用 常函数
  
      //p.age = 100; // 常对象内的成员变量属性值不能修改
      p.id = 100; // 常对象内的mutable成员变量属性值能修改
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```







#### 4.4 友元

- 作用：目的是让一个函数或者类访问另一个类中的私有成员
- 关键字：friend
- 实现：
  1. 全局函数做友元
  2. 类做友元
  3. 成员函数做友元
  
  



##### 4.4.1 全局函数做友元

```c++
#include <iostream>

using namespace std;

class Room
{
    // 将一个全局函数 在类中 通过friend关键在修饰 声明后，该全局函数可以访问 类中私有的成员变量属性
    friend void Func_Friend(Room *room);
private:
    string privateRoom;

public:
    string publicRoom;

    Room()
    {
        privateRoom = "privateRoom Access Succeeded";
        publicRoom = "publicRoom Access Succeeded";
    }
};

void Func_Friend(Room *room)
{
    cout << "Friend Function Access: " << room->publicRoom << endl;
    // 声明友元后，可以正常访问类中的私有成员变量
    cout << "Friend Function Access: " << room->privateRoom << endl;
}

void Test()
{
    Room room;
    Func_Friend(&room);
}

int main()
{
    Test();
    return 0;
}
```





##### 4.4.2 类做友元

```c++
#include <iostream>

using namespace std;

// 先声明一个 Service类
class Service;

class User
{
private:
    // 定义一个 私有 Service类对象的指针
    Service *service;

public:
    // 构造函数和成员函数写在类外
    User();
    void access();
};

class Service
{
    // 将 User类 声明为 Service类的友元类 使得User类的对象是 Service类得到友元对象，可以访问私有成员变量的属性
    friend class User;
private:
    string priContent;

public:
    string pubContent;

    // 构造函数声明在外
    Service();
};

// 通过User类的作用域创建一个User类的构造函数，初始化User类中的成员变量的属性值
User::User()
{
    // 创建一个Service类的对象指针
    service = new Service;
}

// 通过User类的作用域创建一个User类的成员函数
void User::access()
{
    cout << "User Access Service: " << service->pubContent << endl;
    // 当User类成为Service类的友元后，可以在User的函数内访问 Service类中的私有成员变量属性
    cout << "User Access Service: " << service->priContent << endl;
}

// 通过Service类的作用域创建一个Service类的构造函数
Service::Service()
{
    this->priContent = "priContent";
    this->pubContent = "pubContent";
}

void demo()
{
    User user;
    user.access();
}

int main()
{
    demo();
    return 0;
}
```





##### 4.4.3 成员函数做友元

```c++
#include <iostream>

using namespace std;

class Service;

class User
{
public:
    Service *service;

    User();

    void access1();
    void access2();
};

class Service
{
    // 通过friend关键字 声明User类中的成员函数access2() 是Service类的友元函数
    friend void User::access2();
private:
    string priContent;

public:
    string pubContent;

    Service();
};

// User类和Service类的构造函数和成员函数在类外创建，类内声明
User::User()
{
    service = new Service;
}

void User::access1()
{
    cout << "Access pubContent: " << service->pubContent << endl;
}

// 访问Service类中的私有成员变量的属性
void User::access2()
{
    cout << "Access priContent: " << service->priContent << endl;
}

Service::Service()
{
    priContent = "priContent";
    pubContent = "pubContent";
}

void demo()
{
    User user;
    user.access1();
    user.access2();
}

int main()
{
    demo();

    return 0;
}
```





#### 4.5 运算符重载

- 概念：对已有的运算符进行重新的定义，赋予另一种功能，以适应不同的数据类型



##### 4.5.1 加号运算符重载

- 作用：实现两个自定义数据类型相加的运算

- 编辑器提供了通用名称：operator+

- 内置的不能使用运算符重载，只有自定义类型的可以使用

  ```c++
  //
  // Created by FHang on 2020/8/11.
  //
  #include <iostream>
  
  using namespace std;
  
  class Num
  {
  public:
      int num1;
      int num2;
  
      // 类中 成员函数 实现的 重载运算‘+’
      Num operator+(Num &n) const
      {
          Num my_n{};
          my_n.num1 = this->num1 + n.num1;
          my_n.num2 = this->num2 + n.num2;
          return my_n;
      }
  };
  
  // 全局函数 运算符重载的默认写法
  Num operator+(Num &n1, Num &n2)
  {
      Num my_n{};
      my_n.num1 = n1.num1 + n2.num1;
      my_n.num2 = n1.num2 + n2.num2;
      return my_n;
  }
  
  // 运算符函数 重载
  Num operator+(Num &n, int num)
  {
      Num my_n{};
      my_n.num1 = n.num1 + num;
      my_n.num2 = n.num2 + num;
      return my_n;
  }
  
  void demo1()
  {
      Num n1{};
      n1.num1 = 10;
      n1.num2 = 10;
  
      Num n2{};
      n2.num1 = 5;
      n2.num2 = 5;
  
      Num n3{};
      // 重载后的简化写法
      n3 = n1 + n2;
  
      // 成员函数 重载的默认写法
      // n3 = n1.operator+(n2);
  
      // 全局函数 重载的默认写法
      // n3 = operator+(n1, n2);
  
      cout << "Operator: n3 = n1 + n2 = " << n3.num1 << endl;
      cout << "Operator: n3 = n1 + n2 = " << n3.num2 << endl;
  }
  
  void demo2()
  {
      Num n4{};
      n4.num1 = 20;
  
      int num2 = 10;
  
      // 重载运算符函数的 重载写法 （Num类型 + int类型）
      Num n5 = n4 + num2;
  
      cout << "Operator: n5 = n4 + num2 = " << n5.num1 <<endl;
      cout << "Operator: n5 = n4 + num2 = " << n5.num2 <<endl;
  }
  
  int main()
  {
      demo1();
      demo2();
  
      return 0;
  }
  ```



##### 4.5.2 左移运算符重载

- 作用：输出自定义的数据类型

- 左移运算符重载 最好在声明为全局函数

- 配合友元使用

  ```c++
  //
  // Created by Admin on 2021/4/29.
  //
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
      friend ostream &operator<<(ostream &c, Person &p);
  private:
      string name;
      int age{};
  
  public:
      Person(string name, int age);
  };
  
  Person::Person(string newName, int newAge)
  {
      name = newName;
      age = newAge;
  }
  
  ostream &operator<<(ostream &c, Person &p)
  {
      cout << "Person Name: " << p.name << endl;
      cout << "Person Age: " << p.age << endl;
      return c;
  }
  
  void demo()
  {
      Person p("FHang", 24);
      cout << p << endl;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  

##### 4.5.3 递增运算符重载

- 需要配合 全局左移运算符 重载

- 配合使用 友元

- 前置重载 返回引用

- 后置重载 返回类内值

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class MyInt
  {
      friend ostream &operator<<(ostream &c, MyInt myInt);
  private:
      int my_num;
  
  public:
      MyInt()
      {
          my_num = 0;
      }
  
      // 重载 前置 ++ 运算符
      // 返回引用的目的是 仅对当前的对象进行计算，若是返回对象，则一次计算后，生成另一个新对象
      MyInt &operator++()
      {
          my_num++;
          return *this;
      }
  
      // 重载 后置 ++ 运算符
      // MyInt &operator++(int) => int 是 占位参数，告诉编译器，用于区分，前后置重载
      // 此处 返回值 不返回自身引用，该函数内 自身的引用指向的值 是临时变量，一次操作后，被回收，若是连续多次使用 后置 ++，便是访问NULL，非法操作
      MyInt operator++(int)
      {
          MyInt tempInt = *this;
          my_num++;
          return tempInt;
      }
  };
  
  // 全局重载 左移运算符
  ostream &operator<<(ostream &c, MyInt myInt)
  {
      cout << myInt.my_num;
      return c;
  }
  
  void demo1()
  {
      cout << "<---------demo1----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
  }
  
  void demo2()
  {
      cout << "<---------demo2----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
      cout << ++myInt << endl;
      cout << ++(++myInt) << endl;
      cout << myInt++ << endl;
      cout << myInt << endl;
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```



##### 4.5.4 递减运算符重载

- 基本情况 同 递增运算符重载

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class MyInt
  {
      friend ostream &operator<<(ostream &c, MyInt myInt);
  private:
      int my_num;
  
  public:
      MyInt()
      {
          my_num = 10;
      }
  
      // 重置 前置 -- 返回引用
      MyInt &operator--()
      {
          my_num--;
          return *this;
      }
  
      // 重置 后置 -- 返回值
      MyInt operator--(int)
      {
          MyInt tempInt = *this;
          my_num--;
          return tempInt;
      }
  };
  
  // 全局重载 左移运算符
  ostream &operator<<(ostream &c, MyInt myInt)
  {
      cout << myInt.my_num;
      return c;
  }
  
  void demo1()
  {
      cout << "<---------demo1----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
  }
  
  void demo2()
  {
      cout << "<---------demo2----------->" << endl;
      MyInt myInt;
      cout << myInt << endl;
      cout << --myInt << endl;
      cout << --(--myInt) << endl;
      cout << myInt-- << endl;
      cout << myInt << endl;
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```



##### 4.5.5 赋值运算符重载

- C++ 编译器至少给一个类添加4个函数

  1. 默认构造函数（无参，函数体为空）
  2. 默认析构函数（无参，函数体为空）
  3. 默认拷贝构造函数，对属性值进行值拷贝
  4. 赋值运算符 operator=，对属性值进行值拷贝

- 如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      int *my_Age;
  
      explicit Person(int age)
      {
          my_Age = new int(age);
      }
  
      ~Person()
      {
          if (my_Age != nullptr)
          {
              delete my_Age;
              my_Age = nullptr;
          }
      }
  
      // 重载 赋值运算符 让每一个对象 都各自对应一块堆区，避免浅拷贝带来的多个对象指向同一堆区，在析构函数的作用下，重复释放堆区
      Person &operator=(Person &person)
      {
          // 编译器 默认 浅拷贝
          // my_Age = person.my_Age;
  
          // 1. 在 p2 = p1 中，p2在堆区中已有属性值，所以在进行深拷贝之前，先释放 p2 堆区
          if (my_Age != nullptr)
          {
              delete my_Age;
              my_Age = nullptr;
          }
  
          // 2. 进行 深拷贝
          my_Age = new int(*person.my_Age);
  
          return *this;
      }
  };
  
  void demo1()
  {
      Person p1(18);
      Person p2(24);
  
      // 该 赋值操作 为 浅拷贝
      p2 = p1;
  
      // 浅拷贝时 堆区 my_Age 占有 的内存 被析构函数 重复释放
      cout << *p1.my_Age << endl;
      cout << *p2.my_Age << endl;
  }
  
  void demo2()
  {
      Person p1(18);
      Person p2(24);
      Person p3(36);
  
      p3 = p2 = p1;
  
      cout << *p1.my_Age << endl;
      cout << *p2.my_Age << endl;
      cout << *p3.my_Age << endl;
  }
  
  int main()
  {
      // demo1();
      demo2();
      return 0;
  }
  ```



##### 4.5.6 关系运算符重载

- 让自定义的两个对象类型进行比较操作

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class Person
  {
  public:
      string my_Name;
      int my_Age;
  
      Person(string name, int age)
      {
          my_Name = std::move(name);
          my_Age = age;
      }
  
      // 重载 关系运算符 返回值类型可以为：int类型 0/1；或者 bool类型
      // 此次 重载的关系运算符为 ==，其他例如：!=, <, > ...同理
      int operator==(Person &person) const
      {
          if (this->my_Name == person.my_Name && this->my_Age == person.my_Age)
          {
              return 1;
          }
          return 0;
      }
  };
  
  void demo1()
  {
      Person p1("FH", 24);
      Person p2("HF", 24);
  
      // 此处 的 p1 == p2 是 p1.operator==(p2), 返回一个 bool类型 或者 0/1的int类型，进行if语句判断
      if (p1 == p2)
      {
          cout << "P1 = P2" << endl;
      }
      else
      {
          cout << "P1 != P2" << endl;
      }
  
      // 此次 得到的返回值为 int类型的 0/1，所以亦可采用 switch语句来xie
      switch (p1 == p2)
      {
          case 0:
              cout << "P1 != P2" << endl;
              break;
  
          case 1:
              cout << "P1 = P2" << endl;
      }
  }
  
  int main()
  {
      demo1();
      return 0;
  }
  ```



##### 4.5.7 函数调用运算符重载

- 函数调用运算符（）也可重载

- 重载后使用的方式，类似函数的调用，被称为 “仿函数”

- 仿函数 的写法灵活，没有固定写法

  ```c++
  //
  // Created by Admin on 2021/6/20.
  //
  #include <iostream>
  
  using namespace std;
  
  class FPrint
  {
  public:
      void operator()(const string &text)
      {
          cout << text << endl;
      }
  };
  
  class FAdd
  {
  public:
      void operator()(int num1, int num2)
      {
          cout << num1 + num2 << endl;
      }
  };
  
  void demo1()
  {
      FPrint fPrint;
      fPrint("Hello World !");
  }
  
  void demo2()
  {
      FAdd fAdd;
      fAdd(10, 20);
  
      // 匿名函数对象
      FAdd()(20, 40);
  }
  
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```





#### 4.6 继承



##### 4.6.1 继承的基本使用

- 继承的作用：减少编写重复的代码

- 继承的语法：

  ```c++
  class 子类 : 继承方式 父类 
  1. 子类 也叫 派生类 （derived class）
  2. 父类 也叫 基类 (base class)
  3. 继承方式：public
  ```

- 继承的演示：

  ```c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  // 公共页面 是 其子类页面 公用拥有的属性
  class BasePage
  {
  public:
      void pageHeader()
      {
          cout << " -首页 公开课 登陆 注册 (公共)" << endl;
      }
  
      void pageLeft()
      {
          cout << " -Java C# C/C++ Php Golang (公共)" << endl;
      }
  
      void pageFoot()
      {
          cout << " -帮助中心 交流合作 友链 (公共)" << endl;
      }
  };
  
  // 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容
  class JavaPage : public BasePage
  {
  public:
      JavaPage()
      {
          cout << "<<-- Java Web Page -->>" << endl;
      }
      
      ~JavaPage()
      {
          cout << endl;
      }
  
      void pageBody()
      {
          cout << " -Java_demo1 Java_demo2 Java_demo3 (Java)" << endl;
      }
  };
  
  // 子类页面 继承 公共页面的属性 同时也可自定义 一部分属性内容
  class CPP : public BasePage
  {
  public:
      CPP()
      {
          cout << "<<-- C/C++ Web Page -->>" << endl;
      }
      
      ~CPP()
      {
          cout << endl;
      }
  
      void pageBody()
      {
          cout << " -C/C++_demo1 C/C++_demo2 C/C++_demo3 (C/C++)" << endl;
      }
  };
  
  void java_demo()
  {
      JavaPage javaPage;
      javaPage.pageHeader();
      javaPage.pageLeft();
      javaPage.pageBody();
      javaPage.pageFoot();
  }
  
  void cpp_demo()
  {
      CPP cpp;
      cpp.pageHeader();
      cpp.pageLeft();
      cpp.pageBody();
      cpp.pageFoot();
  }
  
  int main()
  {
      java_demo();
      cpp_demo();
      return 0;
  }
  ```



##### 4.6.2 继承的方式

- 继承语法: `class 子类 : 继承方式 父类`

- 继承方式：

  1. 公共继承：public
  2. 保护继承：protected
  3. 私有继承：private

- 继承方式演示：

  ```c++
  // 父类中的 private 可以被 子类  任何继承方式 继承；但 ！ 子类 无法 访问 和 使用
  class Father
  {
  public:
      int a;
  protected:
      int b;
  private:
      int c;
  };
  
  class Son : public Father
  {
  // public继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 无改动；
  public:
      int a;
  protected:
      int b;
  };
  
  class Son : protected Father
  {
  // protected继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 protected
  protected:
      int a;
      int b;
  };
  
  class Son : private Father
  {
  // private继承方式下：Father类中的 Public 和 Protected 的成员变量，在子类中 全为 private
  private:
      int a;
      int b;
  };
  
  // 总结：
  // 父类的 private 可以被 任何 继承方式 继承；但 ！ 子类 无法 访问 和 使用
  // 子类通过某个 继承方式 继承 父类 后，父类中的 public，protected 中的成员变量 在子类中 以某种继承方式出现；
  ```

  

##### 4.6.3 继承中的对象模型



###### 4.6.3.1 验证子类模型

- 父类中的所有成员变量(非静态)，无论是什么权限保护的成员，都会被子类继承，但子类无法访问和使用

  ``` c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      int base_A;
  protected:
      int base_B;
  private:
      int base_C;
  };
  
  class Derived_1 : public Base
  {
  public:
      int derived_A;
  };
  
  void demo1()
  {
      Derived_1 derived1{};
      cout << sizeof(derived1) << endl;
  }
  
  int main()
  {
      demo1();
      return 0;
  }
  ```



###### 4.6.3.2 Developer Powershell - VS

- Visual Studio 提供的工具

- 使用方式：

  1. 首先找到上面的案例代码的所在文件位置
  2. 打开 Visual Studio 提供的 Developer Powershell
  3. 将工作路径切换到案例代码的所在文件路径
  4. 通过开发命令，查看案例代码中，子类对象的结构

- 使用步骤：

  ``` powershell
  # 切换路径 和 查看路径下 是否存在 案例代码 cpp 文件
  
  **********************************************************************
  ** Visual Studio 2019 Developer PowerShell v16.9.4
  ** Copyright (c) 2021 Microsoft Corporation
  **********************************************************************
  PS C:\Users\Admin\source\repos> D:
  PS D:\DevelopmentTool\VisualStudio\IDE> cd D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> ls
  
  
      目录: D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  
  
  Mode                 LastWriteTime         Length Name
  ----                 -------------         ------ ----
  -a----         2021/6/22     15:09           1515 Inherit_Base.cpp
  -a----         2021/6/22     15:42            397 Inherit_ObjectModel.cpp
  ```

  ``` powershell
  # 通过开发命令，查看案例代码中，子类对象的结构
  
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> cl /d1 reportSingleClassLayoutDerived_1 ".\Inherit_ObjectModel.cpp"
  用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
  版权所有(C) Microsoft Corporation。保留所有权利。
  
  Inherit_ObjectModel.cpp
  
  class Derived_1 size(16): # 此处可以看到 子类Derived_1对象的大小 和 之前的案例代码的打印结果一致
          +---
   0      | +--- (base class Base) # 子类Derived_1完全继承父类中所有成员 中的 base_A base_B  base_C
   0      | | base_A
   4      | | base_B
   8      | | base_C
          | +---
  12      | derived_A # 同时 子类Derived_1 自身的成员也在 derived_A
          +---
  
  # 总结：子类 Derived_1中 四个int类型的成员变量，占内存大小为16字节
  ```

  ``` powershell
  # 用到的指令
  
  # 切换盘符 到 案例代码 所在 的 盘
  D:
  
  # 切换到具体的路径地址
  cd D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  
  # 查看路径下 的 案例代码文件 Inherit_ObjectModel.cpp
  ls
  
  # 指定 报告单个类的布局 ：子类Deriverd_1
  # cl /d1 reportSingleClassLayout需要查看的类 "类所在的具体文件"
  cl /d1 reportSingleClassLayoutDerived_1 ".\Inherit_ObjectModel.cpp"
  ```



##### 4.6.4 继承中构造和析构顺序

- 子类继承父类之后，当创建子类对象时，也会调用父类的构造和析构函数

- 案例验证，子类和父类的构造和析构函数的调用先后顺序

  ``` c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      Base()
      {
          cout << "Base Constructor Transfer" << endl;
      }
  
      ~Base()
      {
          cout << "Base Destructor Transfer" << endl;
      }
  };
  
  class Derived : public Base
  {
  public:
      Derived()
      {
          cout << "Derived Constructor Transfer" << endl;
      }
  
      ~Derived()
      {
          cout << "Derived Destructor Transfer" << endl;
      }
  };
  
  void demo()
  {
      Derived derived;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  ```powershell
  # 案例结果
  D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\cmake-build-debug\Code9_3.exe
  Base Constructor Transfer
  Derived Constructor Transfer
  Derived Destructor Transfer
  Base Destructor Transfer
  ```

- 由 案例结果 可以 看出

- 当创建子类时，子类和父类 的 构造和析构函数的调用 顺序

  1. 子类构造
  2. 父类构造
  3. 父类析构
  4. 子类析构



##### 4.6.5 继承同名成员处理方式

- 继承时的问题：当子类和父类出现同名成员，如何通过子类对象，访问子类或父类的同名数据

  1. 访问子类同名成员，直接访问
  2. 访问父类同名成员，添加作用域

  ```c++
  //
  // Created by Admin on 2021/6/22.
  //
  #include <iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      int num;
  
      Base()
      {
          num = 100;
      }
  
      void FPrint()
      {
          cout << "Base Print" << endl;
      }
  
      void FPrint(int n)
      {
          cout << "Base Print (int n) : Overload Function" << endl;
      }
  };
  
  class Derived : public Base
  {
  public:
      int num;
  
      Derived()
      {
          num = 200;
      }
  
      void FPrint()
      {
          cout << "Derived Print" << endl;
      }
  };
  
  void demo()
  {
      Derived derived;
      cout << "Derived num = " << derived.num << endl;
      cout << "Base num = " << derived.Base::num << endl;
      derived.FPrint();
      derived.Base::FPrint();
  
      // 当父类和子类中，存在同名成员时，会默认隐藏父类的成员，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用
      // derived.FPrint(10);  // 父类被隐藏，所以直接传参也无法找到 重载的函数，因为子类没有 FPrint的重载函数
      derived.Base::FPrint(10); // 加上 父类作用域后 可调用
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

- 解决方法：

  1. 子类对象可以直接访问到子类同名成员
  2. 子类对象加上作用域可以访问到父类同名成员
  3. 当子类和父类拥有同名的成员函数，子类会隐藏父类同名成员函数，子类加作用域可以访问到父类中同名函数



##### 4.6.6 继承同名静态成员处理方式

- 问题：继承中，同名的静态成员在子类对象上如何访问

- 静态成员和非静态成员出现同名，处理方式一致

  1. 访问子类同名成员，直接访问
  2. 访问父类同名成员，添加作用域

  ```c++
  //
  // Created by FHang on 2021/6/24 10:23
  //
  #include <iostream>
  
  using namespace std;
  
  // 基类
  class Base
  {
  public:
      static int num;
  
      static void func()
      {
          cout << "Base-Static Func" << endl;
      }
  
      ~Base()
      {
          cout << endl;
      }
  };
  
  int Base::num = 100;
  
  // 子类
  class Derived : public Base
  {
  public:
      static int num;
  
      static void func()
      {
          cout << "Derived-Static Func" << endl;
      }
  };
  
  int Derived::num = 200;
  
  // 同名静态成员属性
  void demo1()
  {
      Derived derived;
      // 通过对象访问
      cout << "通过对象访问" << endl;
      cout << "Derived Num = " << derived.num << endl;
      cout << "Base Num = " << derived.Base::num << endl;
  
      // 通过类目访问
      cout << "通过类目访问" << endl;
      cout << "Derived Num = " << Derived::num << endl;
      cout << "Base Num = " << Base::num << endl;
  
      // 第一个 :: 表示使用类名访问；第二个 :: 表示父类作用域下
      cout << "Base Num = " << Derived::Base::num << endl;
  }
  
  // 同名静态成员变量
  void demo2()
  {
      Derived derived;
      // 通过对象访问
      cout << "通过对象访问" << endl;
      derived.func();
      derived.Base::func();
  
      // 通过类目访问
      cout << "通过类目访问" << endl;
      Derived::func();
      Derived::Base::func();
  }
  
  // 当父类和子类中，存在同名成员变量时，会默认隐藏父类的成员变量，所以可以直接调用子类成员，而父类成员需要 子类调用父类，在父类作用域下 调用
  int main()
  {
      demo1();
      demo2();
      return 0;
  }
  ```

- 总结：同名静态成员处理方式和非同名静态的处理方式一样

- 区别：同名静态成员处理：

  1. 通过对象调用
  2. 通过类目调用



##### 4.6.7 多继承语法

- C++ 允许一个类继承多个类

- 语法：class 子类 : 继承方式 父类1, 继承方式 父类2...

- 多继承可能会引发父类中同名成员出现，需要加作用域区分使用

- 实际开发中，建议不用，不易于维护

  ```c++
  //
  // Created by FHang on 2021/6/24 11:03
  //
  #include <iostream>
  
  using namespace std;
  
  class Base1
  {
  public:
      int num;
  
      Base1()
      {
          num = 100;
      }
  };
  
  class Base2
  {
  public:
      int num;
  
      Base2()
      {
          num = 200;
      }
  };
  
  class Derived : public Base1, public Base2
  {
  public:
      int num;
  
      Derived()
      {
          num = 300;
      }
  };
  
  void demo()
  {
      Derived derived;
      cout << "Sizeof derived = " << sizeof(derived) << endl;
      cout << "Derived Num = " << derived.num << endl;
      cout << "Base1 Num = " << derived.Base1::num << endl;
      cout << "Base2 Num = " << derived.Base2::num << endl;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

- 此处也使用了 Developer PowerShell 查看了 Derived 类的结构

  ```powershell
  **********************************************************************
  ** Visual Studio 2019 Developer PowerShell v16.9.4
  ** Copyright (c) 2021 Microsoft Corporation
  **********************************************************************
  PS C:\Users\Admin\source\repos> D:
  PS D:\DevelopmentTool\VisualStudio\IDE> cd D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo> ls
  
  
      目录: D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo
  
  
  Mode                 LastWriteTime         Length Name
  ----                 -------------         ------ ----
  d-----          2021/5/4      9:34                .idea
  d-----         2021/6/24     11:12                cmake-build-debug
  d-----          2021/5/4      9:34                Code1
  d-----          2021/5/4      9:34                Code2
  d-----          2021/5/4      9:34                Code3
  d-----          2021/5/4      9:34                Code4
  d-----          2021/5/4      9:34                Code4_CirclePoint
  d-----          2021/5/4      9:34                Code5
  d-----          2021/5/4      9:34                Code6
  d-----          2021/5/4      9:34                Code7
  d-----         2021/6/20     21:27                Code8
  d-----         2021/6/24     11:11                Code9
  -a----         2021/2/21     19:24            174 .gitignore
  -a----         2021/6/24     11:12           2930 CMakeLists.txt
  
  
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo> cd Code9
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> ls
  
  
      目录: D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9
  
  
  Mode                 LastWriteTime         Length Name
  ----                 -------------         ------ ----
  -a----         2021/6/22     15:09           1515 Inherit_Base.cpp
  -a----         2021/6/22     16:36            590 Inherit_ConstructorDestructorTransferOrder.cpp
  -a----         2021/6/22     17:32           1216 Inherit_DealWithSameName.cpp
  -a----         2021/6/24     10:49           1431 Inherit_DealWithSameNameObject.cpp
  -a----         2021/6/24     11:11            126 Inherit_DiamondInheritance.cpp
  -a----         2021/6/24     11:10            730 Inherit_MoreInherit.cpp
  -a----         2021/6/22     16:01            395 Inherit_ObjectModel.cpp
  
  
  PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> cl /d1 reportSingleClassLayoutDerived ".\Inherit_MoreInherit.cpp"
  用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
  版权所有(C) Microsoft Corporation。保留所有权利。
  
  Inherit_MoreInherit.cpp
  
  class Derived   size(12):
          +---
   0      | +--- (base class Base1)
   0      | | num
          | +---
   4      | +--- (base class Base2)
   4      | | num
          | +---
   8      | num
          +---
  ```




##### 4.6.8 菱形继承

- 概念：

  1. 两个派生类继承同一个基类
  2. 又有某一个类同时继承了两个派生类

- 问题解决：

  1. 默认情况下

     ```c++
     //
     // Created by FHang on 2021/6/24 11:11
     //
     #include <iostream>
     
     using namespace std;
     
     class Animal
     {
     public:
         int age;
     
         Animal()
         {
             age = 10;
         }
     };
     
     class Tiger : public Animal{};
     
     class Lion : public Animal{};
     
     class LionTiger : public Tiger, public Lion{};
     
     void demo1()
     {
         LionTiger lionTiger;
     
         // 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题
         lionTiger.Tiger::age = 20;
         lionTiger.Lion::age = 30;
     
         cout << "Tiger Age = " << lionTiger.Tiger::age << endl;
         cout << "Lion Age = " << lionTiger.Lion::age << endl;
     }
     
     int main()
     {
         demo1();
         return 0;
     }
     ```

     ```c++
     // 打印结果
     D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\cmake-build-debug\Code9_7.exe
     // 此时，可看出，LionTiger同时继承了两个成员变量，在作用域下可单独赋值
     Tiger Age = 20
     Lion Age = 30
     ```

     ```powershell
     # 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构
     PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> cl /d1 reportSingleClassLayoutLionTiger ".\Inherit_DiamondInheritance.cpp"
     用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
     版权所有(C) Microsoft Corporation。保留所有权利。
     
     Inherit_DiamondInheritance.cpp
     .\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失
     
     class LionTiger size(8): # 可以看到，LionTiger 继承了两个 重复的成员
             +---
      0      | +--- (base class Tiger)
      0      | | +--- (base class Animal)
      0      | | | age
             | | +---
             | +---
      4      | +--- (base class Lion)
      4      | | +--- (base class Animal)
      4      | | | age
             | | +---
             | +---
             +---
     ```

  2. 使用虚继承解决问题，关键字：virtual

     ```c++
     //
     // Created by FHang on 2021/6/24 11:11
     //
     #include <iostream>
     
     using namespace std;
     
     class Animal
     {
     public:
         int age;
     
         Animal()
         {
             age = 10;
         }
     };
     
     // 利用 虚继承 解决菱形继承的问题
     // 使用 关键字 virtual ，两个派生类继承同一个父类时，两个派生类 可虚拟共享同一个 父类中继承来的成员，（继承了虚基类 Animal的age 的地址）
     // Animal 类，称为 虚基类
     class Tiger : virtual public Animal{};
     
     class Lion : virtual public Animal{};
     
     class LionTiger : public Tiger, public Lion{};
     
     void demo1()
     {
         LionTiger lionTiger;
     
         // 菱形继承，两个父类拥有相同的数据，通过作用域区分，同时造成资源浪费，通过 虚继承 解决问题
         lionTiger.Tiger::age = 20;
         lionTiger.Lion::age = 30;
     
         cout << "Tiger Age = " << lionTiger.Tiger::age << endl;
         cout << "Lion Age = " << lionTiger.Lion::age << endl;
     }
     
     int main()
     {
         demo1();
         return 0;
     }
     ```

     ```c++
     // 打印结果
     D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\cmake-build-debug\Code9_7.exe
     // 使用 虚继承 后，LionTiger 只继承了一个 成员变量
     Tiger Age = 30
     Lion Age = 30
     ```

     ```powershell
     # 利用 Developer Powershell 工具， 查看 LionTriger 类 的结构 (使用了 虚继承)
     PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code9> cl /d1 reportSingleClassLayoutLionTiger ".\Inherit_DiamondInheritance.cpp"
     用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
     版权所有(C) Microsoft Corporation。保留所有权利。
     
     Inherit_DiamondInheritance.cpp
     .\Inherit_DiamondInheritance.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以 防止数据丢失
     
     class LionTiger size(12):
             +---
      0      | +--- (base class Tiger)
      0      | | {vbptr} # 指向 LionTiger::$vbtable@Tiger@: 
             | +---
      4      | +--- (base class Lion)
      4      | | {vbptr} # 指向 LionTiger::$vbtable@Lion@:
             | +---
             +---
             +--- (virtual base Animal)
      8      | age
             +---
     
     LionTiger::$vbtable@Tiger@: # 偏移量 8，从类结构布局的开始 +8，刚好指向 virtual base Animal 的 成员变量 age
      0      | 0
      1      | 8 (LionTigerd(Tiger+0)Animal)
      
     LionTiger::$vbtable@Lion@: # 偏移量 4，从类结构布局的开始 +4，刚好指向 virtual base Animal 的 成员变量 age
      0      | 0
      1      | 4 (LionTigerd(Lion+0)Animal)
     vbi:       class  offset o.vbptr  o.vbte fVtorDisp
               Animal       8       0       4 0
     
     #  一些解释，上面的结构
     vbptr -> v=virtual, b=base, ptr=pointer; vbptr 指向 vbtable
     vbtable -> v=virtual, b=base, table
     ```



#### 4.7 多态



##### 4.7.1 多态的基本概念

多态是C++面向对象的三大特性之一

- 多态分为两类

  1. 静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名
  2. 动态多态：派生类 和 虚函数 实现运行时，为多态

- 静态多态和动态多态的区别

  1. 静态多态的函数地址早绑定 — 编译阶段确定函数地址
  2. 动态多态的函数地址晚绑定 — 运行阶段确定函数地址

- 案例说明

  1. 静态多态

     ```c++
     //
     // Created by FHang on 2021/6/24 14:56
     //
     #include <iostream>
     
     using namespace std;
     
     class Animal
     {
     public:
         void speak()
         {
             cout << "Animal Speaking" << endl;
         }
     };
     
     class Cat : public Animal
     {
     public:
         void speak()
         {
             cout << "Cat Speaking" << endl;
         }
     };
     
     // 该函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）
     // 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）
     void doSpeak(Animal &animal)
     {
         animal.speak();
     }
     
     void demo()
     {
         Cat cat;
         doSpeak(cat);
     }
     
     int main()
     {
         demo();
         return 0;
     }
     ```

     ```c++
     // 运行结果
     D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\cmake-build-debug\Code10_1.exe
     Animal Speaking
     ```

  2. 动态多态

     ```c++
     //
     // Created by FHang on 2021/6/24 14:56
     //
     #include <iostream>
     
     using namespace std;
     
     class Animal
     {
     public:
         // 使用关键字 virtual，使得变成虚函数
         virtual void speak()
         {
             cout << "Animal Speaking" << endl;
         }
     };
     
     class Cat : public Animal
     {
     public:
         void speak()
         {
             cout << "Cat Speaking" << endl;
         }
     };
     
     class Dog : public Animal
     {
     public:
         void speak()
         {
             cout << "Dog Speaking" << endl;
         }
     };
     
     // 该函数内传入引用对象调用的speak()函数的地址是早绑定，编译阶段确定引用的 Animal类的对象地址，后面调用时，传入Cat对象，不改变结果（静态多态）
     // 将基类Animal中的 函数 speak() 设为虚函数，运行时才确定地址，后面调用时，传入Cat对象，引用的便是Cat的对象地址（动态多态）
     void doSpeak(Animal &animal)
     {
         // speak()早绑定时，默认是传入基类Animal的引用对象地址
         // speak()使用virtual后是晚绑定时，传入指定引用对象地址
         animal.speak();
     }
     
     void demo()
     {
         Cat cat;
         Dog dog;
         doSpeak(cat);
         doSpeak(dog);
     }
     
     int main()
     {
         demo();
         return 0;
     }
     ```
     
     ```c++
     // 运行结果
     D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\cmake-build-debug\Code10_1.exe
     Cat Speaking
     Dog Speaking
     ```
  
- 动态多态的满足条件

  1. 有继承关系
  2. 子类重写父类的虚函数
  3. 重写：函数返回值类型，函数名，参数列表，完全一致

- 动态多态的使用：父类的指针或引用，执行子类对象



##### 4.7.2 多态深入原理

案例代码

```c++
//
// Created by FHang on 2021/6/24 14:56
//
#include <iostream>

using namespace std;

class Animal
{
public:
    virtual void speak()
    {
        cout << "Animal Speaking" << endl;
    }
};

class Cat : public Animal
{
public:
    void speak()
    {
        cout << "Cat Speaking" << endl;
    }
};

class Dog : public Animal
{
public:
    void speak()
    {
        cout << "Dog Speaking" << endl;
    }
};

void doSpeak(Animal &animal) // 此处 => Animal &animal = cat
{
    animal.speak();
}

void demo()
{
    Cat cat;
    Dog dog;
    doSpeak(cat); 
    doSpeak(dog);
}

int main()
{
    demo();
    return 0;
}
```

- 静态多态

  - 基类 Animal 中的 speak() 没有 virtual 前是早绑定，函数地址在类外，此时Animal类是空类，大小为1；

- 动态多态

  - 基类 Animal 中的 speak() 有 virtual 是晚绑定，函数地址在类内，此时Animal类不是空类，大小为4；

  - 此时 虚函数speak()，在类内中是 vfptr = virtualFunctionPointer ( 虚函数(表)指针 )，指向vftable (虚函数表)，函数地址入口是 &Animal::speak;
  - 子类Cat继承Animal后，默认情况下，Cat类完全继承了Animal类的属性；
  - 但案例代码中，Cat类内实现了speak()的重写，此时函数地址入口是 &Cat::speak;
  - 子类中的虚函数表内部会替换成子类的虚函数地址；
  - 此时，当父类的指针或引用指向子类对象时，发生多态；

- 验证：Developer PowerShell

  - 静态多态

    ```powershell
    # 基类Animal 的函数表
    PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code10> cl /d1 reportSingleClassLayoutAnimal ".\Polymorphism_DeepUnderlying.cpp"
    用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
    版权所有(C) Microsoft Corporation。保留所有权利。
    
    Polymorphism_DeepUnderlying.cpp
    
    class Animal    size(1):
            +---
            +---
    ```

    ```powershell
    PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code10> cl /d1 reportSingleClassLayoutCat ".\Polymorphism_DeepUnderlying.cpp"
    用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
    版权所有(C) Microsoft Corporation。保留所有权利。
    
    Polymorphism_DeepUnderlying.cpp
    
    class _s__CatchableType size(28):
            +---
     0      | properties
     4      | pType
     8      | _PMD thisDisplacement
    20      | sizeOrOffset
    24      | copyFunction
            +---
    
    class _s__CatchableTypeArray    size(4):
            +---
     0      | nCatchableTypes
     4      | arrayOfCatchableTypes
            +---
    
    class Cat       size(1):
            +---
     0      | +--- (base class Animal) #基类没有实现虚函数，为静态多态时，子类完全继承基类，即使子类重写了speak，也依然是默认的基类对象引用
            | +---
            +---
    ```

    

  - 动态多态

    ```powershell
    # 基类Animal 的函数表
    PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code10> cl /d1 reportSingleClassLayoutAnimal ".\Polymorphism_DeepUnderlying.cpp"
    用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
    版权所有(C) Microsoft Corporation。保留所有权利。
    
    Polymorphism_DeepUnderlying.cpp
    
    class Animal    size(4):
            +---
     0      | {vfptr}
            +---
    
    Animal::$vftable@:
            | &Animal_meta
            |  0
     0      | &Animal::speak
    
    Animal::speak this adjustor: 0
    ```

    ```powershell
    # 子类Cat 没有发生重写时的 函数表
    PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code10> cl /d1 reportSingleClassLayoutCat ".\Polymorphism_DeepUnderlying.cpp"
    用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
    版权所有(C) Microsoft Corporation。保留所有权利。
    
    Polymorphism_DeepUnderlying.cpp
    
    class _s__CatchableType size(28):
            +---
     0      | properties
     4      | pType
     8      | _PMD thisDisplacement
    20      | sizeOrOffset
    24      | copyFunction
            +---
    
    class _s__CatchableTypeArray    size(4):
            +---
     0      | nCatchableTypes
     4      | arrayOfCatchableTypes
            +---
    
    class Cat       size(4):
            +---
     0      | +--- (base class Animal)
     0      | | {vfptr}
            | +---
            +---
    
    Cat::$vftable@:
            | &Cat_meta
            |  0
     0      | &Animal::speak # Cat内没有重写 speak 时，Cat类的函数指针指向的函数表是 Animal 的
    ```

    ```powershell
    # 子类Cat 发生重写时的 函数表
    PS D:\Learn\Cpp\3_Cpp_plus_Clion\CodeDemo\Code10> cl /d1 reportSingleClassLayoutCat ".\Polymorphism_DeepUnderlying.cpp"
    用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29914 版
    版权所有(C) Microsoft Corporation。保留所有权利。
    
    Polymorphism_DeepUnderlying.cpp
    
    class _s__CatchableType size(28):
            +---
     0      | properties
     4      | pType
     8      | _PMD thisDisplacement
    20      | sizeOrOffset
    24      | copyFunction
            +---
    
    class _s__CatchableTypeArray    size(4):
            +---
     0      | nCatchableTypes
     4      | arrayOfCatchableTypes
            +---
    
    class Cat       size(4):
            +---
     0      | +--- (base class Animal)
     0      | | {vfptr}
            | +---
            +---
    
    Cat::$vftable@:
            | &Cat_meta
            |  0
     0      | &Cat::speak  # Cat内重写 speak 后，Cat类的函数指针指向的函数表是 Cat 的
    
    Cat::speak this adjustor: 0
    ```



##### 4.7.3 多态案例-计算器

- 案例描述：分别使用普通的方法和多态，设计实现两个操作数进行运算的计算器类

- 多态的优点：

  - 代码组织结构清晰
  - 可读性强
  - 利于前期和后期的扩展和维护

- 示例：普通实现

  ```c++
  //
  // Created by FHang on 2021/6/24 16:39
  //
  #include <iostream>
  
  using namespace std;
  
  class Calculator
  {
  public:
      int num1;
      int num2;
  
      float getResult(string f_operator)
      {
          if (f_operator == "+")
          {
              return num1 + num2;
          }
          if (f_operator == "-")
          {
              return num1 - num2;
          }
          if (f_operator == "*")
          {
              return num1 * num2;
          }
      }
  };
  
  void demo()
  {
      Calculator calculator{};
      calculator.num1 = 10;
      calculator.num2 = 15;
  
      cout << calculator.num1 << " + " << calculator.num2 << " = " << calculator.getResult("+") << endl;
      cout << calculator.num1 << " - " << calculator.num2 << " = " << calculator.getResult("-") << endl;
      cout << calculator.num1 << " * " << calculator.num2 << " = " << calculator.getResult("*") << endl;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

- 多态实现

  ```c++
  //
  // Created by FHang on 2021/6/24 18:46
  //
  #include <iostream>
  
  using namespace std;
  
  class AbstractCalculator
  {
  public:
      int num1;
      int num2;
  
      virtual float getResult()
      {
          return 0.0;
      }
  };
  
  class SumCalculator : public AbstractCalculator
  {
  public:
      virtual float getResult()
      {
          return float (num1 + num2);
      }
  };
  
  class SubCalculator : public AbstractCalculator
  {
  public:
      virtual float getResult()
      {
          return float (num1 - num2);
      }
  };
  
  class MulCalculator : public AbstractCalculator
  {
  public:
      virtual float getResult()
      {
          return float (num1 * num2);
      }
  };
  
  void demo()
  {
      // 父类指针或引用指向子类执行
      AbstractCalculator *abs;
      // Sum
      abs = new SumCalculator;
      abs->num1 = 10;
      abs->num2 = 15;
      cout << abs->num1 << " + " << abs->num2 << " = " << abs->getResult() << endl;
      delete abs;
  
      // Sub
      abs = new SubCalculator;
      abs->num1 = 10;
      abs->num2 = 15;
      cout << abs->num1 << " - " << abs->num2 << " = " << abs->getResult() << endl;
      delete abs;
  
      // Mul
      abs = new MulCalculator;
      abs->num1 = 10;
      abs->num2 = 15;
      cout << abs->num1 << " * " << abs->num2 << " = " << abs->getResult() << endl;
      delete abs;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```



##### 4.7.4 纯虚函数和抽象类

- 纯函数和抽象类的定义和语法：
  - 在多态中，通常父类中虚函数的实现是无意义的，主要是调用子类中重写的内容，因此可将该虚函数称为 纯虚函数
  - 纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0；`
  - 当类中存在纯虚函数时，该类亦可称为抽象类；（例如：4.7.3中的AbstractCalculator类）

- 抽象类的特点：
  - 无法实例化对象
  - 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

- 示例：

  ```c++
  //
  // Created by FHang on 2021/6/24 19:15
  //
  #include <iostream>
  
  using namespace std;
  
  // 抽象类
  class Base
  {
  public:
      // 纯虚函数
      virtual void func() = 0;
  };
  
  class Derived : public Base
  {
  public:
      virtual void func()
      {
          cout << "Derived Function" << endl;
      }
  };
  
  void demo()
  {
      Base *base = new Derived;
      base->func();
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```



##### 4.7.5 多态案例-制作饮品

- 案例描述：煮水 -> 冲泡 -> 倒入杯中 -> 加入辅料

- 实现要求：利用多态，提供抽象制作的饮品基类，提供子类制作咖啡和茶叶

- 案例代码：

  ```c++
  //
  // Created by FHang on 2021/6/24 19:29
  //
  #include <iostream>
  
  using namespace std;
  
  class AbstractMakeDrinks
  {
  public:
      virtual void boilWater() = 0;
      virtual void brew() = 0;
      virtual void pourIntoCup() = 0;
      virtual void addAccessories() = 0;
  
      void makeDrinks()
      {
          boilWater();
          brew();
          pourIntoCup();
          addAccessories();
      }
  
      ~AbstractMakeDrinks()
      {
          cout << endl;
      }
  };
  
  class MakeCoffee : public AbstractMakeDrinks
  {
  public:
      MakeCoffee()
      {
          cout << "< -- Make Coffee -->" << endl;
      }
      virtual void boilWater()
      {
          cout << "BoilWater" << endl;
      }
      virtual void brew()
      {
          cout << "Brew Coffee" << endl;
      }
      virtual void pourIntoCup()
      {
          cout << "Pour Coffee Into The Cup" << endl;
      }
      virtual void addAccessories()
      {
          cout << "Add Accessories Like Milk" << endl;
      }
  };
  
  class MakeTea : public AbstractMakeDrinks
  {
  public:
      MakeTea()
      {
          cout << "< -- Make Tea -->" << endl;
      }
      virtual void boilWater()
      {
          cout << "BoilWater" << endl;
      }
      virtual void brew()
      {
          cout << "Brew Tea" << endl;
      }
      virtual void pourIntoCup()
      {
          cout << "Pour Tea Into The Cup" << endl;
      }
      virtual void addAccessories()
      {
          cout << "Add Accessories Like Sugar" << endl;
      }
  };
  
  // 参数是 指针地址 的写法
  void makeDrinks(AbstractMakeDrinks *abstractMakeDrinks)
  {
      abstractMakeDrinks->makeDrinks();
      delete abstractMakeDrinks;
  }
  
  void makeDrinks_Coffee()
  {
      makeDrinks(new MakeCoffee);
  }
  
  void makeDrinks_Tea()
  {
      makeDrinks(new MakeTea);
  }
  
  // 参数是 对象引用 的写法
  //void makeDrinks(AbstractMakeDrinks &abstractMakeDrinks)
  //{
  //    abstractMakeDrinks.makeDrinks();
  //    delete &abstractMakeDrinks;
  //}
  //
  //void makeDrinks_Coffee()
  //{
  //    makeDrinks(*new MakeCoffee);
  //}
  //
  //void makeDrinks_Tea()
  //{
  //    makeDrinks(*new MakeTea);
  //}
  
  int main()
  {
      makeDrinks_Coffee();
      makeDrinks_Tea();
      return 0;
  }
  ```



##### 4.7.6 虚析构和纯虚析构

- 多态使用时，如果子类中又属性开辟到堆区，父类指针在释放时无法调用到子类的析构代码

- 解决方式：将父类中的析构函数改为虚析构或纯虚析构

- 虚析构和纯虚析构的共性：

  - 可以解决父类指针释放子类对象
  - 都需要具体的函数实现

- 虚析构和纯虚析构的区别：

  - 如果是纯虚析构，该类属于抽象类，无法实例化对象

- 虚析构语法：`virtual ~类名 () {}`

- 纯虚析构语法：

  - 类内：`virtual ~类名 () = 0;`
  - 类外：`类名::~类名() {}`

- 代码示例：

  ```c++
  //
  // Created by FHang on 2021/6/24 20:24
  //
  #include <iostream>
  
  using namespace std;
  
  class Animal
  {
  public:
      Animal()
      {
          cout << "Animal Construct Transfer" << endl;
      }
      // 虚析构，此时释放父类时，会调用子类的析构函数
      virtual ~Animal()
      {
          cout << "Animal Destruct Transfer" << endl;
      }
      // 纯虚析构，在类外实现具体
      // virtual ~Animal() = 0;
  
      // 纯虚函数
      virtual void speak() = 0;
  };
  
  // 类外实现的 纯虚析构
  //Animal::~Animal()
  //{
  //    cout << "Animal Destruct Transfer" << endl;
  //}
  
  class Cat : public Animal
  {
  public:
      string *cat_Name;
  
      Cat(string name)
      {
          cout << "Cat Construct Transfer" << endl;
          cat_Name = new string(name);
      }
      ~Cat()
      {
          if (cat_Name != nullptr)
          {
              cout << "Cat Destruct Transfer" << endl;
              delete cat_Name;
              cat_Name = nullptr;
          }
      }
  
      virtual void speak()
      {
          cout << *cat_Name << "Cat is Speaking" << endl;
      }
  };
  
  void demo()
  {
      // 父类指针指向子类调用
      Animal *animal = new Cat("Tom");
      animal->speak();
      // 释放父类对象析构时，不会调用子类的析构函数，出现内存泄露
      // 在基类的析构函数前 加入关键字 virtual，即可解决问题
      delete animal;
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

- 总结：

  1. 虚析构和纯虚析构，用来解决父类指针释放子类对象
  2. 如果子类在堆区中，没有开辟空间，可以不写虚析构或纯虚析构
  3. 拥有纯虚析构的类，属于抽象类



##### 4.7.7 多态案例-电脑组装

- 案例描述：

  - 电脑主要组成部分：CPU，显卡，内存条；
  - 将每个零件封装成抽象基类，并且提供不同的厂商生产不同的零件，例如：Inter和AMD；
  - 创建电脑类提供电脑工作的函数，并且调用每个零件工作的接口；
  - 测试时，组装三台电脑进行测试

- 案例代码：

  ```c++
  //
  // Created by FHang on 2021/6/25 14:06
  //
  #include <iostream>
  
  using namespace std;
  
  // 抽象 CPU类
  class CPU
  {
  public:
      virtual void calculation() = 0;
  };
  
  // 抽象 显卡类
  class GraphicsCard
  {
  public:
      virtual void display() = 0;
  };
  
  // 抽象 内存类
  class RAM
  {
  public:
      virtual void storage() = 0;
  };
  
  // 电脑类
  class Computer
  {
  private:
      string *name;
      CPU *cpu;
      GraphicsCard *graphicsCard;
      RAM *ram;
  
  public:
      // 电脑零件组装
      Computer(string *name, CPU *cpu, GraphicsCard *graphicsCard, RAM *ram)
      {
          this->name = name;
          this->cpu = cpu;
          this->graphicsCard = graphicsCard;
          this->ram = ram;
          cout << "< --" << *this->name << " Computer Is Start Run" << "-- >" << endl;
      }
      ~Computer()
      {
          if (cpu != nullptr)
          {
              delete cpu;
              cpu = nullptr;
          }
          if (graphicsCard != nullptr)
          {
              delete graphicsCard;
              graphicsCard = nullptr;
          }
          if (ram != nullptr)
          {
              delete ram;
              ram = nullptr;
          }
          cout << "< --" << *this->name << " Computer Is Running Normal" << "-- >" << endl;
          cout << endl;
      }
  
      // 电脑运行函数
      void computerRun()
      {
          // 电脑零件 接口调用
          cpu->calculation();
          graphicsCard->display();
          ram->storage();
      }
  };
  
  // 具体厂商的类
  // Inter Class
  class Inter_CPU : public CPU
  {
  public:
      void calculation() override
      {
          cout << "Inter CPU Is Calculation" << endl;
      }
  };
  
  class Inter_GraphicsCard : public GraphicsCard
  {
  public:
      void display() override
      {
          cout << "Inter Graphics Card Is Displaying" << endl;
      }
  };
  
  class Inter_RAM : public RAM
  {
  public:
      void storage() override
      {
          cout << "Inter RAM Is In Storage" << endl;
      }
  };
  
  // AMD Class
  class AMD_CPU : public CPU
  {
  public:
      void calculation() override
      {
          cout << "AMD CPU Is Calculation" << endl;
      }
  };
  
  class AMD_GraphicsCard : public GraphicsCard
  {
  public:
      void display() override
      {
          cout << "AMD Graphics Card Is Displaying" << endl;
      }
  };
  
  class AMD_RAM : public RAM
  {
  public:
      void storage() override
      {
          cout << "AMD RAM Is In Storage" << endl;
      }
  };
  
  // 组装不同厂商组件的电脑
  // Assembling Inter Computer
  void assemblingComputer_Inter()
  {
      // 准备 Inter Computer 的 Component
      string name = "Inter";
      CPU *interCPU = new Inter_CPU;
      GraphicsCard *interGraphicsCard = new Inter_GraphicsCard;
      RAM *interRAM = new Inter_RAM;
  
      // Assembling Inter Computer
      Computer *computer = new Computer(&name, interCPU, interGraphicsCard, interRAM);
  
      // Running Inter Computer
      computer->computerRun();
      delete computer;
  }
  
  // Assembling AMD Computer
  void assemblingComputer_AMD()
  {
      // 准备 AMD Computer 的 Component
      string name = "AMD";
      CPU *amdCPU = new AMD_CPU;
      GraphicsCard *amdGraphicsCard = new AMD_GraphicsCard;
      RAM *amdRAM = new AMD_RAM;
  
      // Assembling AMD Computer
      Computer *computer = new Computer(&name, amdCPU, amdGraphicsCard, amdRAM);
  
      // Running AMD Computer
      computer->computerRun();
      delete computer;
  }
  
  int main()
  {
      assemblingComputer_Inter();
      assemblingComputer_AMD();
      return 0;
  }
  ```





### 5. 文件操作



- 文件作用：
  - 程序运行时产生的数据都是临时数据，程序结束后，都会被释放
  - 通过文件，可以将数据持久化
  - C++中对文件操作，需要包含头文件 `<fstream>`
- 文件类型：
  1. 文本文件：文件以文本的ASCII码形式存储在计算机中
  2. 二进制文件：文件以文本的二进制形式存储在计算机中，无法直接读懂
- 操作文件的三大类：
  1. `ofstream`：写操作	
  2. `ifstream`：读操作
  3. `fstream`：读写操作



#### 5.1 文本文件



##### 5.1.1 写文本文件



- 写文件步骤：

  1. 包含头文件：`#include <fstream>`
  2. 创建流对象：`ofstream ofs`
  3. 打开文件：`ofs.open("文件路径", 打开方式)`
  4. 写数据：`ofs << "写入数据";`
  5. 关闭文件：`ofs.close()`

- 文件的打开方式：

  | 打开方式    | 解释                         |
  | :---------- | :--------------------------- |
  | ios::in     | 为读文件而打开文件           |
  | ios::out    | 为写文件而打开文件           |
  | ios::ate    | 初始位置：文件尾             |
  | ios::app    | 追加方式写文件               |
  | ios::trunc  | 如果文件存在，先删除，再创建 |
  | ios::binary | 二进制方式                   |

- 注意：文件打开方式，可以配合使用，利用 `|`操作符

- 例如：用二进制方式写文件：`ios::binary | ios::out`

- 代码示例：

  ```c++
  //
  // Created by FHang on 2021/6/25 15:56
  //
  #include <iostream>
  #include <fstream>
  
  using namespace std;
  
  void demo()
  {
      ofstream ofs;
      ofs.open(R"(C:\Users\Admin\Desktop\demo.txt)", ios::out);
  
      ofs << "Hello World" << endl;
      ofs << "Hello FHang" << endl;
  
      ofs.close();
  
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```





##### 5.1.2 读文本文件



- 写文件步骤：

	1. 包含头文件：`#include <fstream>`
	2. 创建流对象：`ifstream ifs`
	3. 先判断打开文件是否成功，打开文件：`ifs.open("文件路径", 打开方式)`
	4. 读数据：四种读取方式
	5. 关闭文件：`ifs.close()`
	
- 代码示例：

  ```c++
  //
  // Created by FHang on 2021/6/25 16:06
  //
  #include <iostream>
  #include <fstream>
  
  using namespace std;
  
  void demo()
  {
      ifstream ifs;
      ifs.open(R"(C:\Users\Admin\Desktop\demo.txt)", ios::in);
  
      if (!ifs.is_open())
      {
          cout << "Open File Failed" << endl;
  	return;
      }
  
      // 读数据，四种
      // 1. 一行行读，不喜欢这个
  //    char buf[1024] = {0};
  //    while (ifs >> buf)
  //    {
  //        cout << buf << endl;
  //    }
  
      // 2. 一行行读，感觉一般
  //    char buf[1024] = {0};
  //    while (ifs.getline(buf, sizeof(buf)))
  //    {
  //        cout << buf << endl;
  //    }
  
      // 3. 一行行读，个人一般常用
      string buf;
      while (getline(ifs, buf))
      {
          cout << buf << endl;
      }
  
      // 4. 一个个读，慢
  //    char buf;
  //    while ((buf = ifs.get()) != EOF)
  //    {
  //        cout << buf;
  //    }
  
      ifs.close();
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```





#### 5.2 二进制文件



- 以二进制的方式对文件进行读写操作
- 打开方式需要指定：`ios:binary`



##### 5.2.1 写二进制文件



- 二进制写文件主要利用 流对象 调用成员函数 `write()`

- 函数原型：`ostream &write(const char *buffer, int len);`

- 参数解释：字符指针 `buffer`指向内存中一段内存空间，`len`是读写的字节数

- 代码示例：

  ```c++
  //
  // Created by FHang on 2021/6/25 16:34
  //
  #include <iostream>
  #include <fstream>
  
  using namespace std;
  
  class Person
  {
  public:
      string f_Name;
      int f_Age;
  };
  
  void demo()
  {
      Person person = {"FHang", 24};
      ofstream ofs;
      ofs.open(R"(C:\Users\Admin\Desktop\Person.txt)", ios::out | ios::binary);
      ofs.write((const char *) &person, sizeof(Person));
      ofs.close();
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```



##### 5.2.2 读二进制文件



- 二进制方式读文件，主要利用 流对象 调用成员函数 `read`

- 函数原型：`ostream &read(char *buffer, int len);`

- 参数解释：字符指针 `buffer`指向内存中一段内存空间，`len`是读写的字节数

- 代码示例：

  ```c++
  //
  // Created by FHang on 2021/6/25 17:00
  //
  #include <iostream>
  #include <fstream>
  
  using namespace std;
  
  class Person
  {
  public:
      string f_Name;
      int f_Age;
  };
  
  void demo()
  {
      Person person;
      ifstream ifs;
      ifs.open(R"(C:\Users\Admin\Desktop\Person.txt)", ios::in | ios::binary);
  
      if (!ifs.is_open())
      {
          cout << "Open File Failed" << endl;
          return;
      }
  
      ifs.read((char *) &person, sizeof(Person));
      cout << "Name = " << person.f_Name << endl;
      cout << "Age = " << person.f_Age << endl;
  
      ifs.close();
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```

  

