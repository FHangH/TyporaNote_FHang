# C++面试



### 1. 线程和进程的区别

-  线程和进程是操作系统中的两个基本概念。
- 线程是进程的一部分，它是操作系统调度的基本单位，而进程是一个具有一定独立功能的程序关于某个数据集合上的一次运行活动。

- 线程比进程更小，它可以更快地响应，并且更容易被操作系统调度。
- 线程可以共享进程的资源，如内存，文件句柄等，而进程之间不能共享资源。
- 此外，线程的上下文切换比进程的上下文切换更快，因为线程的上下文切换只需要保存和恢复少量的寄存器内容，而进程的上下文切换需要保存和恢复大量的内存内容。



### 2. 进程间通信方式

- 管道( pipe )
- 有名管道 (named pipe)
- 信号量( semophore )
- 消息队列( message queue )
- 信号 ( signal )
- 套接字( socket )



### 3. 线程间通信方式

- 事件(Event); 
- 信号量(semaphore); 
- 互斥量(mutex); 
- 临界区(Critical section)



### 4. 什么时候用进程或线程

- 在多任务系统中，进程和线程都可以用来实现并发执行。
- 进程是一个独立的执行单元，它有自己的内存空间和资源，可以被操作系统调度执行。
- 而线程是进程的一个执行单元，它可以共享进程的资源，但是比进程更小，更轻量，可以更快地被操作系统调度执行。
- 一般来说，如果需要多任务处理，可以使用进程；如果需要多线程处理，可以使用线程。此外，进程和线程也可以用来实现并发IO，以提高系统的性能。



### 5. 栈和堆的区别

栈（stack）: 

- 它由编译器自动管理，无需我 们手工控制
- 1M大小
- 计算机会在底层对栈提供支持：分配专门的寄存器存放 栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。但程序员无法对其进行控制。

堆（heap）: 

- 申请和释放由程序员控制
- 32 位系统下，堆内存可以达到 4G 的空间
- 由 new 或 malloc 分配的内存，一般速度比较慢，而且容易产生内 存碎片



### 6. C++和 C 的区别

C 是一个结构化语言，它的重点在于算法和数据结构。

C++中引入了重 载、内联函数、异常处理等。C++更是拓展了面向对象设计的内容，如类、继承、虚函数、模板和包容器类 等。



### 7. 产生死锁的必要条件

- 互斥条件：一个进程对共享资源的排他性使用，即一个资源在一段时间内只能被一个进程使用
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有
- 不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程强行剥夺，只有在资源使用完之后才能被释放
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系



### 8. 预防死锁

1. 避免死锁：可以通过研究系统资源分配图来避免死锁，即在分配资源之前先检查是否会发生死锁。
2. 预防死锁：可以通过设置资源分配次序来预防死锁，即按照一定的顺序分配资源，以避免出现死锁。
3. 检测死锁：可以通过定期检测系统中是否存在死锁来及时发现死锁，并采取相应的措施来解决。
4. 解除死锁：可以通过撤销进程或释放资源来解除死锁，以便让系统恢复正常运行。



### 9. TCP 和 UDP 的区别

TCP（传输控制协议）

- 是一种面向连接的、可靠的、基于字节流的传输层通信协议。
- 它主要用于在两台计算机之间传输数据，并且能够确保数据的正确传输。
- 它可以提供可靠的、有序的、双向的数据流，以及可靠的数据传输服务。
- 它是一种面向连接的协议，因此在传输数据之前，它需要建立一个连接。
- 它使用三次握手确认连接，然后才能传输数据。它还提供了流量控制、拥塞控制和可靠性等功能。



TCP三次握手：

1. 客户端发送一个SYN（synchronize）信号给服务器
2. 服务器收到后，回复一个SYN/ACK（synchronize-acknowledge）信号
3. 客户端收到后，再回复一个ACK（acknowledge）信号，这样就完成了一次三次握手



TCP四次挥手：

1. 客户端发送一个FIN（finish）信号给服务器
2. 服务器收到后，回复一个ACK（acknowledge）信号
3. 客户端收到后，再发送一个FIN
4. 服务器收到后，回复一个ACK，这样就完成了一次四次挥手



 UDP

- 是一种无连接的传输层协议，它不需要建立连接就可以发送数据，可以提供非常快速的数据传输。
- 它提供了不可靠的服务，因为它不能保证数据的完整性和可靠性，但是它可以提供高速的数据传输。



### 10. static 关键字

静态变量：

- 是在程序的整个生命周期中只存在一份拷贝，它的值在程序的整个生命周期中保持不变。它可以被所有函数所访问，在程序结束时才被释放。

- 静态变量和函数是指在程序的整个生命周期内都存在的变量和函数。
- 静态变量和函数可以在程序的任何地方被调用，而不必担心它们被重新定义或重新声明。
- 静态变量和函数可以用来存储和访问全局变量，这些变量可以在程序的任何地方被访问。
- 此外，静态变量和函数可以用来提供程序的私有函数，这些函数只能在程序的特定位置被调用。



### 11. const 关键字

1. `const` 关键字用于声明常量，即只读变量，它的值一旦被赋值，就不能再改变。
2. `const` 关键字还可以用于修饰指针，以保证指针所指向的内容不被修改。
3. 在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值
4. 对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的 成员变量
5. 对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”



### 12. 指针和引用的区别

指针和引用都可以用来指向变量或者对象

1. 指针是一个变量，可以在程序中被赋值和改变，而引用是一个别名，它的值不能被改变。
2. 指针可以指向不同的对象，而引用只能指向它初始化时指定的对象。
3. 指针可以为空，而引用不能为空。
4. 指针可以在函数间传递，而引用不能。



### 13. 哈希表

哈希表（Hash Table）是一种数据结构，它将键映射到值，使得查找和插入操作的时间复杂度都是O(1)。它的基本思想是：通过计算一个关键字的哈希值，可以直接定位到相关联的值，从而提高查找效率。



### 14. 哈希表处理冲突

链地址法：是指把所有的冲突关键字存储在一个线性链表中，这个链表由其散列地址唯一标识

开放定址法：指可存放新表项的空闲地址，既向它的同义词表项开放，又向它的非同义词表项开放

再散列法：利用另一个哈希函数再次计算一个地址。直到冲突不再发生

建立一个公共溢出区：一旦由哈希函数得到的地址冲突，就都填入溢出表



### 15. 面向对象的三大特性和五个原则

C++面向对象的三大特性：

- **封装**、**继承**和**多态**。这三个特性共同构成了面向对象编程的基础。

C++面向对象的五个原则是：

- **单一职责原则**：每个类只负责一项职责
- **开放封闭原则**：软件实体应该可以扩展，但不可修改
- **里氏替换原则**：子类可以替换父类
- **依赖倒置原则**：程序依赖抽象而不是具体实现
- **接口隔离原则**：接口应该尽量小，只包含客户端需要的方法



C++多态基于虚函数和虚继承实现：

- 用一个更通用的基类指针指向 不同的子类实例
- 为了能调用正确的方法，我们需要用到虚函数和虚继承。
- 在内存中，通过虚函数表来实 现子类方法的正确调用；
- 通过虚基类指针，仅保留一份基类的内存结构，避免冲突。



### 16. 深拷贝和浅拷贝

- 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间

- 深拷贝不但对指针进行拷贝， 而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。



### 17. vector 的实现原理

- `vector`的实现原理是基于动态数组的，它可以自动调整大小，以适应不断变化的数据量。
- 它使用一个连续的内存空间来存储元素，并且可以在不重新分配内存的情况下添加或删除元素。
- 它的实现原理是：
  - 当添加元素时，`vector`会检查它的容量，如果容量不足，它会自动重新分配内存，以容纳新元素；
  - 当删除元素时，`vector`会自动调整它的容量，以释放多余的内存空间。

​	

### 18. C++ 源代码到可执行代码的详细过程

编译：将高级语言指令转换为功能等效 的汇编代码，再由汇编程序转换为机器语言，并且按照操作系统对可执行文件格式的要求链接生成可执行 程序



源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件

1. 预处理：将源代码中的宏定义和条件编译指令处理成可供编译器处理的形式，使用预处理器（如cpp）将源代码中的宏定义和条件编译指令处理成可供编译器处理的形式。
2. 编译：将预处理后的源代码编译成汇编代码，使用编译器（如GCC）将源代码编译为汇编代码，汇编代码是机器可以识别的代码。
3. 优化：对汇编代码进行优化，使用优化器（如GCC）对汇编代码进行优化，以提高程序的执行效率。
4. 汇编：将优化后的汇编代码翻译成机器代码，使用汇编器（如GAS）将汇编代码翻译成机器代码，机器代码是机器可以直接执行的代码。
5. 链接：将多个机器代码文件链接成可执行文件，使用链接器（如LD）将多个机器代码文件链接成可执行文件，可执行文件是机器可以直接运行的文件。



### 19. 虚函数和纯虚函数的区别

虚函数：

- 虚函数为了重载和多态的需要，在基类中定义的，即便定义为空；纯虚函数是在基类中声明 的虚函数，它可以再基类中有定义，且派生类必须定义自己的实现方法
- 一旦父类的成员函数声明 virtual，其子类的函数不管有没有声明为 virtual，都是虚函数

- 基类定义虚函数（可以实现，也可以不实现）
- 子类（可以重载和不重载）

纯虚函数：

- 是基类只定义了函数体，没有实现过程（类似接口）
- 纯虚必须在子类去实现

普通函数如果不被使用，可以只有声明没有定义，虚函数必须要有定义，即使是一个空实现,因为编译 器无法确定会使用哪个函数



### 20. overload,override,overwrite 的区别

**Overload(重载)：**在 C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载

- （1）相同的范围（在同一个类中）； 
- （2）函数名字相同；
- （3）参数不同； 
- （4）virtual 关键字可有可无。

**Override(覆盖)：**是指派生类函数覆盖基类函数，特征是： 

- （1）不同的范围（分别位于派生类与基类）； 
- （2）函数名字相同； 
- （3）参数相同； 
- （4）基类函数必须有 virtual 关键字

**Overwrite(重写)：**是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 

- （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字， 基类的函数将被隐藏。 
- （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关 键字。此时，基类的函数被隐藏。



### 21. 强制类型转换

1. `static_cast`：用于基本类型之间的转换，可以安全地执行数据类型转换。
   - a、用于类层次结构中基类和派生类之间指针或引用的转换 上行转换（派生类—->基类）是安全的； 下行转换（基类—->派生类）由于没有动态类型检查，所以是不安全的。 
   - b、用于基本数据类型之间的转换，如把 int 转换为 char，这种带来安全性问题由程序员来保证 
   - c、把空指针转换成目标类型的空指针 
   - d、把任何类型的表达式转为 void 类型
2. `const_cast`：用于去除常量属性，可以把常量转换成非常量。
3. `reinterpret_cast`：用于指针和引用之间的转换，可以把指针和引用转换成其他指针和引用类型。
4. `dynamic_cast`：用于多态类型之间的转换，可以把多态类型转换成其他多态类型。



### 22. malloc/free，new/delete

- `malloc`/`free`是C语言中的内存分配函数，它们只能用于分配和释放内存，不能调用构造函数和析构函数，因此不能用于管理类对象
- `new`/`delete`是C++语言中的内存分配函数，它们不仅可以用于分配和释放内存，还可以调用构造函数和析构函数，因此可以用于管理类对象。

对于非内部数据类型的对象而言，对象的消亡之前要自动执行析构函数。由于 malloc/free 是库函数 而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于 malloc/free，因 此只有使用 new/delete 运算符



### 23.  c++11 特性

**nullptr**

- 传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些 编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0
- C++ 不允许直接将 `void *` 隐式转换到其他类型，但如果 NULL 被定义为` ((void*)0)`，那么当编译`char *ch = NULL`;时，NULL 只好被定义为 0，而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱
  - `void foo(char *)`
  - `void foo(int)`
- NULL 又被定义为了 0 那么 `foo(NULL)`; 这个语句将会去调用 `foo(int)`， 从而导致代码违反直观
- nullptr 的类型为 `nullptr_t`，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等 或者不等的比较



**ChatGPT:**

- `nullptr` 和 `NULL` 是C++中的两个特殊值，它们都表示空指针，但是它们之间有一些重要的区别：
  1. `nullptr` 是一个特殊的指针类型，它可以被用来表示任何类型的指针，而 `NULL` 只能表示原始指针类型。
  2. `nullptr` 是一个新的C++11特性，而 `NULL` 是C++98中的一个宏定义，它可以被用来表示空指针。
  3. `nullptr` 可以被用来调用重载函数，而 `NULL` 不能。
  4. `nullptr` 可以被用来初始化指针，而 `NULL` 不能。



**auto**

- `auto` 是C++11中的一个关键字，它可以被用来自动推断变量的类型，从而简化程序的书写。它的主要用途有：
  1. 简化变量的声明：使用`auto`可以更简单地声明变量，而不必指定变量的类型，从而简化程序的书写。
  2. 提高代码的可读性：使用`auto`可以更有效地表达变量的意图，从而提高代码的可读性。
  3. 更有效地使用模板：使用`auto`可以更有效地使用模板，从而提高代码的可读性和可维护性。



C++11 还引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：

```c++
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) 
{
	return x+y;
}
```

C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：

```c++
template<typename T, typename U>
auto add(T x, U y) 
{
    return x+y;
}
```



**区间迭代**

```c++
// & 启用了引用
for(auto &i : arr) 
{
	std::cout << i << std::endl;
}
```

- 使用`&i`可以更有效地处理数组中的每一个元素，因为它可以直接引用数组中的元素，而不必创建新的变量来存储数组中的元素，从而提高程序的性能
- 使用`const auto &i`可以保证数组中的每一个元素在循环中不会被修改，从而提高程序的可读性和可维护性。但是，使用`const auto &i`会使程序的性能略有下降，因为它会多消耗一些内存。
- 因为它会多消耗一些内存，因为它会创建一个新的变量来存储数组中的元素，而不是直接引用数组中的元素，从而消耗更多的内存。



**模板增强**

**外部模板 **

- 传统 C++ 中，模板只有在使用时才会被编译器实例化，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时 间的增加。`没有办法通知编译器不要触发模板实例化`

- C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能 够显式的告诉编译器何时进行模板的实例化：

```c++
template class std::vector; // 强行实例化 
extern template class std::vector; // 不在该编译文件中实例化模板
```



**类型别名模板**

- 在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。 因为，模板不是类型

  ```c++
  template< typename U>
  typedef SuckType<std::vector<int>, U, 1> NewType; // 不合法
  ```

- C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效： 

  ```c++
  template  using NewType = SuckType; // 合法
  ```



**默认模板参数**

- C++11 中提供了一种便利，可以指定模板的默认参数：

  ```c++
  template<typename T = int, typename U = int>
  auto add(T x, U y) -> decltype(x+y) // C++ 11中， C++14 直接写成：auto add(T x, U y)即可
  {
  	return x+y;
  }
  ```

  

**构造函数**

**委托构造**

- C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数， 从而达到简化代码的目的：

  ```c++
  class Base 
  {
  public:
  	int value1;
  	int value2;
  	Base() 
  	{
  		value1 = 1;
  	}
  	Base(int value) : Base() 
  	{ // 委托 Base() 构造函数
  		value2 = 2;
  	}
  };
  ```



**继承构造**

- 派生类想要使用基类的构造函数，需要在构造函数中显式声明

- C++11中：如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类 各种构造函数更加节省目标代码空间

  ```c++
  C++11 的继承构造：
  struct A
  {
   	A(int i) {}
   	A(double d,int i){}
   	A(float f,int i,const char* c){}
   	//...等等系列的构造函数版本
  };
  struct B:A
  {
   	using A::A;
   	//关于基类各构造函数的继承一句话搞定
   	//......
  };
  ```



**Lambda 表达式**

- 实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一 个函数，但是又不想费力去命名一个函数的情况下去使用的

  ```c++
  [ caputrue ] ( parameters ) options -> returnType
  {
      body; 
  };
  ```

- capture 是可选的，用于捕获外部变量；

- parameters 是可选的，用于接收参数；

- returnType 是可选的，用于指定返回值类型；

- body 是必需的，用于定义 lambda 表达式的函数体。

- options 是函数选项；可以填 mutable,exception,attribute（选填） :

  - mutable 说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的 non-const 方法。
  - exception 说明 lambda 表达式是否抛出异常以及何种异常。
  - attribute 用来声明属性。



**捕获列表**

- lambda 表达式的捕获列表精细控制了 lambda 表达式能够访问的外部变量，以 及如何访问这些变量

  - `[]`不捕获任何变量
  - 捕获外部变量：可以使用 `&` 或 `=` 来捕获外部变量。(按值捕获)且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷 贝
  - 捕获 this 指针：可以使用 `this` 来捕获 this 指针。捕获 this 的目的是可以在 lamda 中使 用当前类的成员函数和成员变量
  - 捕获外部类成员：可以使用 `&` 来捕获外部类成员。
  - `[=,&foo]`按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。
  - `[bar]`按值捕获 bar 变量，同时不捕获其他变量。

- 如果希望去修改按值捕获的外部变量，需 要显示指明 lambda 表达式为 mutable。被 mutable 修饰的 lambda 表达式就算没有参数也要写 明参数列表

- 捕获列表捕获住 的任何外部变量，最终会变为闭包类型的成员变量，按照 C++标准，lambda 表达式的operator() 默认是 const 的，而 mutable 的作用，就在 于取消 operator()的 const

  ```c++
  int a = 0;
  auto f1 = [=] { return a++; }; //error
  auto f2 = [=] () mutable { return a++; }; //OK
  ```

- Lambda原理：

  - 定义一个 lambda 表达式后，编译器会自动生成一个匿 名类（这个类重载了()运算符），我们称为闭包类型
  - 运行时，这个 lambda 表达式就会返回一个匿名的闭包实例，是一个右值
  - 对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成 员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包
  - 引用捕获方式，无论 是否标记 mutable，都可以在 lambda 表达式中修改捕获的值

- lambda 表达式是不能被赋值的:

  ```c++
  auto a = [] { cout << "A" << endl; };
  auto b = [] { cout << "B" << endl; };
  a = b; // 非法，lambda 无法赋值
  zauto c = a; // 合法，生成一个副本
  ```

- 闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个 lambda 表达式去初 始化另外一个 lambda 表达式而产生副本

- 悬挂引用：引用捕获不会 延长引用的变量的生命周期

  ```c++
  std::function<int(int)> add_x(int x)
  {
   return [&](int a) { return x + a; };
  }
  // 参数 x 仅是一个临时变量，函数 add_x 调用后就被销毁了，但是返回的 lambda 表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果
  ```

- Lambda函数指针：

  - STL 定义在< functional >头文件提供了一个多态的函数对象封装 std::function，其类似于函数指针。它可以绑定任何 类函数对象，只要参数与返回类型相同

    ```c++
    std::function<bool(int, int)> wrapper = [](int x, int y) { return x < y; };
    ```

  - 重要应用：作为参数传递，实现函数回调

  - 最常用的是在 STL 算法中：`count_if()`，`generate()`，`for_each()`



**新增容器**

**std::array**

- 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从 而获得更高的性能

- 在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 只需指定其类型和大小即可

  ```c++
  std::array<int, 4> arr= {1,2,3,4};
  int len = 4;
  std::array<int, len> arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式
  ```



**std::forward_list**

- `std::list`是双向链表
- `std::forward_list`是单向链表
- 提供了 O(1) 复杂度 的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法 的容器
- 不需要双向迭代时，具有比 std::list 更高的空间利用率



**无序容器**

包括 `unordered_set`、`unordered_map`、`unordered_multiset` 和 `unordered_multimap`

特点：

- 它们使用哈希函数来存储元素，而不是使用比较函数。
- 它们提供了更快的查找性能，因为它们可以在常数时间内查找元素。
- 它们支持更快的插入和删除操作，因为它们不需要移动元素来维护有序性。



**元组 std::tuple**

三个核心的函数：

- `std::make_tuple`: 构造元组 
- `std::get`: 获得元组某个位置的值 
- `std::tie`: 元组拆包

合并两个元组，可以通过 `std::tuple_cat`:

```c++
auto new_tuple = std::tuple_cat(get_student(1), std::move(t));
```



**语言级线程支持**

代码编译需要使用 -pthread 选项

- `std::thread` 类，用于创建和控制线程。
- `std::mutex` 类，用于控制线程之间的互斥访问。
- `std::condition_variable` 类，用于实现线程间的同步。
- `std::future` 类，用于获取异步操作的结果。
- `std::atomic` 类，用于实现原子操作。

线程同步：

```c++
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex m;
std::condition_variable cv;

void thread_func()
{
    std::unique_lock<std::mutex> lock(m);
    cv.wait(lock);
    // Do something
}

int main()
{
    std::thread t(thread_func);
    // Do something
    cv.notify_one();
    t.join();
    return 0;
}
```



**右值引用和 move 语义**

**右值引用**

通过重载直接使用右值参数。 我们所要做的就是写一个以右值引用为参数的构造函数：

```c++
string(string&& that) // string&& is an rvalue reference to a string
{
	data = that.data;
	that.data = 0;
}
```

没有深度拷贝堆内存的数据，而是复制了指针，并把源对象的指针置空

由于源对象是一个右值，不会再被使用，因此 客户并不会觉察到源对象被改变了`转移构造函数`

类别：

- `var&`：左值引用
- `var&&`：右值引用

示例：

- C++ 11 中，`std::auto_ptr< T >`已经被 `std::unique_ptr< T >`所取代，后者就是利用的右值引用

- 其转移构造函数：

  ```c++
  unique_ptr(unique_ptr&& source) // note the rvalue reference
  {
   	ptr = source.ptr;
   	source.ptr = nullptr;
  }
  
  unique_ptr<Shape> a(new Triangle);
  unique_ptr<Shape> b(a); // error
  unique_ptr<Shape> c(make_triangle()); // okay
  ```

  第二行不能编译通过，因为 a 是左值，但是参数 unique_ptr&& source 只能接受右值，这正是我们所 需要的，杜绝危险的隐式转移



**转移左值**

```c++
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a); // still an error
unique_ptr<Shape> c(std::move(a)); // okay
```

- std::move 仅仅是简单地将左值转换为 右值，它本身并没有转移任何东西。它仅仅是让对象可以转移
- 注意：第三行之后，a 不再拥有 Triangle 对象。不过这没有关系，因为通过明确的写 出 std::move(a)，我们很清楚我们的意图



### 24. STL resize与reserve

`resize()` 和 `reserve()` 都是用于管理容器大小的函数，但它们的作用不同

- `resize()` 
  - 用于更改容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器 内的对象了
  - resize 函数可以有两个参数，第一个参数是容器新的大小，第二个参数是要加入容器 中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数
- `reserve()` 
  - 用于预留容器的存储空间间，但并不真正创建元素对象，在创建对象之前，不能引用容器内 的元素
  - reserve 函数之后一个参数，即需要预留的容器的空间



### 25. vector与deque

**vector**

vector是动态容器，随着内容的添加，容器大小会在内部自行扩容，相较于array，array是静态空间，扩容的需要自行扩容

`vector 的数据结构`：

- 线性线性空间。它以两个迭代器 start 和 finish 分别指向配置得 来的连续空间中目前已经被使用的范围，并以迭代器 end_of_storage 指向整块连续空间的尾端

`vector 的构造与内存管理`：

- 插入元素时，如果空间不够，会另开辟一块更大的空间，让容器迭代器指向新的空间



**deque**

deque 是一种双向开口的连续线性空间（`双端队列`）。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删 除操作

`deque 的中控器`：

- deque是由一段一段的定量连续空间构成，一旦有必要在 deque 的前端或尾端增加新空间，便配置一段 定量连续空间，串接在整个 deque 的头端或尾端
- deque便是在这些分段的定量连续空间上， 维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价则是复 杂的迭代器架构
- deque 采用一块所谓的 map(注意,不是 STL 的 map 容器)作为主控。这里所谓 map 是一小块连续空间 ， 其中每个元素(此处称为一个节点, node)都是指针，指向另一段(较大的) 连续线性空间，称为缓冲区。缓 冲区才是 deque 的存储空间主体

`deque 的构造与内存管理`：

- 果申请的 map 空间不够时，也需要重新配置更大的空间，将原来 map 里的指针拷贝过来，最后释放 原来的空间

`vector 和 deque 的区别`：

- vector 是单向开口的连续线性空间， dequeu 是一种双向开口的连续线性定
- deque 允许于常数时间内对起头端进行元素的插入或移除操作
- deque 没有所谓容量(capacity)观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新 的空间并链接起来



### 26. 大端小端

示例：

- 值：123456
- 地址：从右往左（默认） 或 从下往上（地址由小增大）

大端：654321

小端：123456

```c++
int checkCPU()
{
 	union w
 	{
 		int a;
 		char b;
 	}c;
 	c.a = 1;
 	return (c.b == 1);//小端返回 1，大端返回 0
}
```



### 27. malloc 原理

堆的介绍：

- 堆块由一个字的头部、有效载荷、填充以及一个字的脚部组成，空闲块是通过头部中的大小 字段隐含地连接在一起形成一个隐式空闲链表，分配器可以通过遍历堆中所有的块，从而间接遍历整个空 闲块的集合

malloc()步骤：

- `放置`、`分割`、`合并`



**放置**

用请求一个 k 字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲 块，分配器执行这种搜索的方式是放置策略确定的

常见的策略：

- 首次适配：从头开始搜索空闲链表，选择第一个适合的空闲块。 
- 下一次适配：从上一次查询结束的地方开始搜索空闲链表，选择第一个适合的空闲块。 
- 最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。



**分割**

一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空块中多少空间。 一个选择是用整个空闲块，另一个选择是将这个空闲块分割成两部分

果分配器不能为请求块找到合适的空闲块将发生什么：

- 选择是通过合并那些在内存中物理上相邻 的空闲块来创建一些更大的空闲块
- 还是不能生成一个足够大的块，或者如果空闲块已经 最大程度地合并了，那么分配器就会通过调用 sbrk 函数，向内核请求额外的堆内存，分配器将额外的内存 转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中



**合并**

边界标记：允许在常数时间内进行对前面的块合并

- 每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本
- 如果每个块包括这样一个脚部， 那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态
- 这个脚部总是在当前块开始位 置一个字的距离



### 28. 构造、析构函数的虚函数

构造函数不能声明为虚函数：

- 构造一个对象，必须知道对象的类型
- 当对象还没有构造完成时，编译器无法确定对象是类本身，还是派生类
- 虚函数的执行依赖于虚函数表，虚函数表在构造函数中完成，如果构造函数声明为虚函数，调用构造函数时，虚函数表没有初始化，构造将无法进行

析构函数可以：

- 调用析构函数时，对象已经确定，虚函数表也已经存在，可以正常使用
- 在类的继承中，基类指针指向子类对象，基类delete，析构函数如果不是虚函数，子类对象不会执行析构函数
- 析构时，先从最下面的子类开始逐层向父类析构



### 29. STL unordered_map 和 map

unordered_map：

- 键值对形式
- hashMap
- 无序存储
- 不存重复的键



**hash_map 与 unordered_map**

- unordered_map 在 C++11 的时候被引入标准库

- 查询平均时间是 O(1)，unordered，就是无序了，数据是按散列函数 插入到槽里面去的，数据之间无顺序可言
- 有些时候我只要访问而不需要顺序，因此可以选择哈希表



**unordered_map 与 map**

- map 的内部结构是 R-B-tree 来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是 O（logn），最坏和平均都是
- 是并不是 unordered_map 查询时间一定比 map 短，因为实际情况中还要考虑到数据量
- unordered_map 的 hash 函数的构造速度也没那么快



**unordered_map 与 unordered_set**

- unordered_set：value 就是它自己的 key，而不是像之前的 unordered_map 那样 有键-值对



题目：

- A,B 两组数， 由整数组成，然后把 B 中在 A 中出现的数字取出来，要求用线性时间完成，用 unordered_set 来存放 A 的数

分析：

- 可以使用 `unordered_set` 来存放 A 中的数字，然后遍历 B 中的每个数字，判断它是否在 A 中出现过。由于 `unordered_set` 的查找操作是平均 O(1) 时间复杂度的，所以整个算法的时间复杂度是线性的

代码：

```c++
#include <iostream>
#include <vector>
#include <unordered_set>

std::vector<int> find_common_elements(const std::vector<int>& A, const std::vector<int>& B) 
{
    std::unordered_set<int> setA(A.begin(), A.end());  // 将 A 中的数字存入 unordered_set
    std::vector<int> result;  // 存放结果的 vector

    for (auto num : B) 
    {
        if (setA.count(num) > 0) 
        {  // 如果 num 在 setA 中出现过，说明它在 A 中也出现过
            result.push_back(num);  // 将 num 加入结果 vector
        }
    }

    return result;
}

int main() {
    std::vector<int> A = {1, 2, 3, 4, 5};
    std::vector<int> B = {3, 4, 5, 6, 7};
    std::vector<int> result = find_common_elements(A, B);

    // 输出结果：[3, 4, 5]
    for (auto num : result) 
    {
        std::cout << num << " ";
    }

    return 0;
}
```



### 30. C/C++中 extern

`extern` 用于在一个文件中引用在另一个文件中定义的全局变量或函数

`extern` 声明的变量或函数只是一个声明，而不是定义。这意味着在当前文件或函数中使用

`extern` 声明的变量或函数时，编译器不会为其分配内存空间或生成代码。相反，编译器会在链接时查找该变量或函数的定义，并将其与声明进行匹配。



**extern 修饰变量的声明**

- 如果文件 a.c 需要引用 b.c 中变量 int v，就可 以在 a.c 中声明 extern int v，然后就可以引用变量 v



**extern 修饰函数声明**

- 从本质上来讲，变量和函数没有区别。函数名是指向函数二进 制块开头处的指针
- 文件 a.c 需要引用 b.c 中的函数，比如在 b.c 中原型是 int fun(int mu)，那么就可以在 a.c 中声明 extern int fun（int mu），然后就能使用 fun 来做任何事情



**使用 extern 和包含头文件来引用函数有什么区别**

- extern 的引用方式比包含头文件要简洁得多
- 加速程序的编译（确切的说是预处理）的过程，节省时间



**extern 修饰符可用于指示 C 或者 C++函数的调用规范**

- 在 C++中调用 C 库 函数，就需要在 C++程序中用 extern “C”声明要引用的函数

- 这是给链接器用的，告诉链接 器在链接的时候用 C 函数规范来链接

- 主要原因是 C++和 C 程序编译完成后在目标代码中命名 规则不同

- 示例：

  - 我们要在C++中包含一个名为 `example.h` 的C头文件

  - example.h

    ```c
    #ifdef __cplusplus
    extern "C" {
    #endif
    
    /* C语言代码 */
    
    #ifdef __cplusplus
    }
    #endif
    ```

  - index.cpp

    ```c++
    #include "example.h"
    ```

    

### 31.  C++类的四个缺省函数

- 默认构造函数
- 拷贝构造函数
- 析构函数
- 赋值函数



### 32. 重写拷贝构造函数

当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝

示例：

```c++
#include <cstring>

class MyClass 
{
public:
    // 构造函数
    MyClass(int size) 
    {
        // 分配内存
        m_size = size;
        m_data = new int[m_size];
    }

    // 拷贝构造函数
    MyClass(const MyClass& other) 
    {
        // 复制成员变量
        m_size = other.m_size;
        m_data = new int[m_size];
        std::memcpy(m_data, other.m_data, m_size * sizeof(int));
    }

    // 析构函数
    ~MyClass() 
    {
        // 释放内存
        delete[] m_data;
    }

private:
    int m_size;
    int* m_data;
};
```

解释：

- 拷贝构造函数的参数是一个 `const MyClass&` 类型的引用，这意味着它接受一个常量引用。
- 在拷贝构造函数中，我们创建一个新的对象，并将其成员变量设置为与另一个对象相同的值。
- 对于指向动态内存分配的指针成员变量 `m_data`，我们使用 `new` 运算符为它分配新的内存，并使用 `std::memcpy` 函数将原始数据复制到新的内存中。
- 这确保了新对象和原对象的指针成员变量都指向不同的内存地址，从而实现了深拷贝。最后，在析构函数中，我们释放了 `m_data` 指向的内存

注意：

- 如果类中有其他指针成员变量，也需要在拷贝构造函数中进行深拷贝，以确保新对象和原对象的指针成员变量都指向不同的内存地址



### 33. 调用拷贝构造函数

- 创建对象时
- 当类的一个对象去初始化该类的另一个对象时
- 如果函数的形参是类的对象，调用函数进行形参和实参结合时
- 如果函数的返回值是类对象，函数调用完成返回时



### 34. 构造函数的特征

- 专门用来初始化对象成员变量的
- 构造函数的名字必须与类名相同
- 它不具有任何类型
- 不返回任何值



### 35. 类外访问类非公有成员

- 友元
- 继承
- 公有成员函数
- 父类 protected



### 36. 不允许重载的运算符

`*`（成员指针访问运算符号）

`::`域运算符

`sizeof` 长度运算符号

`?`条件运算符号

`.`（成员访问符）

