# C++_面向对象反汇编补充



### 1. 类



#### 1.1 类的定义

- C++中可以使用 `struct`，`class`来定义类



#### 1.2 struct和class区别



- `struct`默认成员权限是`public`
- `class`默认成员权限是`private`



##### 1.2.1 定义和访问



- 代码示例：

  ```c++
  struct Person
  {
      int m_Age;
      
      void run()
      {
          cout << "m_Age: " << m_Age << endl;
      }
  };
  
  class Person
  {
  public:    
      int m_Age;
      
      void run()
      {
          cout << "m_Age: " << m_Age << endl;
      }
  };
  
  Person person;
  // 通过对象访问
  person.m_Age = 20;
  person.run();
  
  // 通过指针访问
  Person *ptr_Person = &person;
  ptr_Person ->m_Age = 20;
  ptr_Person ->run();
  ```

- `对象person` 和 `指针ptr_Person`的内存都是在函数的栈空间中，自动分配和回收

- `对象person`只有一个`int类型`的成员变量，所以是`4字节`

- `指针ptr_Person`在 `32位`占用`4字节`，`64位`占用`8字节`







##### 1.2.2 反汇编查看区别



- 代码示例1：

  ```c++
  class Car
  {
  public:
      int m_price;
      
      void run()
      {
          cout << "Car::run() " << m_price << endl;
      }
  };
  
  int main()
  {
      Car car1;
      car1.m_price = 10;
      car1.run();
      
      Car car2;
      car2.m_price = 20;
      car2.run();
      
      return 0;
  }
  ```

  ```assembly
  // 查看核心部分汇编代码
  
  mov dword ptr[car1], 0Ah // 由此可得，对象占用4字节，成员变量占用4字节，所以第一个成员变量的内存地址就是对象的地址
  // Car car1;
  // car1.m_price = 10;
  
  lea ecx, [car1]
  call 0086141A // 此处 call run()
  // car1.run();
      
  mov dword ptr[car2], 14h
  // Car car2;
  
  lea ecx, [car2]
  call 0086141A // 此处 call run()
  // car2.m_price = 20;
  // car2.run();
  
  // 由上可以等到，两个对象 car1 和 car2 的成员变量是不同的
  // 但它们调用的函数的地址是同一个
  ```

- 对象内的函数不占用对象的内存大小：

  - 类中的函数在编译阶段，会将函数的地址存放到单独的一段内存中
  - 当两个函数完全相同时，会去重，仅保留一个函数地址
  - 一个类生成的多个对象中，只有成员变量是每个对象各自拥有的，而成员方法则是统一去重存储在`方法列表`中

- 补充：

  - 无论函数和变量存在于什么地方，如果没有在其它地方使用或调用
  - 该函数和变量，在编译阶段会被优化，也就是根本不存在







#### 1.3 对象的内存布局



- 代码示例：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      person.m_id = 100;
      
      cout << "&person = " << &person << endl;
      cout << "&person.m_age = " << &person.m_age << endl;
      cout << "&person.m_id = " << &person.m_id << endl;
      return 0;
  }
  ```

- 运行结果：

  ```powershell
  &person = 0x7bfe18
  &person.m_age = 0x7bfe18   
  &person.m_id = 0x7bfe1c  
  ```








### 2. this



- 隐式参数
- 存储着函数调用者的地址



- 代码示例1：

  ```c++
  struct Person
  {
    int m_age;
    
    void run()
    {
      // 编译器会隐式传参
      // this = &person1
        this->m_age = 3;
    }
  };
  
  int main()
  {
      Person person1;
      person1.m_age = 10;
      person1.run();
      
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  // ebp-8 是 this 的地址
  // eax 是 person1 的地址
  
  // Person person1;
  // person1.m_age = 10;
  mov dword ptr [ebp-0Ch], 0Ah
  
  // person.run();
  lea ecx, [ebp-0Ch]
  call 00181366
  	mov dword ptr [ebp-8], ecx
  	
  	// this->m_age = 3;
  	mov eax. dword ptr [ebp-8]
  	mov dword ptr [eax], 3
  ```





- 代码示例2：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
    
    void run(){}
  };
  
  int main()
  {
      Person person1;
      person1.m_age = 10;
      person1.m_id = 20;
      person1.run();
  	
      Person *person2 = &person1;
      person2->m_age = 10;
      person2->m_id = 10;
      person2->run();
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  // Person person1;
  // person1.m_age = 10;
  mov dword ptr [ebp-14h], 0Ah
  
  // person1.m_id = 20;
  mov dword ptr [ebp-10h], 14h
  
  // person1.run();
  lea ecx, [ebp-14h]
  call 00FA141F
  	
  // Person *person2 = &person1;
  lea eax, [ebp-14h] // [ebp-14h]是person1的地址
  mov dword ptr [ebp-20h], eax // [ebp-20h]是指针变量person2的地址
  
  // person2->m_age = 10;
  mov eax, dword ptr [ebp-20h] // eax存储的是person1的地址值
  mov dword ptr [eax], 0Ah 
  
  // person2->m_id = 10;
  mov eax, dword ptr [ebp-20h]
  mov dword ptr [eax+4], 0Ah 
  
  // person2->run();
  mov ecx, dword ptr [ebp-20h] // 将person1地址隐式传给this
  call 003B141F
  ```



- 代码示例3：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
    int m_height;  
    
    void run()
    {
        cout << m_age << "+" << m_id << "+" << m_height << endl;
    }
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      person.m_id = 20;
      person.m_height = 30;
  	
      Person *p = (Person *) &person.m_age;
      p->m_age = 0;
      p->m_id = 0;
      
      // 注意：这里用的 person，不是 p
      person.run();
      return 0;
  }
  
  # 打印结果：
  # 10+0+0
  ```

- 反汇编分析：

  ```assembly
  // Person *p = (Person *) &person.m_id;
  // eax == &person.m_id == person+4
  
  // p->m_age = 0;
  mov eax, dword ptr [p]
  mov dword ptr [eax + 0], 0h
  
  // p->m_id = 0;
  mov eax, dword ptr [p]
  mov dword ptr [eax + 4], 0h
  
  // 在栈空间中>> &person == &person.m_age
  // 改程序中 eax 的存储的地址是 &person.m_id == &person+4
  // 所以>> 
  // p->m_age = 0; 修改的是 m_id
  // p->m_id = 0; 修改的是 m_height
  ```

- 思考：

  ```c++
  Person *p = (Person *) &person.m_age;
  p->m_age = 0;
  p->m_id = 0;
  
  // person 对象的地址传递给 run 的this
  person.run();
  // 改为
  // 将指针 p 里存储的地址值传给 run 的this == &person.m_id 传递给 this
  p->run();
  
  # 打印结果
  # 40+50+-858993460
  # -858993460 == Oxcccccccc
  ```

- 补充：

- 上面的程序打印结果：`Oxcccccccc`

- 由来：函数调用是，开辟栈空间，调用结束，用`cccccccc`来填充内存空间

- 原因：

  - `cc`的汇编是`int3`：断点
  - `int`是`硬件中断`

- 作用：防止`指针`或`jump`之类的指令，指向错误的内存地址，可能造成系统安全问题，所以用硬件中断指令填充被释放的栈空间

  ```assembly
  // p->run();
  // 汇编中有一条指令
  mov eax, 0cccccccch
  rep stos dword ptr es:[edi]
  ```

  



### 3. 内存空间的布局



- 每个应用都有自己独立的内存空间：
  - 代码区(代码段)：用于存放代码
  - 全局区(数据段)：用于存放全局变量等
  - 栈空间：
    - 每调用一个函数就会给它分配一个连续的栈空间，等函数调用完毕后会自动回收这段栈空间
    - 自动分配和回收
  - 堆空间：需要主动去申请和释放



#### 3.1 代码区



- 只读
- 存放CPU指令(机器码)



#### 3.2 全局区



- 程序结束，全局区的数据才会清空





#### 3.3 堆空间



- 在程序运行过程中，为了能自由控制内存的生命周期，大小，会经常使用堆空间的内存



##### 3.3.1 堆空间申请和释放



- 堆空间的申请和释放：(`C/C++语言 => malloc() / free()`)

  ```c++
  void demo()
  {
      // malloc(4) 申请4字节堆空间，返回 void *，强转成 int *
      int *p = (int *)malloc(4);
      // int * 占用4个字节，所以 10 赋值给4个字节空间
      *p = 10;
      // 释放 p 申请的所有空间
      free(p);
      
      char *p = (char *)malloc(4);
      // char * 占用1个字节空间，所以 10 赋值给 p地址的第一个字节，另外3个字节是空的
      *p = 10;
      *(p + 1) = 11;
      *(p + 2) = 12;
      *(p + 3) = 13;
      // 等价于
      p[0] = 10;
      p[1] = 11;
      p[2] = 12;
      p[3] = 13;
      
      free(p);
  }
  ```

- 分析上面代码的内存分布：

  ```c++
  int *p = (int *)malloc(4);
  *p = 10;
  
  // X86 -- 32bit ，int 指针占用 4 字节，64bit 占用 8字节
  // 栈空间
  # 地址：0x111
  # 占用：4字节
  # p = 0x999
  
  // 堆空间
  # 地址：0x999
  # 占用：4字节
  # 值：10
  ```





- 堆空间的申请和释放：(`C++语言-新 => new / delete`)

  ```c++
  void demo()
  {
      int *p = new int; // 等价于  int *p = (int *)malloc(4);
      *p = 10;
      
      // 释放
      delete p;
  }
  ```

- (`new[] / delete []`)

  ```c++
  void demo()
  {
      char *p = new char[4]; // 等价于  char *p = (char *)malloc(4);
      *p = 10;
      
      // 释放
      delete p; // 错误：此时 只会 释放地址p的第一个字节空间，后面3个字节没有释放
      delete[] p; // 正确：释放 p 申请的所有空间
  }
  ```



- 注意：
  - 申请堆空间成功后，会返回那一段空间的地址
  - 申请和释放必须是一一对应的，不然会造成内存泄露



##### 3.3.2 堆空间初始化



- 简单示例：(`memset == memory set`)

  ```c++
  int *p1 = (int *)malloc(sizeof(int)); // *p1 未初始化
  
  int *p2 = (int *)malloc(sizeof(int));
  memset(p2, 0, sizeof(int)); // *p2 的每个字节初始化为0
  ```



- 其它初始化方式：

  ```c++
  int *p = new int; // 未初始化
  int *p = new int(); // 每个字节初始化为0
  // mov __memset(0), eax
  
  int *p = new int(5); // 每个字节初始化为5
  
  int *p = new int[3]; // 数组三个元素未初始化
  int *p = new int[3](); // 数组三个元素初始化为0
  int *p = new int[3]{}; // 数组三个元素初始化为0
  int *p = new int[3]{5}; // 数组首元素初始化为5，其它元素初始化为0
  ```





###### 3.3.2.1 memset



- memset 函数将较大的数据结构(`对象，数组等等`)内存清零的比较快的方式



- 代码示例1：

  ```c++
  Person person;
  person.id = 1;
  person.age = 2;
  person.height = 3;
  
  memset(&person, 0, sizeof(person));
  ```



- 代码示例2：

  ```c++
  Person persons[] = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};
  memset(persons, 0, sizeof(persons));
  ```







#### 3.4 对象的内存



- 对象可以存在于3个地方
  1. 全局区(数据段)：全局变量
  2. 栈空间：函数里面的局部变量
  3. 堆空间：动态申请内存(malloc, new等)



- 代码示例：

  ```c++
  // 全局区
  Person person;
  
  int main()
  {
      // 栈空间
      Person person;
      
      // 堆空间
      Person *person = new Person;
      return 0;
  }
  ```







### 4. 构造函数



- 类的默认构造函数，无论其对象在什么地方创建，都会调用构造函数
- 但存在特殊情况，在堆中创建对象，构造函数不会调用



- 代码示例：

  ```c++
  Person *person = (Person *)malloc(sizeof(Person));
  free(person);
  // malloc 不会调用构造函数
  
  Person *person = new Person;
  delete person;
  // 这个 new 会调用构造函数
  ```



##### 4.1 关于构造函数的错误概念



- 错误概念：当类内`没有自己定义`构造函数，编译器会默认添加一个`空实现的，无参的，默认构造函数`
- 正确理解：在特定情况下，编译器才会为类生成`空的无参构造函数`
- 具体情况：后面的`虚函数`会总结



- 代码示例：(`定义了构造函数`)

  ```c++
  class Person
  {
      int m_age;
      
      Person(){}
  };
  
  int main()
  {
      Person person;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  lea ecx, [person]
  call Person::Person (0A914BFh)
  // 定义了构造函数时，对象创建会调用构造函数
  ```



- 代码示例：(`没定义构造函数`)

  ```c++
  class Person
  {
      int m_age;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  # person.m_age = 10;
  mov dword ptr[person], 0Ah
  // 类没有定义构造函数时，编译时也不会创建所谓的：空实现的，无参的，默认构造函数
  ```



- 代码示例：(`没定义构造函数，但类中静态初始化了成员变量`)

  ```c++
  class Person
  {
      int m_age = 0;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  lea ecx, [person]
  call Person::Person (0314C4h)
  # person.m_age = 10;
  mov dword ptr[person], 0Ah
  
  // 没定义构造函数，但类中静态初始化了成员变量，此时编译器会创建：空实现的，无参的，默认构造函数
  ```
