# C++_面向对象反汇编补充



### 1. 类



#### 1.1 类的定义

- C++中可以使用 `struct`，`class`来定义类



#### 1.2 struct和class区别



- `struct`默认成员权限是`public`
- `class`默认成员权限是`private`



##### 1.2.1 定义和访问



- 代码示例：

  ```c++
  struct Person
  {
      int m_Age;
      
      void run()
      {
          cout << "m_Age: " << m_Age << endl;
      }
  };
  
  class Person
  {
  public:    
      int m_Age;
      
      void run()
      {
          cout << "m_Age: " << m_Age << endl;
      }
  };
  
  Person person;
  // 通过对象访问
  person.m_Age = 20;
  person.run();
  
  // 通过指针访问
  Person *ptr_Person = &person;
  ptr_Person ->m_Age = 20;
  ptr_Person ->run();
  ```

- `对象person` 和 `指针ptr_Person`的内存都是在函数的栈空间中，自动分配和回收

- `对象person`只有一个`int类型`的成员变量，所以是`4字节`

- `指针ptr_Person`在 `32位`占用`4字节`，`64位`占用`8字节`







##### 1.2.2 反汇编查看区别



- 代码示例1：

  ```c++
  class Car
  {
  public:
      int m_price;
      
      void run()
      {
          cout << "Car::run() " << m_price << endl;
      }
  };
  
  int main()
  {
      Car car1;
      car1.m_price = 10;
      car1.run();
      
      Car car2;
      car2.m_price = 20;
      car2.run();
      
      return 0;
  }
  ```

  ```assembly
  // 查看核心部分汇编代码
  
  mov dword ptr[car1], 0Ah // 由此可得，对象占用4字节，成员变量占用4字节，所以第一个成员变量的内存地址就是对象的地址
  // Car car1;
  // car1.m_price = 10;
  
  lea ecx, [car1]
  call 0086141A // 此处 call run()
  // car1.run();
      
  mov dword ptr[car2], 14h
  // Car car2;
  
  lea ecx, [car2]
  call 0086141A // 此处 call run()
  // car2.m_price = 20;
  // car2.run();
  
  // 由上可以等到，两个对象 car1 和 car2 的成员变量是不同的
  // 但它们调用的函数的地址是同一个
  ```

- 对象内的函数不占用对象的内存大小：

  - 类中的函数在编译阶段，会将函数的地址存放到单独的一段内存中
  - 当两个函数完全相同时，会去重，仅保留一个函数地址
  - 一个类生成的多个对象中，只有成员变量是每个对象各自拥有的，而成员方法则是统一去重存储在`方法列表`中

- 补充：

  - 无论函数和变量存在于什么地方，如果没有在其它地方使用或调用
  - 该函数和变量，在编译阶段会被优化，也就是根本不存在







#### 1.3 对象的内存布局



- 代码示例：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      person.m_id = 100;
      
      cout << "&person = " << &person << endl;
      cout << "&person.m_age = " << &person.m_age << endl;
      cout << "&person.m_id = " << &person.m_id << endl;
      return 0;
  }
  ```

- 运行结果：

  ```powershell
  &person = 0x7bfe18
  &person.m_age = 0x7bfe18   
  &person.m_id = 0x7bfe1c  
  ```








### 2. this



- 隐式参数
- 存储着函数调用者的地址



- 代码示例1：

  ```c++
  struct Person
  {
    int m_age;
    
    void run()
    {
      // 编译器会隐式传参
      // this = &person1
        this->m_age = 3;
    }
  };
  
  int main()
  {
      Person person1;
      person1.m_age = 10;
      person1.run();
      
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  // ebp-8 是 this 的地址
  // eax 是 person1 的地址
  
  // Person person1;
  // person1.m_age = 10;
  mov dword ptr [ebp-0Ch], 0Ah
  
  // person.run();
  lea ecx, [ebp-0Ch]
  call 00181366
  	mov dword ptr [ebp-8], ecx
  	
  	// this->m_age = 3;
  	mov eax. dword ptr [ebp-8]
  	mov dword ptr [eax], 3
  ```





- 代码示例2：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
    
    void run(){}
  };
  
  int main()
  {
      Person person1;
      person1.m_age = 10;
      person1.m_id = 20;
      person1.run();
  	
      Person *person2 = &person1;
      person2->m_age = 10;
      person2->m_id = 10;
      person2->run();
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  // Person person1;
  // person1.m_age = 10;
  mov dword ptr [ebp-14h], 0Ah
  
  // person1.m_id = 20;
  mov dword ptr [ebp-10h], 14h
  
  // person1.run();
  lea ecx, [ebp-14h]
  call 00FA141F
  	
  // Person *person2 = &person1;
  lea eax, [ebp-14h] // [ebp-14h]是person1的地址
  mov dword ptr [ebp-20h], eax // [ebp-20h]是指针变量person2的地址
  
  // person2->m_age = 10;
  mov eax, dword ptr [ebp-20h] // eax存储的是person1的地址值
  mov dword ptr [eax], 0Ah 
  
  // person2->m_id = 10;
  mov eax, dword ptr [ebp-20h]
  mov dword ptr [eax+4], 0Ah 
  
  // person2->run();
  mov ecx, dword ptr [ebp-20h] // 将person1地址隐式传给this
  call 003B141F
  ```



- 代码示例3：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
    int m_height;  
    
    void run()
    {
        cout << m_age << "+" << m_id << "+" << m_height << endl;
    }
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      person.m_id = 20;
      person.m_height = 30;
  	
      Person *p = (Person *) &person.m_age;
      p->m_age = 0;
      p->m_id = 0;
      
      // 注意：这里用的 person，不是 p
      person.run();
      return 0;
  }
  
  # 打印结果：
  # 10+0+0
  ```

- 反汇编分析：

  ```assembly
  // Person *p = (Person *) &person.m_id;
  // eax == &person.m_id == person+4
  
  // p->m_age = 0;
  mov eax, dword ptr [p]
  mov dword ptr [eax + 0], 0h
  
  // p->m_id = 0;
  mov eax, dword ptr [p]
  mov dword ptr [eax + 4], 0h
  
  // 在栈空间中>> &person == &person.m_age
  // 改程序中 eax 的存储的地址是 &person.m_id == &person+4
  // 所以>> 
  // p->m_age = 0; 修改的是 m_id
  // p->m_id = 0; 修改的是 m_height
  ```

- 思考：

  ```c++
  Person *p = (Person *) &person.m_age;
  p->m_age = 0;
  p->m_id = 0;
  
  // person 对象的地址传递给 run 的this
  person.run();
  // 改为
  // 将指针 p 里存储的地址值传给 run 的this == &person.m_id 传递给 this
  p->run();
  
  # 打印结果
  # 40+50+-858993460
  # -858993460 == Oxcccccccc
  ```

- 补充：

- 上面的程序打印结果：`Oxcccccccc`

- 由来：函数调用是，开辟栈空间，调用结束，用`cccccccc`来填充内存空间

- 原因：

  - `cc`的汇编是`int3`：断点
  - `int`是`硬件中断`

- 作用：防止`指针`或`jump`之类的指令，指向错误的内存地址，可能造成系统安全问题，所以用硬件中断指令填充被释放的栈空间

  ```assembly
  // p->run();
  // 汇编中有一条指令
  mov eax, 0cccccccch
  rep stos dword ptr es:[edi]
  ```

  



### 3. 内存空间的布局



- 每个应用都有自己独立的内存空间：
  - 代码区(代码段)：用于存放代码
  - 全局区(数据段)：用于存放全局变量等
  - 栈空间：
    - 每调用一个函数就会给它分配一个连续的栈空间，等函数调用完毕后会自动回收这段栈空间
    - 自动分配和回收
  - 堆空间：需要主动去申请和释放



#### 3.1 代码区



- 只读
- 存放CPU指令(机器码)



#### 3.2 全局区



- 程序结束，全局区的数据才会清空





#### 3.3 堆空间



- 在程序运行过程中，为了能自由控制内存的生命周期，大小，会经常使用堆空间的内存



##### 3.3.1 堆空间申请和释放



- 堆空间的申请和释放：(`C/C++语言 => malloc() / free()`)

  ```c++
  void demo()
  {
      // malloc(4) 申请4字节堆空间，返回 void *，强转成 int *
      int *p = (int *)malloc(4);
      // int * 占用4个字节，所以 10 赋值给4个字节空间
      *p = 10;
      // 释放 p 申请的所有空间
      free(p);
      
      char *p = (char *)malloc(4);
      // char * 占用1个字节空间，所以 10 赋值给 p地址的第一个字节，另外3个字节是空的
      *p = 10;
      *(p + 1) = 11;
      *(p + 2) = 12;
      *(p + 3) = 13;
      // 等价于
      p[0] = 10;
      p[1] = 11;
      p[2] = 12;
      p[3] = 13;
      
      free(p);
  }
  ```

- 分析上面代码的内存分布：

  ```c++
  int *p = (int *)malloc(4);
  *p = 10;
  
  // X86 -- 32bit ，int 指针占用 4 字节，64bit 占用 8字节
  // 栈空间
  # 地址：0x111
  # 占用：4字节
  # p = 0x999
  
  // 堆空间
  # 地址：0x999
  # 占用：4字节
  # 值：10
  ```





- 堆空间的申请和释放：(`C++语言-新 => new / delete`)

  ```c++
  void demo()
  {
      int *p = new int; // 等价于  int *p = (int *)malloc(4);
      *p = 10;
      
      // 释放
      delete p;
  }
  ```

- (`new[] / delete []`)

  ```c++
  void demo()
  {
      char *p = new char[4]; // 等价于  char *p = (char *)malloc(4);
      *p = 10;
      
      // 释放
      delete p; // 错误：此时 只会 释放地址p的第一个字节空间，后面3个字节没有释放
      delete[] p; // 正确：释放 p 申请的所有空间
  }
  ```



- 注意：
  - 申请堆空间成功后，会返回那一段空间的地址
  - 申请和释放必须是一一对应的，不然会造成内存泄露



##### 3.3.2 堆空间初始化



- 简单示例：(`memset == memory set`)

  ```c++
  int *p1 = (int *)malloc(sizeof(int)); // *p1 未初始化
  
  int *p2 = (int *)malloc(sizeof(int));
  memset(p2, 0, sizeof(int)); // *p2 的每个字节初始化为0
  ```



- 其它初始化方式：

  ```c++
  int *p = new int; // 未初始化
  int *p = new int(); // 每个字节初始化为0
  // mov __memset(0), eax
  
  int *p = new int(5); // 每个字节初始化为5
  
  int *p = new int[3]; // 数组三个元素未初始化
  int *p = new int[3](); // 数组三个元素初始化为0
  int *p = new int[3]{}; // 数组三个元素初始化为0
  int *p = new int[3]{5}; // 数组首元素初始化为5，其它元素初始化为0
  ```





###### 3.3.2.1 memset



- memset 函数将较大的数据结构(`对象，数组等等`)内存清零的比较快的方式



- 代码示例1：

  ```c++
  Person person;
  person.id = 1;
  person.age = 2;
  person.height = 3;
  
  memset(&person, 0, sizeof(person));
  ```



- 代码示例2：

  ```c++
  Person persons[] = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};
  memset(persons, 0, sizeof(persons));
  ```







#### 3.4 对象的内存



- 对象可以存在于3个地方
  1. 全局区(数据段)：全局变量
  2. 栈空间：函数里面的局部变量
  3. 堆空间：动态申请内存(malloc, new等)



- 代码示例：

  ```c++
  // 全局区
  Person person;
  
  int main()
  {
      // 栈空间
      Person person;
      
      // 堆空间
      Person *person = new Person;
      return 0;
  }
  ```







### 4. 构造函数



- 类的默认构造函数，无论其对象在什么地方创建，都会调用构造函数
- 但存在特殊情况，在堆中创建对象，构造函数不会调用
- 通过`malloc()`，不会调用构造函数



- 代码示例：

  ```c++
  Person *person = (Person *)malloc(sizeof(Person));
  free(person);
  // malloc 不会调用构造函数
  
  Person *person = new Person;
  delete person;
  // 这个 new 会调用构造函数
  ```



#### 4.1 构造函数的错误概念



- 错误概念：当类内`没有自己定义`构造函数，编译器会默认添加一个`空实现的，无参的，默认构造函数`
- 正确理解：在特定情况下，编译器才会为类生成`空的无参构造函数`
- 具体情况：后面的`虚函数`会总结



- 代码示例：(`定义了构造函数`)

  ```c++
  class Person
  {
      int m_age;
      
      Person(){}
  };
  
  int main()
  {
      Person person;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  lea ecx, [person]
  call Person::Person (0A914BFh)
  // 定义了构造函数时，对象创建会调用构造函数
  ```



- 代码示例：(`没定义构造函数`)

  ```c++
  class Person
  {
      int m_age;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  # person.m_age = 10;
  mov dword ptr[person], 0Ah
  // 类没有定义构造函数时，编译时也不会创建所谓的：空实现的，无参的，默认构造函数
  ```



- 代码示例：(`没定义构造函数，但类中静态初始化了成员变量`)

  ```c++
  class Person
  {
      int m_age = 0;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  lea ecx, [person]
  call Person::Person (0314C4h)
  # person.m_age = 10;
  mov dword ptr[person], 0Ah
  
  // 没定义构造函数，但类中静态初始化了成员变量，此时编译器会创建：空实现的，无参的，默认构造函数
  ```





#### 4.2 构造函数的调用



- 通过多种创建对象的方式，判读是否调用了类的构造函数



- 代码示例：

  ```c++
  class Person
  {
  public:
      int m_age;
  
      Person()
      {
          m_age = 0;
          cout << "Person()" << endl;
      }
  
      Person(int age)
      {
          m_age = age;
          cout << "Person(int)" << endl;
      }
  };
  
  Person g_person0; // Person()
  Person g_person1(); // 这是 g_person1() 函数的声明或定义，不会调用构造函数
  Person g_person2(10); // Person(int)
  
  int main()
  {
      Person person0; // Person()
      Person person1(); // 这是 g_person1() 函数的声明或定义，不会调用构造函数
      Person person2(20); // Person(int)
  
      Person *p0 = new Person; // Person()
      Person *p1 = new Person(); // Person() ，这是在堆空间中创建对象
      Person *p2 = new Person(30); // Person(int)
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo1
  Person()
  Person(int)
  Person()
  Person(int)
  Person()
  Person()
  Person(int)
  ```





#### 4.3 构造函数的成员变量初始化



- 默认情况下，没有自定义构造函数时，只有全局区和堆区的对象创建，会初始化为0，其余栈空间不会初始化成员变量

- 如果自定义了构造函数，除了全局区，其它内存空间的成员变量默认都不会被初始化，需要手动初始化



- 代码示例1：`(无自定义构造函数)`

  ```c++
  class Person
  {
  public:    
      int m_age;
  };
  
  // 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0
  Person g_person;
  
  int main()
  {
      // 栈空间的对象直接被编译器优化了，不会初始化成员变量
      // Person person;
  
      // 没有初始化
      Person *p0 = new Person;
  
      // 初始化
      Person *p1 = new Person();
  
      cout << g_person.m_age << endl;
      cout << p0->m_age << endl;
      cout << p1->m_age << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo2
  0
  14184048
  0
  ```

- 得出结论：

  1. `全局区`内，内存值默认全是 `0`
  2. `堆空间`内，通过 `()` 申请的内存，默认初始化为 `0`
  3. `栈空间`内，默认初始化为 `cccccccc`





- 代码示例2：`(有自定义构造函数) -> 空实现`

  ```c++
  class Person
  {
  public:    
      int m_age;
      
      Person(){}
  };
  
  // 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0
  Person g_person;
  
  int main()
  {
      // 没有初始化
      Person *p0 = new Person;
  
      // 没有初始化，初始化工作交给自定义构造函数，然而自定义构造函数是空实现，所以没有初始化
      Person *p1 = new Person();
  
      cout << g_person.m_age << endl;
      cout << p0->m_age << endl;
      cout << p1->m_age << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo2
  0
  14184048
  14184048
  ```





#### 4.4 构造函数的集体初始化



- 通过`memset()`方法实现



- 代码示例：

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  
  class Person
  {
  public:    
      int m_age;
  
      Person()
      {
          // memset() 方法，方便用于类成员变量集体初始化或清零
          memset(this, 0, sizeof(Person));
      }
  };
  
  int main()
  {
      Person *p1 = new Person();
  
      cout << p1->m_age << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo3
  0
  ```





### 5. 析构函数



- 又名`析构器`，在对象销毁时自动调用，一般用于完成对象的清理工作
- 没有返回值，不能重载
- 通过`malloc()`分配的对象，`free()`时，不会调用析构函数
- 类中的构造函数和析构函数，需要`public:`修饰后，才能被外界调用
- 全局区的对象，不会调用析构函数



#### 5.1 malloc与析构函数

- 代码示例1：

  ```c++
  class Person
  {
  public:    
      int m_age;
  
      Person()
      {
          cout << "Person()" << endl;
      }
      ~Person()
      {
          cout << "~Person()" << endl;
      }
  };
  
  int main()
  {
      // malloc 的 对象不会调用 构造函数 和 析构函数
      Person *p0 = (Person *)malloc(sizeof(Person));
      free(p0);
  
      Person *p1 = new Person();
      delete p1;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo4
  Person()
  ~Person()
  ```





#### 5.2 对象内申请的堆区对象



- 对象析构时，只会回收对象，如果对象的成员变量指向堆空间，需要手动释放，否则会造成`内存泄漏`
- 内存泄漏：该释放的内存，没有去释放



- 代码示例：

  ```c++
  class Car
  {
  public:
      int m_price;
  
      Car()
      {
          cout << "Car()" << endl;
      }   
      ~Car()
      {
          cout << "~Car()" << endl;
      } 
  };
  
  class Person
  {
  public:    
      int m_age;
      Car *m_car;
  
      Person()
      {
          // 此处的 m_car是在堆空间中声明，需要delete才能回收
          // 如果是栈空间声明，person在调用析构函数时，会先回收m_car
          m_car = new Car;
          cout << "Person()" << endl;
      }
      ~Person()
      {
          delete m_car;
          cout << "~Person()" << endl;
      }
  };
  
  int main()
  {
      Person person;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo5
  Car()
  Person()
  ~Car()
  ~Person()
  ```







### 6. 声明和实现



- 类的定义和声明分离，分别在 `.h`和`.cpp`中实现



#### 6.1 具体演示



`Person.h`

```c++
class Person
{
private:
    int m_age;

public:
    Person();
    ~Person();

    void set_Age(int age);
    int get_Age();
};
```



`Person.cpp`

```c++
Person::Person()
{
    cout << "Person()" << endl;
}
Person::~Person()
{
    cout << "~Person()" << endl;
}

void Person::set_Age(int age)
{
    m_age = age;
}
int Person::get_Age()
{
    return m_age;
}
```



`main.cpp`

```c++
#include <iostream>
using namespace std;

int main()
{
    Person person;
    person.set_Age(10);
    int age = person.get_Age();

    cout << age << endl;

    return 0;
}
```



- 打印结果：

  ```c++
  PS C:\Users\Admin\Desktop\Project\Demo2> .\demo1.exe
  Person()
  10
  ~Person()
  ```







### 7. 命名空间



- 作用：
  - 解决重复命名的问题
  - 命名空间不影响内存布局和结构



#### 7.1 命名空间的基本用法



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  namespace fh1
  {
      class Person
      {
      private:
          int m_age;
  
      public:
          Person();
          ~Person();
      };
  }
  
  namespace fh2
  {
      class Person
      {
      private:
          int m_age;
  
      public:
          Person();
          ~Person();
      };
  }
  
  int main()
  {
      fh1::Person person1;
      fh2::Person person2;
      return 0;
  }
  ```





#### 7.2 命名空间的嵌套



- 命名空间可以一直嵌套



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  namespace fh1
  {
      namespace fh2
      {
          class Person
          {
          private:
              int m_age;
  
          public:
              Person();
              ~Person();
          };
      }
  }
  
  int main()
  {
      fh1::fh2::Person person;
      return 0;
  }
  ```

  





#### 7.3 存在最大默认命名空间



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  namespace fh
  {
      void func()
      {
          cout << "fh::func()" << endl;
      }
  }
  
  void func()
  {
      cout << "func()" << endl;
  }
  
  int main()
  {
      fh::func();
      // 通过默认的全局命名空间，访问 fh
      ::fh::func();
  
      func();
      
     	// 通过默认的全局命名空间，访问 func()
      ::func();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo2> .\demo4.exe
  fh::func()
  fh::func()
  func()
  func()
  ```








### 8. 继承



- 继承可以让子类拥有父类的所有成员





#### 8.1 继承的内存布局



- 子对象中的成员变量分布：最上层的父类的成员变量在子对象的首地址，依次向下排列



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:
      int height;    
  };
  
  class Student : public Person
  {
  public:
      int age;    
  };
  
  class My : public Student
  {
  public:
      int id;    
  };
  
  int main()
  {
      Person person;
      Student student;
      My my;
      my.height = 9;
      my.age = 10;
      my.id = 11;
  
      cout << "Person: " << sizeof(person) << endl;
      cout << "Student: " << sizeof(student) << endl;
      cout << "My: " << sizeof(my) << endl;
      
      cout << &my.height << endl;
      cout << &my.age << endl;
      cout << &my.id << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo1.exe
  Person: 4
  Student: 8
  My: 12
  0x7bfe08
  0x7bfe0c
  0x7bfe10
  ```

- 总结：父类的成员变量在前面，子类的在后面

- 补充：父类的成员变量，子类中没有使用，子类的对象大小依然不变，编译器不会去优化，所以要合理设计类







#### 8.2 成员访问权限



- 成员访问权限、继承方式有3种：
  1. `public`：公共的，任何地方都可以访问（`struct默认`）
  2. `private`：私有的，只有当前类内部可以访问（`class默认`）
  3. `protected`：子类内部和当前类可以访问

- 子类在继承父类时，使用了权限修饰：子类内部访问父类成员的权限，是一下两项中权限最小的
  1. 成员本身的访问权限
  2. 上一级父类的继承方式
- 开发中最多的继承方式是`public`继承，保留父类原来的成员访问权限
- 访问权限，不影响对象的内存布局







### 9. 初始化列表



- 特点：
  - 一种便捷的初始化成员变量的方式
  - 只用于构造函数
  - 初始化顺序，只跟成员变量的声明顺序有关
- 补充：
  - 如果构造函数的声明和实现分离，初始化列表只能写在实现中



- 语法：

  ```c++
  class Person
  {
  private:    
      int m_age;
      int m_height;
  
  public:
      // 普通写法
      Person(int age, int height)
      {
          m_age = age;
          m_height = height;
      }
  
      // 初始化列表
      Person(int age, int height) : m_age(age), m_height(height)
      {
      }
  };
  ```

- 两种写法完全等价：(反汇编查看)

  ```assembly
  // 普通构造函数
  // m_age = age;
  mov eax, dword ptr[this]
  mov ecx, dword ptr[age]
  mov dword ptr[eax], ecx
  
  // m_height = height;
  mov eax, dword ptr[this]
  mov ecx, dword ptr[height]
  mov dword ptr [eax+4], ecx
  
  // 初始化列表
  // m_age(age)
  mov eax, dword ptr[this]
  mov ecx, dword ptr[age]
  mov dword ptr[eax], ecx
  
  // m_height(height)
  mov eax, dword ptr[this]
  mov ecx, dword ptr[height]
  mov dword ptr [eax+4], ecx
  ```







### 10. 构造函数互调





#### 10.1 互调语法



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  private:    
      int m_age;
      int m_height;
  
  public:
      // 错误的写法
      // Person() {Person(10, 20);}
      
      // 正确的写法
      Person() : Person(0, 0){}
  
      Person(int age, int height)
      {
          m_age = age;
          m_height = height;
  
          cout << m_age << " " << m_height << endl;
      }
  };
  
  
  int main()
  {
      Person person1;
      Person person2(10, 20);
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo3.exe
  0 0
  10 20
  ```





#### 10.2 语法分析



- 通过反汇编分析两种写法的正确性

  ```assembly
  // 错误的写法
  // 原因：在函数体中写的 Person(0, 0); 是创建临时Person的对象，0 赋值给了临时的Person对象
  // Person() {Person(0, 0);}
  lea ecx, [person1]
  call Person::Person(0E61118h)
  
  mov dword ptr [this], ecx
  push 14h
  push 0Ah
  
  lea ecx, [person] // person是临时对象
  call Person::Person(0E61311h)
  
  mov dword ptr[this], ecx
  
  // 正确的写法
  // Person() : Person(0, 0){}
  lea ecx, [person2]
  call Person::Person(01221118h)
  
  mov dword ptr [this], ecx
  push 14h
  push 0Ah
  
  mov dword ptr[this], ecx
  call Person::Person(01221311h)
  
  mov dword ptr[this], ecx
  ```





#### 10.3 父类的构造函数



- 子类的构造函数默认会调用父类的无参构造函数
- 子类的构造函数主动调用了父类的有参构造函数，则父类的无参构造函数不会被调用
- 如果父类缺少无参构造函数，子类构造函数就必须显式调用父类的有参构造函数



- 代码示例1：(默认会调用父类的无参构造函数)

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      Person()
      {
          cout << "Person::Person()" << endl;
      }
  };
  
  class Student : public Person
  {
  public:    
      Student()
      {
          cout << "Student::Student()" << endl;
      }
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo4.exe
  Person::Person()
  Student::Student()
  ```



- 代码示例2：(主动调用了父类的有参构造函数)

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      Person()
      {
          cout << "Person::Person()" << endl;
      }
  
      Person(int age)
      {
          cout << "Person::Person(int)" << endl;
      }
  };
  
  class Student : public Person
  {
  public:    
      Student() : Person(10)
      {
          cout << "Student::Student()" << endl;
      }
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo4.exe
  Person::Person(int)
  Student::Student()
  ```





#### 10.4 构造和析构的顺序





- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      Person()
      {
          cout << "Person::Person()" << endl;
      }
      ~Person()
      {
          cout << "Person::~Person()" << endl;
      }
  };
  
  class Student : public Person
  {
  public:    
      Student()
      {
          cout << "Student::Student()" << endl;
      }
      ~Student()
      {
          cout << "Student::~Student()" << endl;
      }
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo5.exe
  Person::Person()
  Student::Student()
  Student::~Student()
  Person::~Person()
  ```







### 11. 多态



- 默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态



- 多态是面向对象非常重要的特性
  - 同一个操作，用于不同的对象，可以有不同的解释，产生不同的结果
  - 在运行时，可以识别出真正的对象类型，调用对应子类中的函数



- 多态的要素：
  - 子类重写父类的成员函数`(override)`
  - 父类指针指向子类
  - 利用父类指针调用重写的成员函数





#### 11.1 父类和子类指针



- 父类指针指向子类对象是安全的，子类的继承方式是`public`
- 子类指针指向父类对象是不安全的



- 代码示例1：父类指针指向子类对象

  ```c++
  #include <iostream>
  using namespace std;
  
  struct Person
  {
      int m_age;
  };
  
  struct Student : Person
  {
      int m_score;
  };
  
  int main()
  {
      Person *person = new Student;
      person->m_age = 10;
      cout << "person->m_age: " << person->m_age << "\n";
  
      return 0;
  }
  ```

- 打印结果

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo1.exe
  person->m_age: 10
  ```

- 总结：

  - 父类指针指向子类对象，这样用父类指针使用成员变量时，会很`安全`，不会影响到子类独有的成员变量
  - 父类的成员变量存在得到内存空间，肯定在子类对象的内存范围内，不会超出子类对象的内存范围，所以`安全`





- 代码示例2：子类指针指向父类对象

  ```c++
  #include <iostream>
  using namespace std;
  
  struct Person
  {
      int m_age;
  };
  
  struct Student : Person
  {
      int m_score;
  };
  
  int main()
  {    
      Student *student = (Student *)new Person;
      student->m_age = 10;
      student->m_score = 100;
      
      cout << "m_age: " << student->m_age << "\n" 
           << "m_score: " << student->m_score << "\n";
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo1.exe
  m_age: 10
  m_score: 100
  ```

- 总结：

  - 子类指针指向父类的对象，子类指针指向的成员变量，可能会超出父类对象内存范围内的成员变量，`不安全`
  - 因为可能会覆盖掉，别的子类对象内存范围内的成员变量的值





- 代码示例3：通过反汇编查看强制类型转换

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      void speak(){cout << "Animal::speak()" << endl;}
      void run(){cout << "Animal::run()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  class Cat : public Animal
  {
  public:
      void speak(){cout << "Cat::speak()" << endl;}
      void run(){cout << "Cat::run()" << endl;}
  };
  
  int main()
  {
  	Cat *animal = (Cat *)new Dog;
      animal->speak();
      animal->run();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo1.exe
  Cat::speak()
  Cat::run()
  ```

- 查看反汇编结果：

  ```assembly
  // Cat *animal = (Cat *)new Dog;
  mov dword ptr[ebp-0DCh], 0
  mov ecx, dword ptr[ebp-0DCh]
  mov dword ptr[animal], ecx
  
  // animal->speak();
  mov ecx, dword ptr[animal]
  call Cat::speak(0F714F6h)
  
  // animal->run();
  mov ecx, dword ptr[animal]
  call Cat::run(0F714F1h)
  ```

- 总结：

  - 由上面的`示例3`可知：指针的类型决定了，指针所能访问的内存范围
  - 此时还未实现`多态`







#### 11.2 虚函数实现多态



- 通过虚函数`(virtual function)`实现多态
- 虚函数：被`virtual`修饰的成员函数
- 在`父类`中声明为`虚函数`，子类中`重写`的成员函数会自动`转成虚函数`



-  代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      virtual void speak(){cout << "Animal::speak()" << endl;}
      virtual void run(){cout << "Animal::run()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  class Cat : public Animal
  {
  public:
      void speak(){cout << "Cat::speak()" << endl;}
      void run(){cout << "Cat::run()" << endl;}
  };
  
  void playAnimal(Animal *animal)
  {
      animal->speak();
      animal->run();
  }
  
  int main()
  {
      playAnimal(new Dog);
      playAnimal(new Cat);
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo2.exe
  Dog::speak()
  Dog::run()
  Cat::speak()
  Cat::run()
  ```





#### 11.3 虚表



- 虚函数的实现原理是`虚表`，这个虚表里存储着最终需要调用的`虚函数地址`，这个虚表也叫虚函数表





##### 11.3.1 虚表的大小



- 前提：
  - 类中的普通函数，在对象中不占用空间，因为函数存在代码区中，而对象在栈区中，只有成员变量占用空间
  - 父类的虚函数，在子类重写后，这些函数会存入一个虚函数表中，虚函数表占用子类对象的内存空间
  - x86环境，指针是4字节
  - x64环境，指针是8字节



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      int m_age;
      virtual void speak(){cout << "Animal::speak()" << endl;}
      virtual void run(){cout << "Animal::run()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      int m_height;
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  class Cat
  { 
  public:
      int m_health;
      void speak(){cout << "Cat::speak()" << endl;}
      void run(){cout << "Cat::run()" << endl;}
  };
  
  int main()
  {
      cout << "Cat::sizeof()= " << sizeof(Cat) << endl;
      cout << "Dog::sizeof()= " << sizeof(Dog) << endl;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo3.exe
  Cat::sizeof()= 4
  Dog::sizeof()= 16
  ```

- 结果分析：

  - Dog对象，继承了父类Animal，对象类有`两个int类型`成员变量：`8字节`
  - 父类还`有虚函数`的存在，所以需要在Dog对象内`创建虚函数表`：`x86是4字节`，`x64是8字节`
  - Dog对象重写的父类的方法，存在代码区中，不和对象一起在栈区中，所以不占用对象内存





##### 11.3.2 反汇编分析虚表



- x86环境中，内存的布局

- 代码示例：

  ```c++
  int main()
  {
      Animal *animal = new Dog();
      animal->m_age = 20;
      return 0;
  }
  ```

  |             | 内存地址     | 内存数据                     | 内存地址     | 内存数据                               |
  | ----------- | ------------ | ---------------------------- | ------------ | -------------------------------------- |
  | `dog`       | `0x00E69B60` | `0x00B89B64`==`虚表内存地址` | `0x00B89B64` | `0x00B814E7`==`Dog::speak()的调用地址` |
  |             | 0x00E69B61   |                              | 0x00B89B65   |                                        |
  |             | 0x00E69B62   |                              | 0x00B89B66   |                                        |
  |             | 0x00E69B63   |                              | 0x00B89B67   |                                        |
  | `&m_age`    | `0x00E69B64` | `20`                         | `0x00B89B68` | `0x00B814CE`==`Dog::run()的调用地址`   |
  |             | 0x00E69B65   |                              | 0x00B89B69   |                                        |
  |             | 0x00E69B66   |                              | 0x00B89B6A   |                                        |
  |             | 0x00E69B67   |                              | 0x00B89B6B   |                                        |
  | `&m_height` | `0x00E69B68` | `0`                          |              |                                        |
  |             | 0x00E69B69   |                              |              |                                        |
  |             | 0x00E69B6A   |                              |              |                                        |
  |             | 0x00E69B6B   |                              |              |                                        |

- 总结：

  - 可以看到，`父类`中有`虚函数`，`子类对象`从`首地址开始`，`存放虚函数表`
  - `虚函数表`内`存放着内存地址`，而这个内存地址`指向`的是`代码区的地址`，也正是子类对象内重写父类方法的地址
  - 所以实现多态后，父类指针指向子类对象时，可以`通过虚函数表`，使得`指针调用子类`的方法，以达到多态的目的





- 反汇编查看：

- 代码示例：

  ```c++
  int main()
  {
      Animal *animal = new Dog();
      animal->m_age = 20;
      animal->speak();
      return 0;
  }
  ```

  ```assembly
  // animal->m_age = 20;
  mov eax, dword ptr[animal] // animal == ebp-8 是指针变量，eax 是Dog对象的地址，里面存放着虚表的地址值
  mov dword ptr[eax+4], 14h
  
  // animal->speak();
  mov eax, dword ptr[animal]
  mov edx, dword ptr[eax] // 从Dog对象的地址开始往后4个字节内的数据存入到 寄存器edx 中，edx 得到 虚表的地址
  
  mov esi, esp
  mov ecx, dword ptr[animal]
  mov eax, dword ptr[edx] // 从 edx 中取4个字节，eax 得到虚表中存放 Dog对象方法的地址，(但不是方法的真正地址，需要jump到真正地址)
  
  call eax // 调用 Dog对象的方法
  ```

  





##### 11.3.3 虚表的设计思想



- 前提：项目中实现了多态，其父类指针多次指向不同的子类对象，且父类的方法用`virtual修饰`
- 原理：
  - 编译器在`编译时`，并`不知道`，项目中父类指针多次指向不同的子类对象
  - 即便`父类指针`指向的对象是`自己本身`的对象，也`一样生成`用于`存放虚表地址`的`内存空间`
  - `编译文件`是`静态`的，而程序在内存中`执行`是`动态`过程
- 目的：
  - 多态中，每个`子对象`都要有一个`虚函数表`
  - 实现程序在内存中`执行`的`动态性`
- 虚表的相关优化：
  - 当父类指针多次指向`多个`子类对象，且都是`同一个类`的对象
  - 此时，这些对象依然有`各自独立`存放`虚表地址`的内存空间
  - 这些子类对象的`前4字节`空间中存放的`虚表地址值`(对象的方法所在代码区的地址)是`相等`的
- 总结：相同类的对象，不管在什么区中，共用一份虚表





##### 11.3.4 多态实现的需求



- 实现需求：大致两种
  1. 完全重写父类的成员函数
  2. 在父类的成员函数基础上，利用多态附加子类对象的成员函数



- 代码示例1：第一种`(完全重写)`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      // 子类会完全重写的虚函数是 可以 为空实现
      virtual void speak(){cout << "Animal" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
  };
  
  int main()
  {
      Animal *animal = new Dog;
      animal->speak();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo4.exe
  Dog::speak()
  ```



- 代码示例2：第二种`(父类的方法实现基础上附加子类的实现)`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      // 父类的方法实现基础上附加子类的实现，此处的父类虚函数实现 可以 不为空实现
      virtual void speak(){cout << "Animal" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak()
      {
          Animal::speak();
          cout << "Dog::speak()" << endl;
      }
  };
  
  int main()
  {
      Animal *animal = new Dog;
      animal->speak();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo4.exe
  Animal
  Dog::speak()
  ```








#### 11.4 虚析构函数



- 父类指针指向子类对象，含有虚函数的父类，应该将析构函数声明为虚函数(虚析构函数)
- `delete`父类指针，才会调用子类的析构函数，保证析构的完整型



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      Animal(){cout << "Animal::Animal()" << endl;}
      virtual ~Animal(){cout << "Animal::~Animal()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      Dog(){cout << "Dog::Dog()" << endl;}
      ~Dog(){cout << "Dog::~Dog()" << endl;}
  };
  
  int main()
  {
      Animal *animal = new Dog;
      delete animal;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo5.exe
  Animal::Animal()
  Dog::Dog()
  Dog::~Dog()
  Animal::~Animal()
  ```

- 补充：

  - 先构造父类，再构造子类
  - 先析构子类，再析构父类
  - 父类构造可以不用`virtual`修饰







#### 11.5 纯虚函数



- 定义：没有函数体其初始化为0的虚函数，用来定义接口规范

- 抽象类（`Abstract Class`）
  - 含有纯虚函数的类，不可以实例化（`不可以创建对象`）
  - 抽象类也可以是包含非纯虚函数，成员变量
  - 如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      int m_age;
      virtual void speak() = 0;
      virtual void run() = 0;
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  int main()
  {
      Animal *animal = new Dog();
      cout << animal->m_age << endl;
      animal->run();
      animal->speak();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo1.exe
  0
  Dog::run()
  Dog::speak()
  ```







#### 11.6 多继承



##### 11.6.1 多继承概念

- C++允许一个类，继承多个类（`不建议使用`）
- 如果子类继承的`多个父类`都有虚函数，那么子类对象会产生对应的`多张虚函数表`



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Student
  {
  public:
      int m_score;
  };
  
  class Worker
  {
  public:
      int m_salary;
  };
  
  class Undergraduate : public Student, public Worker
  {
  public:
      int m_grade;
  };
  
  
  int main()
  {
      Undergraduate under;
      cout << "sizeof: " << sizeof(under) << endl;
      under.m_score = 100;
      under.m_salary = 2000;
      under.m_grade = 4;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo2.exe
  sizeof: 12
  ```



- 内存布局：

  |          |             | 内存地址     | 内存数据 |
  | -------- | ----------- | ------------ | -------- |
  | `&under` | `&m_score`  | `0x00E69B60` | 100      |
  |          |             | 0x00E69B61   |          |
  |          |             | 0x00E69B62   |          |
  |          |             | 0x00E69B63   |          |
  |          | `&m_salary` | `0x00E69B64` | 2000     |
  |          |             | 0x00E69B65   |          |
  |          |             | 0x00E69B66   |          |
  |          |             | 0x00E69B67   |          |
  |          | `&m_grade`  | `0x00E69B68` | 4        |
  |          |             | 0x00E69B69   |          |
  |          |             | 0x00E69B6A   |          |
  |          |             | 0x00E69B6B   |          |







##### 11.6.2 同名成员函数/变量



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal_A
  {
  public:
      int m_age;
      void run(){cout << "Animal_A::run()" << endl;}
  };
  
  class Animal_B
  {
  public:
      int m_age;
      void run(){cout << "Animal_B::run()" << endl;}
  };
  
  class Dog : public Animal_A, public Animal_B
  {
  public:
      int m_age;
      void run(){cout << "Dog::run()" << endl;}
  };
  
  int main()
  {
      Dog dog;
  
      dog.m_age = 10;
      dog.Animal_A::m_age = 11;
      dog.Animal_B::m_age = 12;
      dog.Dog::m_age = 13;
      
      dog.run();
      dog.Animal_A::run();
      dog.Animal_B::run();
      dog.Dog::run();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo3.exe
  Dog::run()
  Animal_A::run()
  Animal_B::run()
  Dog::run()
  ```





##### 11.6.3 菱形继承



###### 11.6.3.1 菱形继承结构

- 基本结构：
  - 定义一个类：A
  - 定义类B1，继承A；定义类B2，继承A
  - 定义类C，继承B1，B2



- 菱形继承的问题：
  - 最底层的对象，从基类继承的成员变量冗余，重复
  - 最底层的对象，无法访问基类的成员变量，存在二义性



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class A
  {
      int a;
  };
  
  class B1 : A // 继承A的成员变量，2*int = 8字节
  {
      int b1;
  };
  
  class B2 : A // 同理，2*int = 8字节
  {
      int b2;
  };
  
  class C : B1, B2 // 继承B1，B2，加上自身成员变量，2+2+1 int = 20字节
  {
      int c;
  };
  
  int main()
  {
      C c;
      cout << "sizeof: " << sizeof(c) << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo4.exe
  sizeof: 20
  ```







###### 11.6.3.2 虚继承



- 解决菱形继承带来的底层对象的成员变量冗余，重复和二义性



- 基本结构：
  - 定义一个类：A
  - 定义类B1，继承 `virtual A`；定义类B2，继承 `virtual A`
  - 定义类C，继承B1，B2
- 此时，A为 `虚基类`
- 作用：B1，B2会共同继承同一份 A 的成员，而不是各自继承一份，解决了底层对象的成员冗余



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  struct A
  {
      int a;
  };
  
  struct B1 : virtual A // 虚表8字节，成员变量4字节，12
  {
      int b1;
  };
  
  struct B2 : virtual A // 虚表8字节，成员变量4字节，12
  {
      int b2;
  };
  
  struct C : B1, B2 // 2*12 = 24，虚表8字节，成员变量4字节，虚基类成员变量4字节 = 24 + 8 + 4 + 4 = 40
  {
      int c;
  };
  
  int main()
  {
      C c;
      cout << "sizeof: " << sizeof(c) << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo4.exe
  sizeof: 40
  ```

- 虚继承的类结构：

  - 首地址存放虚指针和偏移量
  - 存放自己的成员变量
  - 存放虚基类的成员变量









### 12. 静态成员





#### 12.1 静态成员基本定义



- 定义：`static`修饰的成员变量/函数
  - 可以通过`对象.静态成员`，`对象指针->静态成员`，`类名::静态成员变量`，进行访问
- 静态成员变量：
  - 存储在数据段（`全局区，类似全局变量`），整个程序运行过程中只有一份内存
  - 对比全局变量，它可以设定访问权限（`public`, `protected`, `private`），达到局部共享的目的
  - 必须初始化，必须在类外面初始化，初始化不能带`static`，如果类的声明和实现分离（`在实现中初始化`）
- 静态成员函数：
  - 内部不能使用`this`指针（`this`指针只能用于非静态成员函数内部）
  - 不能是虚函数（`虚函数只能是非静态成员函数`）
  - 内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数
  - 构造函数和析构函数不可以是静态的
  - 当声明和实现分离，实现不能带`static`
- 总结：
  - 涉及到，通过`对象`来管理，调用成员的变量和函数，都不可以用`static`修饰
  - `static`修饰的成员变量/函数只能通过类，利用作用域使用，或者在静态的函数内使用静态成员变量



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      
      static int m_price;
  
      static void byCar();
  };
  
  int Car::m_price = 1000;
  
  void Car::byCar()
  {
      cout << "Car is running" << endl;
  }
  
  int main()
  {
      cout << "Car price: " << Car::m_price << endl;
      Car::byCar();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo6> .\demo1.exe
  Car price: 1000
  Car is running
  ```







#### 12.2 反汇编分析静态成员



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      int m_age;
      static int m_price;
  };
  
  int Car::m_price = 0;
  
  int g_age;
  
  int main()
  {
      Car car1;
      Car car2;
      
      g_age = 0;
      car1.m_age = 1;
      car1.m_price = 2;
      car2.m_price = 3;
          
      return 0;
  }
  ```

- 反汇编分析，静态成员变量

  ```assembly
  // g_age = 0;
  mov dword ptr ds:[00A9A318h], 0	=> ds 数据段
  
  // car1.m_age = 1;
  mov dword ptr[car], 1	=> mov dword ptr[ebp-8], 1
  
  // car1.m_price = 2;
  mov dword ptr[Car::m_price 00A9A314h)], 2	=> mov dword ptr ds:[00A9A314h], 2
  
  // car2.m_price = 3;
  mov dword ptr[Car::m_price (00A9A314h)], 3	=> mov dword ptr ds:[00A9A314h], 3
  ```

- 总结：

  - 全局变量和类中的静态变量，都存放在数据区内，且程序运行时，仅有一份
  - 静态变量和全局变量的区别：
    - 静态变量可以在类中定义，同时通过`public`, `protected`, `private`修饰其访问权限





#### 12.3 静态成员应用



##### 12.3.1 统计对象个数

- 应用：无论在那个区域增加或删除对象，都能有一个唯一值去统计当前的对象个数

- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  private:
      static int ms_count;
  
  public:
      Car(){++ms_count;}
      ~Car(){--ms_count;}
  
      static int getCount(){return ms_count;}
  };
  int Car::ms_count = 0;
  
  Car g_car; // 1
  
  int main()
  {
      Car car; // 2
      Car *p_car = new Car; // 3
  
      cout << Car::getCount() << endl;
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo6> .\demo2.exe
  3
  ```





##### 12.3.2 单例模式



- 单例模式的构建：
  - 构造/析构函数，私有化
  - 定义一个私有化的 static成员变量指向唯一得到单例对象
  - 提供一个公共的访问单例对象的接口



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Rocket
  {
  private:
      // 构造/析构函数，私有化
      Rocket(){}
      ~Rocket(){}
  
      // 定义一个私有化的 static成员变量指向唯一得到单例对象
      static Rocket* ms_rocket;
  
  public:
      // 提供一个公共的访问单例对象的接口
      static Rocket* sharedRocket()
      {
          // 需要考虑多线程安全
          if (ms_rocket == NULL)
          {
              ms_rocket = new Rocket();
          }
          return ms_rocket;
      }
  
      // 提供一个公共的访问单例对象的接口
      static void deleteRocket()
      {
          // 需要考虑多线程安全
          if (ms_rocket != NULL)
          {
              ms_rocket = NULL;
              delete ms_rocket;
          }
      }
  
      // 测试用函数
      void startRocket(){cout << "Start Rocket" << endl;}    
  };
  Rocket* Rocket::ms_rocket = NULL;
  
  int main()
  {
      Rocket *p_rocket_1 = Rocket::sharedRocket();
      Rocket *p_rocket_2 = Rocket::sharedRocket();
      Rocket *p_rocket_3 = Rocket::sharedRocket();
  
      cout << p_rocket_1 << "\n" << p_rocket_2 << "\n" << p_rocket_3 << endl;
      p_rocket_1->startRocket();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo6> .\demo3.exe
  0x8e6b80
  0x8e6b80
  0x8e6b80
  Start Rocket
  ```

- 总结：由打印结果可看出，指向堆区的对象指针的地址始终不变，对象的单例模型已经实现



- 补充：delete
  - `new`是堆空间，开辟一块区域，用来存放数据
  - `delete`是删除堆空间开辟的区域，使得这片区域`可以被别的new使用`，但里面的数据`没有变化`，
  - 需要在delete之前或之后，使其初始化为`null`









### 13. const成员



- 被`const修饰`的`成员`变量、`非静态`成员`函数`



- `const`成员变量：
  - `必须`在`类内部初始化`，可以在声明时，直接赋值
  - `非static`的`const成员变量`还可以在初始化列表中初始化



- `const`成员函数：
  - `const`关键字写在参数列表后面，函数的声明和实现都要写`const`
    - 内部不能修改`非static`成员变量
    - 内部只能调用`const修饰`的成员函数，`static`成员函数
    - `非const`成员函数可以调用`const`成员函数
  - `const`成员函数和`非const`成员函数`构成重载`
    - `非const`对象（`指针`）优先调用`非const`成员函数
  - `const`对象（`指针`）只能调用`const`成员函数，`static`成员函数







### 14. 引用类型成员



- 引用类型成员变量必须初始化（不考虑static）
  - 在声明的时候直接初始化
  - 通过初始化列表初始化







### 15. 拷贝构造函数



- 拷贝构造函数是构造函数的一种
- 当利用已经存在的对象创建一个新对象时（类似于拷贝），就会调用对象的拷贝构造函数进行初始化
- 拷贝构造函数的格式是固定的，接收一个`const`修饰的`引用类型`参数





#### 15.1 默认拷贝构造函数



- 代码示例：(默认拷贝构造函数)

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      int m_length;
  
  public:
      Car(int price = 0, int lenght = 0) : m_price(price), m_length(lenght){cout << "Car::Car()" << endl;}    
  
      void display(){cout << "price:" << m_price << " length: " << m_length << endl;}
  };
  
  int main()
  {
      Car car1(1, 1);
      car1.display();
  
      Car car2(car1);
      car2.display();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo1.exe
  Car::Car()
  price:1 length: 1
  price:1 length: 1
  ```

- 反汇编查看原理：（默认构造函数）

  ```assembly
  // x86环境
  // Car car2(car1);
  mov eax, dword ptr[ebp-10h] => 10h = 16
  mov dword ptr[ebp-20h], eax => 20h = 32
  // => car2.m_prcie = car1.m_price;
  
  mov ecx, dword ptr[ebp-0Ch] => 0Ch = 12
  mov dword ptr[ebo-1Ch], ecx => 1Ch = 28
  // => car2.m_length = car1.m_length;
  
  // car2.display();
  lea ecx, [ebp-20h]
  call 0024141A
  
  
  // x64环境
  // Car car2(car1);
  mov rax, qword ptr[rbp+8] => 8h = 8
  mov qword ptr[rbp+28h], rax => 28h = 40
  
  // car2.display();
  lea rcx, [rbp+28h]
  call 00007FF685AF12FD
  ```







#### 15.2 自定义拷贝构造函数



- 代码示例：（自定义拷贝构造函数）

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      int m_length;
  
  public:
      Car(int price = 0, int lenght = 0) : m_price(price), m_length(lenght){cout << "Car::Car()" << endl;}    
      Car(const Car &car) : m_price(car.m_price), m_length(car.m_length){cout << "Car::Car(const)" << endl;}
  
      void display(){cout << "price:" << m_price << " length: " << m_length << endl;}
  };
  
  int main()
  {
      Car car1(1, 1);
      car1.display();
  
      Car car2(car1);
      car2.display();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo1.exe
  Car::Car()
  price:1 length: 1
  Car::Car(const)
  price:1 length: 1
  ```







#### 15.3 调用父类拷贝构造函数



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:
      int m_age;
  
      Person(int age) : m_age(age){};
      Person(const Person &person) : m_age(person.m_age){}
  };
  
  class Student : public Person
  {
  public:
      int m_score;
      
      Student(int age, int score) : Person(age), m_score(score){}       
      Student(const Student &student) : Person(student), m_score(student.m_score){}
  };
  
  int main()
  {
      Student stu1(1, 100);
      Student stu2(stu1);
  
      cout << stu2.m_age << " " << stu2.m_score << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo2.exe
  1 100
  ```

- 补充：如果是完全拷贝对象内的数据，可以直接使用默认拷贝构造函数





#### 15.4 浅复制



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Student
  {
  public:
      int m_score;
      
      Student(int score = 0) : m_score(score){cout << "Student::Student()" << endl;}       
      Student(const Student &student) : m_score(student.m_score){cout << "Student::Student(const Student &student)" << endl;}
  };
  
  int main()
  {
      // 默认构造
      Student s1(10);
      
      // 拷贝构造
      Student s2(s1);
      // 拷贝构造 => 创建对象的同时，将 s2 的数据给 s3，符合拷贝构造
      Student s3 = s2;
      
      // 浅复制 => 创建了对象，但没有利用已经存在的对象进赋值，所以是 默认构造
      Student s4;
      s4 = s3; // 此时的两个对象都是 已经存在的对象，不是拷贝g
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo3.exe
  Student::Student()
  Student::Student(const Student &student)
  Student::Student(const Student &student)
  Student::Student()
  ```








#### 15.5 浅/深拷贝





##### 15.5.1 解决浅拷贝问题



- 编译器默认的都是浅拷贝
- 浅拷贝的缺点：
  - 如果出现堆空间指向栈空间，那么浅拷贝后，堆空间内存储着栈空间的地址
  - 栈空间的生命周期是不可控制的，可能会使得堆空间指向栈空间的指针变成野指针



- 代码示例：解决浅拷贝的问题

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      char *m_name;
  
  public:
      Car(int price = 0, const char *name = nullptr) : m_price(price)
      {
          if (name == nullptr){return;}
  
          m_name = new char[strlen(name) + 1]{};
          strcpy(m_name, name);
      }    
      ~Car()
      {
          if (m_name == nullptr){return;}
          m_name = nullptr;
          delete[] m_name;
      }
  
      void printInfo(){cout << m_price << " " << m_name << endl;}
  };
  
  int main()
  {
      char name[] = {'b', 'w', 'm', '\0'};
      Car *car = new Car(100, name);
      car->printInfo();
  
      Car *car2 = new Car(200, "bwm");
      car2->printInfo();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo4.exe
  100 bwm
  200 bwm
  ```







##### 15.5.2 深拷贝



- 使用深拷贝的原因：
  - 当类中有数据会在堆空间中开辟，且在类的对象析构时释放时
  - 此时这个类已有一个对象，而新的对象利用已有的对象进行默认的拷贝构造（浅拷贝）
  - 此时，两个对象的某一个指向堆空间的成员变量，所指的地址相同
  - 当其中一个对象释放，另一个对象中的某个指向堆空间的成员变量也会被释放，使得另一个对象中的成员变量无效化
  - 如果两个对象都释放，则会出现同一个堆空间，两次释放
- 深拷贝定义：
  - 将指针指向的内容拷贝到新的存储空间



- 代码示例：

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      char *m_name;
      void copy(const char *name = nullptr)
      {
          if (name == nullptr){return;}
  
          m_name = new char[strlen(name) + 1]{};
          strcpy(m_name, name);
      }
  
  public:
      Car(int price = 0, const char *name = nullptr) : m_price(price){copy(name);}    
      Car(const Car &car) : m_price(car.m_price){copy(car.m_name);}
      ~Car()
      {
          if (m_name == nullptr){return;}
          m_name = nullptr;
          delete[] m_name;
      }
  
      void printInfo(){cout << m_price << " " << m_name << endl;}
  };
  
  int main()
  {
      Car car1(100, "bwm");
      Car car2 = car1;
      car2.printInfo();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo5.exe
  100 bwm
  ```

  







### 16. 对象类型参数和返回值



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      Car(){cout << "Car::Car() "<< this << endl;}    
      Car(const Car &car){cout << "Car::Car(const) " << this << endl;}
  };
  
  void test1(Car car){}
  
  Car test2()
  {
      Car car;
      return car;
  }
  
  int main()
  {
      Car car;
      test1(car);
  
      cout << endl;
  
      Car car1;
      car1 = test2();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo6.exe
  Car::Car() 0x7bfe1d
  Car::Car(const) 0x7bfe1e
  
  Car::Car() 0x7bfe1c
  Car::Car() 0x7bfe1f
  ```

  
