# C++_面向对象反汇编补充



### 1. 类



#### 1.1 类的定义

- C++中可以使用 `struct`，`class`来定义类



#### 1.2 struct和class区别



- `struct`默认成员权限是`public`
- `class`默认成员权限是`private`



##### 1.2.1 定义和访问



- 代码示例：

  ```c++
  struct Person
  {
      int m_Age;
      
      void run()
      {
          cout << "m_Age: " << m_Age << endl;
      }
  };
  
  class Person
  {
  public:    
      int m_Age;
      
      void run()
      {
          cout << "m_Age: " << m_Age << endl;
      }
  };
  
  Person person;
  // 通过对象访问
  person.m_Age = 20;
  person.run();
  
  // 通过指针访问
  Person *ptr_Person = &person;
  ptr_Person ->m_Age = 20;
  ptr_Person ->run();
  ```

- `对象person` 和 `指针ptr_Person`的内存都是在函数的栈空间中，自动分配和回收

- `对象person`只有一个`int类型`的成员变量，所以是`4字节`

- `指针ptr_Person`在 `32位`占用`4字节`，`64位`占用`8字节`







##### 1.2.2 反汇编查看区别



- 代码示例1：

  ```c++
  class Car
  {
  public:
      int m_price;
      
      void run()
      {
          cout << "Car::run() " << m_price << endl;
      }
  };
  
  int main()
  {
      Car car1;
      car1.m_price = 10;
      car1.run();
      
      Car car2;
      car2.m_price = 20;
      car2.run();
      
      return 0;
  }
  ```

  ```assembly
  // 查看核心部分汇编代码
  
  mov dword ptr[car1], 0Ah // 由此可得，对象占用4字节，成员变量占用4字节，所以第一个成员变量的内存地址就是对象的地址
  // Car car1;
  // car1.m_price = 10;
  
  lea ecx, [car1]
  call 0086141A // 此处 call run()
  // car1.run();
      
  mov dword ptr[car2], 14h
  // Car car2;
  
  lea ecx, [car2]
  call 0086141A // 此处 call run()
  // car2.m_price = 20;
  // car2.run();
  
  // 由上可以等到，两个对象 car1 和 car2 的成员变量是不同的
  // 但它们调用的函数的地址是同一个
  ```

- 对象内的函数不占用对象的内存大小：

  - 类中的函数在编译阶段，会将函数的地址存放到单独的一段内存中
  - 当两个函数完全相同时，会去重，仅保留一个函数地址
  - 一个类生成的多个对象中，只有成员变量是每个对象各自拥有的，而成员方法则是统一去重存储在`方法列表`中

- 补充：

  - 无论函数和变量存在于什么地方，如果没有在其它地方使用或调用
  - 该函数和变量，在编译阶段会被优化，也就是根本不存在







#### 1.3 对象的内存布局



- 代码示例：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      person.m_id = 100;
      
      cout << "&person = " << &person << endl;
      cout << "&person.m_age = " << &person.m_age << endl;
      cout << "&person.m_id = " << &person.m_id << endl;
      return 0;
  }
  ```

- 运行结果：

  ```powershell
  &person = 0x7bfe18
  &person.m_age = 0x7bfe18   
  &person.m_id = 0x7bfe1c  
  ```








### 2. this



- 隐式参数
- 存储着函数调用者的地址



- 代码示例1：

  ```c++
  struct Person
  {
    int m_age;
    
    void run()
    {
      // 编译器会隐式传参
      // this = &person1
        this->m_age = 3;
    }
  };
  
  int main()
  {
      Person person1;
      person1.m_age = 10;
      person1.run();
      
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  // ebp-8 是 this 的地址
  // eax 是 person1 的地址
  
  // Person person1;
  // person1.m_age = 10;
  mov dword ptr [ebp-0Ch], 0Ah
  
  // person.run();
  lea ecx, [ebp-0Ch]
  call 00181366
  	mov dword ptr [ebp-8], ecx
  	
  	// this->m_age = 3;
  	mov eax. dword ptr [ebp-8]
  	mov dword ptr [eax], 3
  ```





- 代码示例2：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
    
    void run(){}
  };
  
  int main()
  {
      Person person1;
      person1.m_age = 10;
      person1.m_id = 20;
      person1.run();
  	
      Person *person2 = &person1;
      person2->m_age = 10;
      person2->m_id = 10;
      person2->run();
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  // Person person1;
  // person1.m_age = 10;
  mov dword ptr [ebp-14h], 0Ah
  
  // person1.m_id = 20;
  mov dword ptr [ebp-10h], 14h
  
  // person1.run();
  lea ecx, [ebp-14h]
  call 00FA141F
  	
  // Person *person2 = &person1;
  lea eax, [ebp-14h] // [ebp-14h]是person1的地址
  mov dword ptr [ebp-20h], eax // [ebp-20h]是指针变量person2的地址
  
  // person2->m_age = 10;
  mov eax, dword ptr [ebp-20h] // eax存储的是person1的地址值
  mov dword ptr [eax], 0Ah 
  
  // person2->m_id = 10;
  mov eax, dword ptr [ebp-20h]
  mov dword ptr [eax+4], 0Ah 
  
  // person2->run();
  mov ecx, dword ptr [ebp-20h] // 将person1地址隐式传给this
  call 003B141F
  ```



- 代码示例3：

  ```c++
  struct Person
  {
    int m_age;
    int m_id;
    int m_height;  
    
    void run()
    {
        cout << m_age << "+" << m_id << "+" << m_height << endl;
    }
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      person.m_id = 20;
      person.m_height = 30;
  	
      Person *p = (Person *) &person.m_age;
      p->m_age = 0;
      p->m_id = 0;
      
      // 注意：这里用的 person，不是 p
      person.run();
      return 0;
  }
  
  # 打印结果：
  # 10+0+0
  ```

- 反汇编分析：

  ```assembly
  // Person *p = (Person *) &person.m_id;
  // eax == &person.m_id == person+4
  
  // p->m_age = 0;
  mov eax, dword ptr [p]
  mov dword ptr [eax + 0], 0h
  
  // p->m_id = 0;
  mov eax, dword ptr [p]
  mov dword ptr [eax + 4], 0h
  
  // 在栈空间中>> &person == &person.m_age
  // 改程序中 eax 的存储的地址是 &person.m_id == &person+4
  // 所以>> 
  // p->m_age = 0; 修改的是 m_id
  // p->m_id = 0; 修改的是 m_height
  ```

- 思考：

  ```c++
  Person *p = (Person *) &person.m_age;
  p->m_age = 0;
  p->m_id = 0;
  
  // person 对象的地址传递给 run 的this
  person.run();
  // 改为
  // 将指针 p 里存储的地址值传给 run 的this == &person.m_id 传递给 this
  p->run();
  
  # 打印结果
  # 40+50+-858993460
  # -858993460 == Oxcccccccc
  ```

- 补充：

- 上面的程序打印结果：`Oxcccccccc`

- 由来：函数调用是，开辟栈空间，调用结束，用`cccccccc`来填充内存空间

- 原因：

  - `cc`的汇编是`int3`：断点
  - `int`是`硬件中断`

- 作用：防止`指针`或`jump`之类的指令，指向错误的内存地址，可能造成系统安全问题，所以用硬件中断指令填充被释放的栈空间

  ```assembly
  // p->run();
  // 汇编中有一条指令
  mov eax, 0cccccccch
  rep stos dword ptr es:[edi]
  ```

  



### 3. 内存空间的布局



- 每个应用都有自己独立的内存空间：
  - 代码区(代码段)：用于存放代码
  - 全局区(数据段)：用于存放全局变量等
  - 栈空间：
    - 每调用一个函数就会给它分配一个连续的栈空间，等函数调用完毕后会自动回收这段栈空间
    - 自动分配和回收
  - 堆空间：需要主动去申请和释放



#### 3.1 代码区



- 只读
- 存放CPU指令(机器码)



#### 3.2 全局区



- 程序结束，全局区的数据才会清空





#### 3.3 堆空间



- 在程序运行过程中，为了能自由控制内存的生命周期，大小，会经常使用堆空间的内存



##### 3.3.1 堆空间申请和释放



- 堆空间的申请和释放：(`C/C++语言 => malloc() / free()`)

  ```c++
  void demo()
  {
      // malloc(4) 申请4字节堆空间，返回 void *，强转成 int *
      int *p = (int *)malloc(4);
      // int * 占用4个字节，所以 10 赋值给4个字节空间
      *p = 10;
      // 释放 p 申请的所有空间
      free(p);
      
      char *p = (char *)malloc(4);
      // char * 占用1个字节空间，所以 10 赋值给 p地址的第一个字节，另外3个字节是空的
      *p = 10;
      *(p + 1) = 11;
      *(p + 2) = 12;
      *(p + 3) = 13;
      // 等价于
      p[0] = 10;
      p[1] = 11;
      p[2] = 12;
      p[3] = 13;
      
      free(p);
  }
  ```

- 分析上面代码的内存分布：

  ```c++
  int *p = (int *)malloc(4);
  *p = 10;
  
  // X86 -- 32bit ，int 指针占用 4 字节，64bit 占用 8字节
  // 栈空间
  # 地址：0x111
  # 占用：4字节
  # p = 0x999
  
  // 堆空间
  # 地址：0x999
  # 占用：4字节
  # 值：10
  ```





- 堆空间的申请和释放：(`C++语言-新 => new / delete`)

  ```c++
  void demo()
  {
      int *p = new int; // 等价于  int *p = (int *)malloc(4);
      *p = 10;
      
      // 释放
      delete p;
  }
  ```

- (`new[] / delete []`)

  ```c++
  void demo()
  {
      char *p = new char[4]; // 等价于  char *p = (char *)malloc(4);
      *p = 10;
      
      // 释放
      delete p; // 错误：此时 只会 释放地址p的第一个字节空间，后面3个字节没有释放
      delete[] p; // 正确：释放 p 申请的所有空间
  }
  ```



- 注意：
  - 申请堆空间成功后，会返回那一段空间的地址
  - 申请和释放必须是一一对应的，不然会造成内存泄露



##### 3.3.2 堆空间初始化



- 简单示例：(`memset == memory set`)

  ```c++
  int *p1 = (int *)malloc(sizeof(int)); // *p1 未初始化
  
  int *p2 = (int *)malloc(sizeof(int));
  memset(p2, 0, sizeof(int)); // *p2 的每个字节初始化为0
  ```



- 其它初始化方式：

  ```c++
  int *p = new int; // 未初始化
  int *p = new int(); // 每个字节初始化为0
  // mov __memset(0), eax
  
  int *p = new int(5); // 每个字节初始化为5
  
  int *p = new int[3]; // 数组三个元素未初始化
  int *p = new int[3](); // 数组三个元素初始化为0
  int *p = new int[3]{}; // 数组三个元素初始化为0
  int *p = new int[3]{5}; // 数组首元素初始化为5，其它元素初始化为0
  ```





###### 3.3.2.1 memset



- memset 函数将较大的数据结构(`对象，数组等等`)内存清零的比较快的方式



- 代码示例1：

  ```c++
  Person person;
  person.id = 1;
  person.age = 2;
  person.height = 3;
  
  memset(&person, 0, sizeof(person));
  ```



- 代码示例2：

  ```c++
  Person persons[] = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};
  memset(persons, 0, sizeof(persons));
  ```







#### 3.4 对象的内存



- 对象可以存在于3个地方
  1. 全局区(数据段)：全局变量
  2. 栈空间：函数里面的局部变量
  3. 堆空间：动态申请内存(malloc, new等)



- 代码示例：

  ```c++
  // 全局区
  Person person;
  
  int main()
  {
      // 栈空间
      Person person;
      
      // 堆空间
      Person *person = new Person;
      return 0;
  }
  ```







### 4. 构造函数



- 类的默认构造函数，无论其对象在什么地方创建，都会调用构造函数
- 但存在特殊情况，在堆中创建对象，构造函数不会调用
- 通过`malloc()`，不会调用构造函数



- 代码示例：

  ```c++
  Person *person = (Person *)malloc(sizeof(Person));
  free(person);
  // malloc 不会调用构造函数
  
  Person *person = new Person;
  delete person;
  // 这个 new 会调用构造函数
  ```



#### 4.1 构造函数的错误概念



- 错误概念：当类内`没有自己定义`构造函数，编译器会默认添加一个`空实现的，无参的，默认构造函数`
- 正确理解：在特定情况下，编译器才会为类生成`空的无参构造函数`
- 具体情况：后面的`虚函数`会总结



- 代码示例：(`定义了构造函数`)

  ```c++
  class Person
  {
      int m_age;
      
      Person(){}
  };
  
  int main()
  {
      Person person;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  lea ecx, [person]
  call Person::Person (0A914BFh)
  // 定义了构造函数时，对象创建会调用构造函数
  ```



- 代码示例：(`没定义构造函数`)

  ```c++
  class Person
  {
      int m_age;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  # person.m_age = 10;
  mov dword ptr[person], 0Ah
  // 类没有定义构造函数时，编译时也不会创建所谓的：空实现的，无参的，默认构造函数
  ```



- 代码示例：(`没定义构造函数，但类中静态初始化了成员变量`)

  ```c++
  class Person
  {
      int m_age = 0;
  };
  
  int main()
  {
      Person person;
      person.m_age = 10;
      return 0;
  }
  ```

- 反汇编分析：

  ```assembly
  # Person person;
  lea ecx, [person]
  call Person::Person (0314C4h)
  # person.m_age = 10;
  mov dword ptr[person], 0Ah
  
  // 没定义构造函数，但类中静态初始化了成员变量，此时编译器会创建：空实现的，无参的，默认构造函数
  ```





#### 4.2 构造函数的调用



- 通过多种创建对象的方式，判读是否调用了类的构造函数



- 代码示例：

  ```c++
  class Person
  {
  public:
      int m_age;
  
      Person()
      {
          m_age = 0;
          cout << "Person()" << endl;
      }
  
      Person(int age)
      {
          m_age = age;
          cout << "Person(int)" << endl;
      }
  };
  
  Person g_person0; // Person()
  Person g_person1(); // 这是 g_person1() 函数的声明或定义，不会调用构造函数
  Person g_person2(10); // Person(int)
  
  int main()
  {
      Person person0; // Person()
      Person person1(); // 这是 g_person1() 函数的声明或定义，不会调用构造函数
      Person person2(20); // Person(int)
  
      Person *p0 = new Person; // Person()
      Person *p1 = new Person(); // Person() ，这是在堆空间中创建对象
      Person *p2 = new Person(30); // Person(int)
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo1
  Person()
  Person(int)
  Person()
  Person(int)
  Person()
  Person()
  Person(int)
  ```





#### 4.3 构造函数的成员变量初始化



- 默认情况下，没有自定义构造函数时，只有全局区和堆区的对象创建，会初始化为0，其余栈空间不会初始化成员变量

- 如果自定义了构造函数，除了全局区，其它内存空间的成员变量默认都不会被初始化，需要手动初始化



- 代码示例1：`(无自定义构造函数)`

  ```c++
  class Person
  {
  public:    
      int m_age;
  };
  
  // 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0
  Person g_person;
  
  int main()
  {
      // 栈空间的对象直接被编译器优化了，不会初始化成员变量
      // Person person;
  
      // 没有初始化
      Person *p0 = new Person;
  
      // 初始化
      Person *p1 = new Person();
  
      cout << g_person.m_age << endl;
      cout << p0->m_age << endl;
      cout << p1->m_age << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo2
  0
  14184048
  0
  ```

- 得出结论：

  1. `全局区`内，内存值默认全是 `0`
  2. `堆空间`内，通过 `()` 申请的内存，默认初始化为 `0`
  3. `栈空间`内，默认初始化为 `cccccccc`





- 代码示例2：`(有自定义构造函数) -> 空实现`

  ```c++
  class Person
  {
  public:    
      int m_age;
      
      Person(){}
  };
  
  // 堆空间中的，无论是对象内的成员变量，还是普通的数据类型，都会默认初始化为 0
  Person g_person;
  
  int main()
  {
      // 没有初始化
      Person *p0 = new Person;
  
      // 没有初始化，初始化工作交给自定义构造函数，然而自定义构造函数是空实现，所以没有初始化
      Person *p1 = new Person();
  
      cout << g_person.m_age << endl;
      cout << p0->m_age << endl;
      cout << p1->m_age << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo2
  0
  14184048
  14184048
  ```





#### 4.4 构造函数的集体初始化



- 通过`memset()`方法实现



- 代码示例：

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  
  class Person
  {
  public:    
      int m_age;
  
      Person()
      {
          // memset() 方法，方便用于类成员变量集体初始化或清零
          memset(this, 0, sizeof(Person));
      }
  };
  
  int main()
  {
      Person *p1 = new Person();
  
      cout << p1->m_age << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo3
  0
  ```





### 5. 析构函数



- 又名`析构器`，在对象销毁时自动调用，一般用于完成对象的清理工作
- 没有返回值，不能重载
- 通过`malloc()`分配的对象，`free()`时，不会调用析构函数
- 类中的构造函数和析构函数，需要`public:`修饰后，才能被外界调用
- 全局区的对象，不会调用析构函数



#### 5.1 malloc与析构函数

- 代码示例1：

  ```c++
  class Person
  {
  public:    
      int m_age;
  
      Person()
      {
          cout << "Person()" << endl;
      }
      ~Person()
      {
          cout << "~Person()" << endl;
      }
  };
  
  int main()
  {
      // malloc 的 对象不会调用 构造函数 和 析构函数
      Person *p0 = (Person *)malloc(sizeof(Person));
      free(p0);
  
      Person *p1 = new Person();
      delete p1;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo4
  Person()
  ~Person()
  ```





#### 5.2 对象内申请的堆区对象



- 对象析构时，只会回收对象，如果对象的成员变量指向堆空间，需要手动释放，否则会造成`内存泄漏`
- 内存泄漏：该释放的内存，没有去释放



- 代码示例：

  ```c++
  class Car
  {
  public:
      int m_price;
  
      Car()
      {
          cout << "Car()" << endl;
      }   
      ~Car()
      {
          cout << "~Car()" << endl;
      } 
  };
  
  class Person
  {
  public:    
      int m_age;
      Car *m_car;
  
      Person()
      {
          // 此处的 m_car是在堆空间中声明，需要delete才能回收
          // 如果是栈空间声明，person在调用析构函数时，会先回收m_car
          m_car = new Car;
          cout << "Person()" << endl;
      }
      ~Person()
      {
          delete m_car;
          cout << "~Person()" << endl;
      }
  };
  
  int main()
  {
      Person person;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\demo> .\demo5
  Car()
  Person()
  ~Car()
  ~Person()
  ```







### 6. 声明和实现



- 类的定义和声明分离，分别在 `.h`和`.cpp`中实现



#### 6.1 具体演示



`Person.h`

```c++
class Person
{
private:
    int m_age;

public:
    Person();
    ~Person();

    void set_Age(int age);
    int get_Age();
};
```



`Person.cpp`

```c++
Person::Person()
{
    cout << "Person()" << endl;
}
Person::~Person()
{
    cout << "~Person()" << endl;
}

void Person::set_Age(int age)
{
    m_age = age;
}
int Person::get_Age()
{
    return m_age;
}
```



`main.cpp`

```c++
#include <iostream>
using namespace std;

int main()
{
    Person person;
    person.set_Age(10);
    int age = person.get_Age();

    cout << age << endl;

    return 0;
}
```



- 打印结果：

  ```c++
  PS C:\Users\Admin\Desktop\Project\Demo2> .\demo1.exe
  Person()
  10
  ~Person()
  ```







### 7. 命名空间



- 作用：
  - 解决重复命名的问题
  - 命名空间不影响内存布局和结构



#### 7.1 命名空间的基本用法



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  namespace fh1
  {
      class Person
      {
      private:
          int m_age;
  
      public:
          Person();
          ~Person();
      };
  }
  
  namespace fh2
  {
      class Person
      {
      private:
          int m_age;
  
      public:
          Person();
          ~Person();
      };
  }
  
  int main()
  {
      fh1::Person person1;
      fh2::Person person2;
      return 0;
  }
  ```





#### 7.2 命名空间的嵌套



- 命名空间可以一直嵌套



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  namespace fh1
  {
      namespace fh2
      {
          class Person
          {
          private:
              int m_age;
  
          public:
              Person();
              ~Person();
          };
      }
  }
  
  int main()
  {
      fh1::fh2::Person person;
      return 0;
  }
  ```

  





#### 7.3 存在最大默认命名空间



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  namespace fh
  {
      void func()
      {
          cout << "fh::func()" << endl;
      }
  }
  
  void func()
  {
      cout << "func()" << endl;
  }
  
  int main()
  {
      fh::func();
      // 通过默认的全局命名空间，访问 fh
      ::fh::func();
  
      func();
      
     	// 通过默认的全局命名空间，访问 func()
      ::func();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo2> .\demo4.exe
  fh::func()
  fh::func()
  func()
  func()
  ```








### 8. 继承



- 继承可以让子类拥有父类的所有成员





#### 8.1 继承的内存布局



- 子对象中的成员变量分布：最上层的父类的成员变量在子对象的首地址，依次向下排列



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:
      int height;    
  };
  
  class Student : public Person
  {
  public:
      int age;    
  };
  
  class My : public Student
  {
  public:
      int id;    
  };
  
  int main()
  {
      Person person;
      Student student;
      My my;
      my.height = 9;
      my.age = 10;
      my.id = 11;
  
      cout << "Person: " << sizeof(person) << endl;
      cout << "Student: " << sizeof(student) << endl;
      cout << "My: " << sizeof(my) << endl;
      
      cout << &my.height << endl;
      cout << &my.age << endl;
      cout << &my.id << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo1.exe
  Person: 4
  Student: 8
  My: 12
  0x7bfe08
  0x7bfe0c
  0x7bfe10
  ```

- 总结：父类的成员变量在前面，子类的在后面

- 补充：父类的成员变量，子类中没有使用，子类的对象大小依然不变，编译器不会去优化，所以要合理设计类







#### 8.2 成员访问权限



- 成员访问权限、继承方式有3种：
  1. `public`：公共的，任何地方都可以访问（`struct默认`）
  2. `private`：私有的，只有当前类内部可以访问（`class默认`）
  3. `protected`：子类内部和当前类可以访问

- 子类在继承父类时，使用了权限修饰：子类内部访问父类成员的权限，是一下两项中权限最小的
  1. 成员本身的访问权限
  2. 上一级父类的继承方式
- 开发中最多的继承方式是`public`继承，保留父类原来的成员访问权限
- 访问权限，不影响对象的内存布局







### 9. 初始化列表



- 特点：
  - 一种便捷的初始化成员变量的方式
  - 只用于构造函数
  - 初始化顺序，只跟成员变量的声明顺序有关
- 补充：
  - 如果构造函数的声明和实现分离，初始化列表只能写在实现中



- 语法：

  ```c++
  class Person
  {
  private:    
      int m_age;
      int m_height;
  
  public:
      // 普通写法
      Person(int age, int height)
      {
          m_age = age;
          m_height = height;
      }
  
      // 初始化列表
      Person(int age, int height) : m_age(age), m_height(height)
      {
      }
  };
  ```

- 两种写法完全等价：(反汇编查看)

  ```assembly
  // 普通构造函数
  // m_age = age;
  mov eax, dword ptr[this]
  mov ecx, dword ptr[age]
  mov dword ptr[eax], ecx
  
  // m_height = height;
  mov eax, dword ptr[this]
  mov ecx, dword ptr[height]
  mov dword ptr [eax+4], ecx
  
  // 初始化列表
  // m_age(age)
  mov eax, dword ptr[this]
  mov ecx, dword ptr[age]
  mov dword ptr[eax], ecx
  
  // m_height(height)
  mov eax, dword ptr[this]
  mov ecx, dword ptr[height]
  mov dword ptr [eax+4], ecx
  ```







### 10. 构造函数互调





#### 10.1 互调语法



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  private:    
      int m_age;
      int m_height;
  
  public:
      // 错误的写法
      // Person() {Person(10, 20);}
      
      // 正确的写法
      Person() : Person(0, 0){}
  
      Person(int age, int height)
      {
          m_age = age;
          m_height = height;
  
          cout << m_age << " " << m_height << endl;
      }
  };
  
  
  int main()
  {
      Person person1;
      Person person2(10, 20);
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo3.exe
  0 0
  10 20
  ```





#### 10.2 语法分析



- 通过反汇编分析两种写法的正确性

  ```assembly
  // 错误的写法
  // 原因：在函数体中写的 Person(0, 0); 是创建临时Person的对象，0 赋值给了临时的Person对象
  // Person() {Person(0, 0);}
  lea ecx, [person1]
  call Person::Person(0E61118h)
  
  mov dword ptr [this], ecx
  push 14h
  push 0Ah
  
  lea ecx, [person] // person是临时对象
  call Person::Person(0E61311h)
  
  mov dword ptr[this], ecx
  
  // 正确的写法
  // Person() : Person(0, 0){}
  lea ecx, [person2]
  call Person::Person(01221118h)
  
  mov dword ptr [this], ecx
  push 14h
  push 0Ah
  
  mov dword ptr[this], ecx
  call Person::Person(01221311h)
  
  mov dword ptr[this], ecx
  ```





#### 10.3 父类的构造函数



- 子类的构造函数默认会调用父类的无参构造函数
- 子类的构造函数主动调用了父类的有参构造函数，则父类的无参构造函数不会被调用
- 如果父类缺少无参构造函数，子类构造函数就必须显式调用父类的有参构造函数



- 代码示例1：(默认会调用父类的无参构造函数)

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      Person()
      {
          cout << "Person::Person()" << endl;
      }
  };
  
  class Student : public Person
  {
  public:    
      Student()
      {
          cout << "Student::Student()" << endl;
      }
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo4.exe
  Person::Person()
  Student::Student()
  ```



- 代码示例2：(主动调用了父类的有参构造函数)

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      Person()
      {
          cout << "Person::Person()" << endl;
      }
  
      Person(int age)
      {
          cout << "Person::Person(int)" << endl;
      }
  };
  
  class Student : public Person
  {
  public:    
      Student() : Person(10)
      {
          cout << "Student::Student()" << endl;
      }
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo4.exe
  Person::Person(int)
  Student::Student()
  ```





#### 10.4 构造和析构的顺序





- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      Person()
      {
          cout << "Person::Person()" << endl;
      }
      ~Person()
      {
          cout << "Person::~Person()" << endl;
      }
  };
  
  class Student : public Person
  {
  public:    
      Student()
      {
          cout << "Student::Student()" << endl;
      }
      ~Student()
      {
          cout << "Student::~Student()" << endl;
      }
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo3> .\demo5.exe
  Person::Person()
  Student::Student()
  Student::~Student()
  Person::~Person()
  ```







### 11. 多态



- 默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态



- 多态是面向对象非常重要的特性
  - 同一个操作，用于不同的对象，可以有不同的解释，产生不同的结果
  - 在运行时，可以识别出真正的对象类型，调用对应子类中的函数



- 多态的要素：
  - 子类重写父类的成员函数`(override)`
  - 父类指针指向子类
  - 利用父类指针调用重写的成员函数





#### 11.1 父类和子类指针



- 父类指针指向子类对象是安全的，子类的继承方式是`public`
- 子类指针指向父类对象是不安全的



- 代码示例1：父类指针指向子类对象

  ```c++
  #include <iostream>
  using namespace std;
  
  struct Person
  {
      int m_age;
  };
  
  struct Student : Person
  {
      int m_score;
  };
  
  int main()
  {
      Person *person = new Student;
      person->m_age = 10;
      cout << "person->m_age: " << person->m_age << "\n";
  
      return 0;
  }
  ```

- 打印结果

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo1.exe
  person->m_age: 10
  ```

- 总结：

  - 父类指针指向子类对象，这样用父类指针使用成员变量时，会很`安全`，不会影响到子类独有的成员变量
  - 父类的成员变量存在得到内存空间，肯定在子类对象的内存范围内，不会超出子类对象的内存范围，所以`安全`





- 代码示例2：子类指针指向父类对象

  ```c++
  #include <iostream>
  using namespace std;
  
  struct Person
  {
      int m_age;
  };
  
  struct Student : Person
  {
      int m_score;
  };
  
  int main()
  {    
      Student *student = (Student *)new Person;
      student->m_age = 10;
      student->m_score = 100;
      
      cout << "m_age: " << student->m_age << "\n" 
           << "m_score: " << student->m_score << "\n";
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo1.exe
  m_age: 10
  m_score: 100
  ```

- 总结：

  - 子类指针指向父类的对象，子类指针指向的成员变量，可能会超出父类对象内存范围内的成员变量，`不安全`
  - 因为可能会覆盖掉，别的子类对象内存范围内的成员变量的值





- 代码示例3：通过反汇编查看强制类型转换

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      void speak(){cout << "Animal::speak()" << endl;}
      void run(){cout << "Animal::run()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  class Cat : public Animal
  {
  public:
      void speak(){cout << "Cat::speak()" << endl;}
      void run(){cout << "Cat::run()" << endl;}
  };
  
  int main()
  {
  	Cat *animal = (Cat *)new Dog;
      animal->speak();
      animal->run();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo1.exe
  Cat::speak()
  Cat::run()
  ```

- 查看反汇编结果：

  ```assembly
  // Cat *animal = (Cat *)new Dog;
  mov dword ptr[ebp-0DCh], 0
  mov ecx, dword ptr[ebp-0DCh]
  mov dword ptr[animal], ecx
  
  // animal->speak();
  mov ecx, dword ptr[animal]
  call Cat::speak(0F714F6h)
  
  // animal->run();
  mov ecx, dword ptr[animal]
  call Cat::run(0F714F1h)
  ```

- 总结：

  - 由上面的`示例3`可知：指针的类型决定了，指针所能访问的内存范围
  - 此时还未实现`多态`







#### 11.2 虚函数实现多态



- 通过虚函数`(virtual function)`实现多态
- 虚函数：被`virtual`修饰的成员函数
- 在`父类`中声明为`虚函数`，子类中`重写`的成员函数会自动`转成虚函数`



-  代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      virtual void speak(){cout << "Animal::speak()" << endl;}
      virtual void run(){cout << "Animal::run()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  class Cat : public Animal
  {
  public:
      void speak(){cout << "Cat::speak()" << endl;}
      void run(){cout << "Cat::run()" << endl;}
  };
  
  void playAnimal(Animal *animal)
  {
      animal->speak();
      animal->run();
  }
  
  int main()
  {
      playAnimal(new Dog);
      playAnimal(new Cat);
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> .\demo2.exe
  Dog::speak()
  Dog::run()
  Cat::speak()
  Cat::run()
  ```





#### 11.3 虚表



- 虚函数的实现原理是`虚表`，这个虚表里存储着最终需要调用的`虚函数地址`，这个虚表也叫虚函数表





##### 11.3.1 虚表的大小



- 前提：
  - 类中的普通函数，在对象中不占用空间，因为函数存在代码区中，而对象在栈区中，只有成员变量占用空间
  - 父类的虚函数，在子类重写后，这些函数会存入一个虚函数表中，虚函数表占用子类对象的内存空间
  - x86环境，指针是4字节
  - x64环境，指针是8字节



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      int m_age;
      virtual void speak(){cout << "Animal::speak()" << endl;}
      virtual void run(){cout << "Animal::run()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      int m_height;
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  class Cat
  { 
  public:
      int m_health;
      void speak(){cout << "Cat::speak()" << endl;}
      void run(){cout << "Cat::run()" << endl;}
  };
  
  int main()
  {
      cout << "Cat::sizeof()= " << sizeof(Cat) << endl;
      cout << "Dog::sizeof()= " << sizeof(Dog) << endl;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo3.exe
  Cat::sizeof()= 4
  Dog::sizeof()= 16
  ```

- 结果分析：

  - Dog对象，继承了父类Animal，对象类有`两个int类型`成员变量：`8字节`
  - 父类还`有虚函数`的存在，所以需要在Dog对象内`创建虚函数表`：`x86是4字节`，`x64是8字节`
  - Dog对象重写的父类的方法，存在代码区中，不和对象一起在栈区中，所以不占用对象内存





##### 11.3.2 反汇编分析虚表



- x86环境中，内存的布局

- 代码示例：

  ```c++
  int main()
  {
      Animal *animal = new Dog();
      animal->m_age = 20;
      return 0;
  }
  ```

  |             | 内存地址     | 内存数据                     | 内存地址     | 内存数据                               |
  | ----------- | ------------ | ---------------------------- | ------------ | -------------------------------------- |
  | `dog`       | `0x00E69B60` | `0x00B89B64`==`虚表内存地址` | `0x00B89B64` | `0x00B814E7`==`Dog::speak()的调用地址` |
  |             | 0x00E69B61   |                              | 0x00B89B65   |                                        |
  |             | 0x00E69B62   |                              | 0x00B89B66   |                                        |
  |             | 0x00E69B63   |                              | 0x00B89B67   |                                        |
  | `&m_age`    | `0x00E69B64` | `20`                         | `0x00B89B68` | `0x00B814CE`==`Dog::run()的调用地址`   |
  |             | 0x00E69B65   |                              | 0x00B89B69   |                                        |
  |             | 0x00E69B66   |                              | 0x00B89B6A   |                                        |
  |             | 0x00E69B67   |                              | 0x00B89B6B   |                                        |
  | `&m_height` | `0x00E69B68` | `0`                          |              |                                        |
  |             | 0x00E69B69   |                              |              |                                        |
  |             | 0x00E69B6A   |                              |              |                                        |
  |             | 0x00E69B6B   |                              |              |                                        |

- 总结：

  - 可以看到，`父类`中有`虚函数`，`子类对象`从`首地址开始`，`存放虚函数表`
  - `虚函数表`内`存放着内存地址`，而这个内存地址`指向`的是`代码区的地址`，也正是子类对象内重写父类方法的地址
  - 所以实现多态后，父类指针指向子类对象时，可以`通过虚函数表`，使得`指针调用子类`的方法，以达到多态的目的





- 反汇编查看：

- 代码示例：

  ```c++
  int main()
  {
      Animal *animal = new Dog();
      animal->m_age = 20;
      animal->speak();
      return 0;
  }
  ```

  ```assembly
  // animal->m_age = 20;
  mov eax, dword ptr[animal] // animal == ebp-8 是指针变量，eax 是Dog对象的地址，里面存放着虚表的地址值
  mov dword ptr[eax+4], 14h
  
  // animal->speak();
  mov eax, dword ptr[animal]
  mov edx, dword ptr[eax] // 从Dog对象的地址开始往后4个字节内的数据存入到 寄存器edx 中，edx 得到 虚表的地址
  
  mov esi, esp
  mov ecx, dword ptr[animal]
  mov eax, dword ptr[edx] // 从 edx 中取4个字节，eax 得到虚表中存放 Dog对象方法的地址，(但不是方法的真正地址，需要jump到真正地址)
  
  call eax // 调用 Dog对象的方法
  ```

  





##### 11.3.3 虚表的设计思想



- 前提：项目中实现了多态，其父类指针多次指向不同的子类对象，且父类的方法用`virtual修饰`
- 原理：
  - 编译器在`编译时`，并`不知道`，项目中父类指针多次指向不同的子类对象
  - 即便`父类指针`指向的对象是`自己本身`的对象，也`一样生成`用于`存放虚表地址`的`内存空间`
  - `编译文件`是`静态`的，而程序在内存中`执行`是`动态`过程
- 目的：
  - 多态中，每个`子对象`都要有一个`虚函数表`
  - 实现程序在内存中`执行`的`动态性`
- 虚表的相关优化：
  - 当父类指针多次指向`多个`子类对象，且都是`同一个类`的对象
  - 此时，这些对象依然有`各自独立`存放`虚表地址`的内存空间
  - 这些子类对象的`前4字节`空间中存放的`虚表地址值`(对象的方法所在代码区的地址)是`相等`的
- 总结：相同类的对象，不管在什么区中，共用一份虚表





##### 11.3.4 多态实现的需求



- 实现需求：大致两种
  1. 完全重写父类的成员函数
  2. 在父类的成员函数基础上，利用多态附加子类对象的成员函数



- 代码示例1：第一种`(完全重写)`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      // 子类会完全重写的虚函数是 可以 为空实现
      virtual void speak(){cout << "Animal" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
  };
  
  int main()
  {
      Animal *animal = new Dog;
      animal->speak();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo4.exe
  Dog::speak()
  ```



- 代码示例2：第二种`(父类的方法实现基础上附加子类的实现)`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      // 父类的方法实现基础上附加子类的实现，此处的父类虚函数实现 可以 不为空实现
      virtual void speak(){cout << "Animal" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      void speak()
      {
          Animal::speak();
          cout << "Dog::speak()" << endl;
      }
  };
  
  int main()
  {
      Animal *animal = new Dog;
      animal->speak();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo4.exe
  Animal
  Dog::speak()
  ```








#### 11.4 虚析构函数



- 父类指针指向子类对象，含有虚函数的父类，应该将析构函数声明为虚函数(虚析构函数)
- `delete`父类指针，才会调用子类的析构函数，保证析构的完整型



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      Animal(){cout << "Animal::Animal()" << endl;}
      virtual ~Animal(){cout << "Animal::~Animal()" << endl;}
  };
  
  class Dog : public Animal
  {
  public:
      Dog(){cout << "Dog::Dog()" << endl;}
      ~Dog(){cout << "Dog::~Dog()" << endl;}
  };
  
  int main()
  {
      Animal *animal = new Dog;
      delete animal;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo4> ./demo5.exe
  Animal::Animal()
  Dog::Dog()
  Dog::~Dog()
  Animal::~Animal()
  ```

- 补充：

  - 先构造父类，再构造子类
  - 先析构子类，再析构父类
  - 父类构造可以不用`virtual`修饰







#### 11.5 纯虚函数



- 定义：没有函数体其初始化为0的虚函数，用来定义接口规范

- 抽象类（`Abstract Class`）
  - 含有纯虚函数的类，不可以实例化（`不可以创建对象`）
  - 抽象类也可以是包含非纯虚函数，成员变量
  - 如果父类是抽象类，子类没有完全实现纯虚函数，那么这个子类依然是抽象类



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal
  {
  public:
      int m_age;
      virtual void speak() = 0;
      virtual void run() = 0;
  };
  
  class Dog : public Animal
  {
  public:
      void speak(){cout << "Dog::speak()" << endl;}
      void run(){cout << "Dog::run()" << endl;}
  };
  
  int main()
  {
      Animal *animal = new Dog();
      cout << animal->m_age << endl;
      animal->run();
      animal->speak();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo1.exe
  0
  Dog::run()
  Dog::speak()
  ```







#### 11.6 多继承



##### 11.6.1 多继承概念

- C++允许一个类，继承多个类（`不建议使用`）
- 如果子类继承的`多个父类`都有虚函数，那么子类对象会产生对应的`多张虚函数表`



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Student
  {
  public:
      int m_score;
  };
  
  class Worker
  {
  public:
      int m_salary;
  };
  
  class Undergraduate : public Student, public Worker
  {
  public:
      int m_grade;
  };
  
  
  int main()
  {
      Undergraduate under;
      cout << "sizeof: " << sizeof(under) << endl;
      under.m_score = 100;
      under.m_salary = 2000;
      under.m_grade = 4;
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo2.exe
  sizeof: 12
  ```



- 内存布局：

  |          |             | 内存地址     | 内存数据 |
  | -------- | ----------- | ------------ | -------- |
  | `&under` | `&m_score`  | `0x00E69B60` | 100      |
  |          |             | 0x00E69B61   |          |
  |          |             | 0x00E69B62   |          |
  |          |             | 0x00E69B63   |          |
  |          | `&m_salary` | `0x00E69B64` | 2000     |
  |          |             | 0x00E69B65   |          |
  |          |             | 0x00E69B66   |          |
  |          |             | 0x00E69B67   |          |
  |          | `&m_grade`  | `0x00E69B68` | 4        |
  |          |             | 0x00E69B69   |          |
  |          |             | 0x00E69B6A   |          |
  |          |             | 0x00E69B6B   |          |







##### 11.6.2 同名成员函数/变量



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Animal_A
  {
  public:
      int m_age;
      void run(){cout << "Animal_A::run()" << endl;}
  };
  
  class Animal_B
  {
  public:
      int m_age;
      void run(){cout << "Animal_B::run()" << endl;}
  };
  
  class Dog : public Animal_A, public Animal_B
  {
  public:
      int m_age;
      void run(){cout << "Dog::run()" << endl;}
  };
  
  int main()
  {
      Dog dog;
  
      dog.m_age = 10;
      dog.Animal_A::m_age = 11;
      dog.Animal_B::m_age = 12;
      dog.Dog::m_age = 13;
      
      dog.run();
      dog.Animal_A::run();
      dog.Animal_B::run();
      dog.Dog::run();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo3.exe
  Dog::run()
  Animal_A::run()
  Animal_B::run()
  Dog::run()
  ```





##### 11.6.3 菱形继承



###### 11.6.3.1 菱形继承结构

- 基本结构：
  - 定义一个类：A
  - 定义类B1，继承A；定义类B2，继承A
  - 定义类C，继承B1，B2



- 菱形继承的问题：
  - 最底层的对象，从基类继承的成员变量冗余，重复
  - 最底层的对象，无法访问基类的成员变量，存在二义性



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class A
  {
      int a;
  };
  
  class B1 : A // 继承A的成员变量，2*int = 8字节
  {
      int b1;
  };
  
  class B2 : A // 同理，2*int = 8字节
  {
      int b2;
  };
  
  class C : B1, B2 // 继承B1，B2，加上自身成员变量，2+2+1 int = 20字节
  {
      int c;
  };
  
  int main()
  {
      C c;
      cout << "sizeof: " << sizeof(c) << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo4.exe
  sizeof: 20
  ```







###### 11.6.3.2 虚继承



- 解决菱形继承带来的底层对象的成员变量冗余，重复和二义性



- 基本结构：
  - 定义一个类：A
  - 定义类B1，继承 `virtual A`；定义类B2，继承 `virtual A`
  - 定义类C，继承B1，B2
- 此时，A为 `虚基类`
- 作用：B1，B2会共同继承同一份 A 的成员，而不是各自继承一份，解决了底层对象的成员冗余



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  struct A
  {
      int a;
  };
  
  struct B1 : virtual A // 虚表8字节，成员变量4字节，12
  {
      int b1;
  };
  
  struct B2 : virtual A // 虚表8字节，成员变量4字节，12
  {
      int b2;
  };
  
  struct C : B1, B2 // 2*12 = 24，虚表8字节，成员变量4字节，虚基类成员变量4字节 = 24 + 8 + 4 + 4 = 40
  {
      int c;
  };
  
  int main()
  {
      C c;
      cout << "sizeof: " << sizeof(c) << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo5> ./demo4.exe
  sizeof: 40
  ```

- 虚继承的类结构：

  - 首地址存放虚指针和偏移量
  - 存放自己的成员变量
  - 存放虚基类的成员变量









### 12. 静态成员





#### 12.1 静态成员基本定义



- 定义：`static`修饰的成员变量/函数
  - 可以通过`对象.静态成员`，`对象指针->静态成员`，`类名::静态成员变量`，进行访问
- 静态成员变量：
  - 存储在数据段（`全局区，类似全局变量`），整个程序运行过程中只有一份内存
  - 对比全局变量，它可以设定访问权限（`public`, `protected`, `private`），达到局部共享的目的
  - 必须初始化，必须在类外面初始化，初始化不能带`static`，如果类的声明和实现分离（`在实现中初始化`）
- 静态成员函数：
  - 内部不能使用`this`指针（`this`指针只能用于非静态成员函数内部）
  - 不能是虚函数（`虚函数只能是非静态成员函数`）
  - 内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数
  - 构造函数和析构函数不可以是静态的
  - 当声明和实现分离，实现不能带`static`
- 总结：
  - 涉及到，通过`对象`来管理，调用成员的变量和函数，都不可以用`static`修饰
  - `static`修饰的成员变量/函数只能通过类，利用作用域使用，或者在静态的函数内使用静态成员变量



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      
      static int m_price;
  
      static void byCar();
  };
  
  int Car::m_price = 1000;
  
  void Car::byCar()
  {
      cout << "Car is running" << endl;
  }
  
  int main()
  {
      cout << "Car price: " << Car::m_price << endl;
      Car::byCar();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo6> .\demo1.exe
  Car price: 1000
  Car is running
  ```







#### 12.2 反汇编分析静态成员



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      int m_age;
      static int m_price;
  };
  
  int Car::m_price = 0;
  
  int g_age;
  
  int main()
  {
      Car car1;
      Car car2;
      
      g_age = 0;
      car1.m_age = 1;
      car1.m_price = 2;
      car2.m_price = 3;
          
      return 0;
  }
  ```

- 反汇编分析，静态成员变量

  ```assembly
  // g_age = 0;
  mov dword ptr ds:[00A9A318h], 0	=> ds 数据段
  
  // car1.m_age = 1;
  mov dword ptr[car], 1	=> mov dword ptr[ebp-8], 1
  
  // car1.m_price = 2;
  mov dword ptr[Car::m_price 00A9A314h)], 2	=> mov dword ptr ds:[00A9A314h], 2
  
  // car2.m_price = 3;
  mov dword ptr[Car::m_price (00A9A314h)], 3	=> mov dword ptr ds:[00A9A314h], 3
  ```

- 总结：

  - 全局变量和类中的静态变量，都存放在数据区内，且程序运行时，仅有一份
  - 静态变量和全局变量的区别：
    - 静态变量可以在类中定义，同时通过`public`, `protected`, `private`修饰其访问权限





#### 12.3 静态成员应用



##### 12.3.1 统计对象个数

- 应用：无论在那个区域增加或删除对象，都能有一个唯一值去统计当前的对象个数

- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  private:
      static int ms_count;
  
  public:
      Car(){++ms_count;}
      ~Car(){--ms_count;}
  
      static int getCount(){return ms_count;}
  };
  int Car::ms_count = 0;
  
  Car g_car; // 1
  
  int main()
  {
      Car car; // 2
      Car *p_car = new Car; // 3
  
      cout << Car::getCount() << endl;
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo6> .\demo2.exe
  3
  ```





##### 12.3.2 单例模式



- 单例模式的构建：
  - 构造/析构函数，私有化
  - 定义一个私有化的 static成员变量指向唯一得到单例对象
  - 提供一个公共的访问单例对象的接口



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Rocket
  {
  private:
      // 构造/析构函数，私有化
      Rocket(){}
      ~Rocket(){}
  
      // 定义一个私有化的 static成员变量指向唯一得到单例对象
      static Rocket* ms_rocket;
  
  public:
      // 提供一个公共的访问单例对象的接口
      static Rocket* sharedRocket()
      {
          // 需要考虑多线程安全
          if (ms_rocket == NULL)
          {
              ms_rocket = new Rocket();
          }
          return ms_rocket;
      }
  
      // 提供一个公共的访问单例对象的接口
      static void deleteRocket()
      {
          // 需要考虑多线程安全
          if (ms_rocket != NULL)
          {
              ms_rocket = NULL;
              delete ms_rocket;
          }
      }
  
      // 测试用函数
      void startRocket(){cout << "Start Rocket" << endl;}    
  };
  Rocket* Rocket::ms_rocket = NULL;
  
  int main()
  {
      Rocket *p_rocket_1 = Rocket::sharedRocket();
      Rocket *p_rocket_2 = Rocket::sharedRocket();
      Rocket *p_rocket_3 = Rocket::sharedRocket();
  
      cout << p_rocket_1 << "\n" << p_rocket_2 << "\n" << p_rocket_3 << endl;
      p_rocket_1->startRocket();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo6> .\demo3.exe
  0x8e6b80
  0x8e6b80
  0x8e6b80
  Start Rocket
  ```

- 总结：由打印结果可看出，指向堆区的对象指针的地址始终不变，对象的单例模型已经实现



- 补充：delete
  - `new`是堆空间，开辟一块区域，用来存放数据
  - `delete`是删除堆空间开辟的区域，使得这片区域`可以被别的new使用`，但里面的数据`没有变化`，
  - 需要在delete之前或之后，使其初始化为`null`









### 13. const成员



- 被`const修饰`的`成员`变量、`非静态`成员`函数`



- `const`成员变量：
  - `必须`在`类内部初始化`，可以在声明时，直接赋值
  - `非static`的`const成员变量`还可以在初始化列表中初始化



- `const`成员函数：
  - `const`关键字写在参数列表后面，函数的声明和实现都要写`const`
    - 内部不能修改`非static`成员变量
    - 内部只能调用`const修饰`的成员函数，`static`成员函数
    - `非const`成员函数可以调用`const`成员函数
  - `const`成员函数和`非const`成员函数`构成重载`
    - `非const`对象（`指针`）优先调用`非const`成员函数
  - `const`对象（`指针`）只能调用`const`成员函数，`static`成员函数







### 14. 引用类型成员



- 引用类型成员变量必须初始化（不考虑static）
  - 在声明的时候直接初始化
  - 通过初始化列表初始化







### 15. 拷贝构造函数



- 拷贝构造函数是构造函数的一种
- 当利用已经存在的对象创建一个新对象时（类似于拷贝），就会调用对象的拷贝构造函数进行初始化
- 拷贝构造函数的格式是固定的，接收一个`const`修饰的`引用类型`参数





#### 15.1 默认拷贝构造函数



- 代码示例：(默认拷贝构造函数)

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      int m_length;
  
  public:
      Car(int price = 0, int lenght = 0) : m_price(price), m_length(lenght){cout << "Car::Car()" << endl;}    
  
      void display(){cout << "price:" << m_price << " length: " << m_length << endl;}
  };
  
  int main()
  {
      Car car1(1, 1);
      car1.display();
  
      Car car2(car1);
      car2.display();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo1.exe
  Car::Car()
  price:1 length: 1
  price:1 length: 1
  ```

- 反汇编查看原理：（默认构造函数）

  ```assembly
  // x86环境
  // Car car2(car1);
  mov eax, dword ptr[ebp-10h] => 10h = 16
  mov dword ptr[ebp-20h], eax => 20h = 32
  // => car2.m_prcie = car1.m_price;
  
  mov ecx, dword ptr[ebp-0Ch] => 0Ch = 12
  mov dword ptr[ebo-1Ch], ecx => 1Ch = 28
  // => car2.m_length = car1.m_length;
  
  // car2.display();
  lea ecx, [ebp-20h]
  call 0024141A
  
  
  // x64环境
  // Car car2(car1);
  mov rax, qword ptr[rbp+8] => 8h = 8
  mov qword ptr[rbp+28h], rax => 28h = 40
  
  // car2.display();
  lea rcx, [rbp+28h]
  call 00007FF685AF12FD
  ```







#### 15.2 自定义拷贝构造函数



- 代码示例：（自定义拷贝构造函数）

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      int m_length;
  
  public:
      Car(int price = 0, int lenght = 0) : m_price(price), m_length(lenght){cout << "Car::Car()" << endl;}    
      Car(const Car &car) : m_price(car.m_price), m_length(car.m_length){cout << "Car::Car(const)" << endl;}
  
      void display(){cout << "price:" << m_price << " length: " << m_length << endl;}
  };
  
  int main()
  {
      Car car1(1, 1);
      car1.display();
  
      Car car2(car1);
      car2.display();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo1.exe
  Car::Car()
  price:1 length: 1
  Car::Car(const)
  price:1 length: 1
  ```







#### 15.3 调用父类拷贝构造函数



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:
      int m_age;
  
      Person(int age) : m_age(age){};
      Person(const Person &person) : m_age(person.m_age){}
  };
  
  class Student : public Person
  {
  public:
      int m_score;
      
      Student(int age, int score) : Person(age), m_score(score){}       
      Student(const Student &student) : Person(student), m_score(student.m_score){}
  };
  
  int main()
  {
      Student stu1(1, 100);
      Student stu2(stu1);
  
      cout << stu2.m_age << " " << stu2.m_score << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo2.exe
  1 100
  ```

- 补充：如果是完全拷贝对象内的数据，可以直接使用默认拷贝构造函数





#### 15.4 浅复制



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Student
  {
  public:
      int m_score;
      
      Student(int score = 0) : m_score(score){cout << "Student::Student()" << endl;}       
      Student(const Student &student) : m_score(student.m_score){cout << "Student::Student(const Student &student)" << endl;}
  };
  
  int main()
  {
      // 默认构造
      Student s1(10);
      
      // 拷贝构造
      Student s2(s1);
      // 拷贝构造 => 创建对象的同时，将 s2 的数据给 s3，符合拷贝构造
      Student s3 = s2;
      
      // 浅复制 => 创建了对象，但没有利用已经存在的对象进赋值，所以是 默认构造
      Student s4;
      s4 = s3; // 此时的两个对象都是 已经存在的对象，不是拷贝g
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo3.exe
  Student::Student()
  Student::Student(const Student &student)
  Student::Student(const Student &student)
  Student::Student()
  ```








#### 15.5 浅/深拷贝





##### 15.5.1 解决浅拷贝问题



- 编译器默认的都是浅拷贝
- 浅拷贝的缺点：
  - 如果出现堆空间指向栈空间，那么浅拷贝后，堆空间内存储着栈空间的地址
  - 栈空间的生命周期是不可控制的，可能会使得堆空间指向栈空间的指针变成野指针



- 代码示例：解决浅拷贝的问题

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      char *m_name;
  
  public:
      Car(int price = 0, const char *name = nullptr) : m_price(price)
      {
          if (name == nullptr){return;}
  
          m_name = new char[strlen(name) + 1]{};
          strcpy(m_name, name);
      }    
      ~Car()
      {
          if (m_name == nullptr){return;}
          m_name = nullptr;
          delete[] m_name;
      }
  
      void printInfo(){cout << m_price << " " << m_name << endl;}
  };
  
  int main()
  {
      char name[] = {'b', 'w', 'm', '\0'};
      Car *car = new Car(100, name);
      car->printInfo();
  
      Car *car2 = new Car(200, "bwm");
      car2->printInfo();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo4.exe
  100 bwm
  200 bwm
  ```







##### 15.5.2 深拷贝



- 使用深拷贝的原因：
  - 当类中有数据会在堆空间中开辟，且在类的对象析构时释放时
  - 此时这个类已有一个对象，而新的对象利用已有的对象进行默认的拷贝构造（浅拷贝）
  - 此时，两个对象的某一个指向堆空间的成员变量，所指的地址相同
  - 当其中一个对象释放，另一个对象中的某个指向堆空间的成员变量也会被释放，使得另一个对象中的成员变量无效化
  - 如果两个对象都释放，则会出现同一个堆空间，两次释放
- 深拷贝定义：
  - 将指针指向的内容拷贝到新的存储空间



- 代码示例：

  ```c++
  #include <iostream>
  #include <cstring>
  using namespace std;
  
  class Car
  {
  private:
      int m_price;
      char *m_name;
      void copy(const char *name = nullptr)
      {
          if (name == nullptr){return;}
  
          m_name = new char[strlen(name) + 1]{};
          strcpy(m_name, name);
      }
  
  public:
      Car(int price = 0, const char *name = nullptr) : m_price(price){copy(name);}    
      Car(const Car &car) : m_price(car.m_price){copy(car.m_name);}
      ~Car()
      {
          if (m_name == nullptr){return;}
          m_name = nullptr;
          delete[] m_name;
      }
  
      void printInfo(){cout << m_price << " " << m_name << endl;}
  };
  
  int main()
  {
      Car car1(100, "bwm");
      Car car2 = car1;
      car2.printInfo();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo5.exe
  100 bwm
  ```

  







### 16. 对象类型参数和返回值



- 代码示例1：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      Car(){cout << "Car::Car()" << endl;}
      Car(const Car &car){cout << "Car::Car(const)" << endl;}    
  };
  
  void test(Car car){}
  
  int main()
  {
      Car car1;
      test(car1);
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo6.exe
  Car::Car() // Car car1;
  Car::Car(const) // Car car = car1;
  ```

  





- 代码示例2：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      Car(){cout << "Car::Car() "<< this << endl;}    
      Car(const Car &car){cout << "Car::Car(const) " << this << endl;}
  };
  
  void test1(Car car){}
  
  Car test2()
  {
      Car car;
      return car;
  }
  
  int main()
  {
      Car car;
      test1(car);
  
      cout << endl;
  
      Car car1;
      car1 = test2();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo7> .\demo6.exe
  Car::Car() 0x7bfe1d
  Car::Car(const) 0x7bfe1e
  
  Car::Car() 0x7bfe1c
  Car::Car() 0x7bfe1f
  ```








### 17. 匿名对象



- 又名：临时对象
- 没有名称，不被指针指向，一次性使用，立即销毁



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      Car(){cout << "Car::Car()" << endl;}
      Car(const Car &car){cout << "Car::Car(const)" << endl;}    
      ~Car(){cout << "Car::~Car()" << endl;}
  };
  
  void test(Car car){}
  
  int main()
  {
      test(Car());
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo8> .\demo1.exe
  Car::Car()
  Car::~Car()
  ```







### 18. 隐式构造



- 又名：转换构造

- 在某些情况下，会隐式调用单参数的构造函数
- 通过关键字`explicit`禁用隐式构造



- 代码示例1：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  private:
      int m_age;    
  public:
      Person(){cout << "Person::Person()" << endl;}
      Person(int age) : m_age(age){cout << "Car::Car(int)" << endl;}
      ~Person(){cout << "Person::~Person()" << endl;}
  };
  
  void test(Person person){}
  Person test2(){return 40;}
  
  int main()
  {
      Person p1 = 20;
      test2();
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo8> g++ demo2.cpp -o demo2; .\demo2
  Car::Car(int)
  Car::Car(int)
  Person::~Person()
  Person::~Person()
  ```





- 代码示例2：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  private:
      int m_age;    
  public:
      Person(){cout << "Person::Person()" << endl;}
      explicit Person(int age) : m_age(age){cout << "Car::Car(int)" << endl;}
      ~Person(){cout << "Person::~Person()" << endl;}
  };
  
  void test(Person person){}
  
  int main()
  {
      // Person p1 = 20; // 此时这样的写法被 禁用
      Person p1(20);
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo8> g++ demo3.cpp -o demo3; .\demo3
  Car::Car(int)
  Person::~Person()
  ```







### 19. 编译器自动生成的构造函数



- C++编译器会在特定的情况下，会给类自动生成无参的构造函数
  - 成员变量在声明时，初始化
  - 有定义虚函数
  - 虚继承了其它类
  - 包含了对象类型的成员，且这个成员有构造函数（可以是编译器自动生成的，或自定义的）
- 总结：
  - 对象创建后，需要进行一些额外的操作（内存操作，函数调用，成员变量初始化，虚函数，虚继承，调用父类构造等等）
  - 编译器都会自动生成无参的构造函数





- 代码示例1：成员变量在声明时，初始化

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      int m_age = 5;    
  };
  
  // 此段代码 完全等价 上面的写法
  /*
  class Car
  {
  public:
      int m_age = 5;    
      Car(){m_age = 5;}
  };
  */
  
  int main()
  {
      Car car;
      return 0;
  }
  ```

- 反汇编查看：

  ```assembly
  // Car car;
  lea ecx, [car]
  call Car::Car(0A1384h)
  
  mov dword ptr[eax], 5
  mov eax, dword ptr[this]
  ```





- 代码示例2：有定义虚函数

  ```c++
  #include <iostream>
  using namespace std;
  
  class Car
  {
  public:
      int m_age;  
      virtual void run(){}
  };
  
  int main()
  {
      Car car;
      return 0;
  }
  ```

- 反汇编查看：

  ```assembly
  lea ecx, [car]
  call Car::Car(0E5111Dh)
  
  mov dword ptr[this], ecx
  mov eax, dword ptr[this]
  mov dword ptr[eax], offset Car::`vftable`(0E57B34h) // vftable == virtual function table 虚函数表
  mov eax, dword ptr[this]
  ```

  



- 代码示例3：虚继承了其它类

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:
      int m_age;  
      void run(){}
  };
  
  class Student : virtual public Person
  {
  public:
      int m_score;
  };
  
  int main()
  {
      Student student;
      return 0;
  }
  ```

- 反汇编查看：

  ```assembly
  lea ecx, [student]
  call Student::Student(012213A7h)
  
  mov eax, dword ptr[this]
  mov dword ptr[eax], offset Student::`vftable`(01227B30h)
  mov eax, dword ptr[this]
  ```







### 20. 友元



- 友元包括：
  - 友元函数
    - 如果将函数A（非成员函数）声明为类B的友元函数，那么函数A内部可以直接访问类B对象的所有成员
  - 友元类
    - 类A内声明了类B的友元，类B可以访问类A的所有成员





- 代码示例1：友元函数

  ```c++
  #include <iostream>
  using namespace std;
  
  class Point
  {
  private:
      int m_x;
      int m_y;
  
      // 声明 友元函数
      friend Point add_P(Point &, Point &);  
  
  public:
      Point(int x = 0, int y = 0) : m_x(x), m_y(y){}
      void printPoint(){cout << m_x << " " << m_y << endl;}    
  };
  
  // 实现 友元函数
  Point add_P(Point &p1, Point &p2)
  {
      return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);
  }
  
  int main()
  {
      Point p1(10, 10);
      Point p2(20, 20);
      Point p3(add_P(p1, p2));
      p3.printPoint();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo8> .\demo5
  30 30
  ```





- 代码示例2：友元类

  ```c++
  #include <iostream>
  using namespace std;
  
  class Point
  {
  private:
      int m_x;
      int m_y;
      
      // 声明 友元类
      friend class FH_Math;
  
  public:
      Point(int x = 0, int y = 0) : m_x(x), m_y(y){}
      void printPoint(){cout << m_x << " " << m_y << endl;}    
  };
  
  // 实现 友元类
  class FH_Math
  {
  public:    
      Point add_P(Point &p1, Point &p2)
      {
          return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);
      }
  };
  
  int main()
  {
      Point p1(10, 10);
      Point p2(20, 20);
      Point p3 = FH_Math().add_P(p1, p2);
      p3.printPoint();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo8> .\demo6
  30 30
  ```







### 21. 内部类



#### 21.1 内部类的定义



- 定义：
  - 类B定义在类A中，B就是A的内部类（嵌套类）
  - 类A就是B的外部类
- 特点：
  - 支持：`public`, `protected`, `private`权限
  - 内部类成员函数可以访问外部类所有成员
  - 外部类则无法访问内部类的成员
  - 成员函数可以直接不带类名，对象名访问其外部类的`static修饰`的成员
  - 不会影响外部类的内存布局



- 代码示例1：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  private:
      int m_age;
  
  public:
      void test1(){cout << "Person::test1()" << endl;}
      static void test2(){cout << "Person::test2(static)" << endl;}
  
  public:
      class Student
      {
      private:
          int m_id;
  
      public:        
          void test3(){test2();}        
      };
  };
  
  
  int main()
  {
      Person::Student s;
      s.test3();
  
      cout << sizeof(Person) << endl;
      cout << sizeof(Person::Student) << endl;
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\demo9> .\demo1
  Person::test2(static)
  4
  4
  ```





#### 21.2 内部类声明与实现分离



- 跟正常的函数声明和实现分离差不多
- 标明类的作用域就可以了







### 22. 局部类



- 在一个函数中定义一个类：局部类
- 特点：
  - 作用域仅限于所在的函数内部，不允许`static修饰`成员
  - 局部类的成员函数不能直接访问所在函数的局部变量（`static`可以）







### 23. 运算符重载



- 注意：
  - 有些运算符不可以重载：
    - 对象成员访问运算符`.`
    - 域运算符`::`
    - 三目运算符`?`
    - `sizeof`
  - 有些运算符只能重载为成员函数：
    - 赋值运算符`=`
    - 下标运算符`[]`
    - 函数运算符`()`
    - 指针访问成员`->`





#### 23.1 基本运算符重载



- 作用：给运算符增加一些新的功能
- 设计思路：
  - 如果仅和类相关，重载运算符函数优先写在类里面
  - 如果是`<<`，`>>`的重载，尽量写成全局函数




- 代码示例1：`+, -`, `+=, -=`, `==, !=`, `-`, `++, --`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Point
  {
  private:
      int m_x;
      int m_y;
  
  public:
      Point(int x = 0, int y = 0) : m_x(x), m_y(y){}
  
      void showPoint(){cout << "(" << m_x << ", " << m_y << ")" << endl;}         
  
      // operator +, -
      const Point operator+(const Point &point) const
      {
          return Point(this->m_x + point.m_x, this->m_y + point.m_y);
      }
  
      // operator +=, -=
      Point &operator+=(const Point &point)
      {
          this->m_x += point.m_x;
          this->m_y += point.m_y;
          return *this;
      }
  
      // operator ==, !=
      const bool operator==(const Point &point)
      {
          return (this->m_x == point.m_x && this->m_y == point.m_y);
      }
  
      // operator -
      const Point operator-() const
      {
          return Point(-m_x, -m_y);
      }
  
      // operator ++, --
      Point &operator++()
      {
          ++this->m_x;
          ++this->m_y;
          return *this;
      }
      const Point operator++(int)
      {
          Point origin_P(this->m_x, this->m_y);
          ++this->m_x;
          ++this->m_y;
          return origin_P;
      }
  };
  
  int main()
  {
      // operator +, -
      cout << "operator +, -" << endl;
      Point p1(10, 10);
      Point p2(20, 20);
      Point p3 = p1 + p2;
      Point p4 = p1 + p2 + p3;
      p4.showPoint();
      cout << "---------" << endl;
  
      // operator +=, -=
      cout << "operator +=, -=" << endl;
      Point p5(1, 1);
      Point p6(2, 2);
      Point p7;
      (p7 += p5) = p6;
      p4.showPoint();
      cout << "---------" << endl;
  
      // operator ==, !=
      cout << "operator ==, !=" << endl;
      Point p8(1, 1);
      Point p9(1, 1);
      cout << (p1 == p2 ? "true" : "false") << endl;
      cout << "---------" << endl;
  
      // operator -
      cout << "operator -" << endl;
      Point p10(1, 1);
      Point p11(0, 0);
      Point p12;
      p11 = -p10;
      p10.showPoint();
      p11.showPoint();
      p12 = -(-p1);
      p12.showPoint();
      cout << "---------" << endl;
  
      // operator ++, --
      cout << "// operator ++, --" << endl;
      Point p13(1, 1);
      Point p14(0, 0);
      Point p15(2, 2);
      ++p13;
      p13++;
      p13.showPoint();
      p14 = (p13++) + p15;
      p14.showPoint();
      cout << "---------" << endl;
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\demo9> .\demo3
  operator +, -
  (60, 60)
  ---------
  operator +=, -=
  (60, 60)
  ---------
  operator ==, !=
  false
  ---------
  operator -
  (1, 1)
  (-1, -1)
  (10, 10)
  ---------
  // operator ++, --
  (3, 3)
  (5, 5)
  ---------
  ```



- 代码示例2：`<<` `>>`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Point
  {
  private:
      int m_x;
      int m_y;
  
  public:
      Point(int x = 0, int y = 0) : m_x(x), m_y(y){}
   
      // operator <<, >>
      friend ostream &operator<<(ostream &cout, const Point &point);
      friend istream &operator>>(istream &cin, Point &point);
  };
  
  ostream &operator<<(ostream &cout, const Point &point)
  {
      cout << "(" << point.m_x << ", " << point.m_y << ")";
      return cout;
  }
  
  istream &operator>>(istream &cin, Point &point)
  {
      cout << "input m_x: ";
      cin >> point.m_x;
  
      cout << "input m_y: ";
      cin >> point.m_y;
      return cin;
  
  }
  
  int main()
  {
      // operator <<, >>
      cout << "operator <<" << endl;
      Point p1(10, 10);
      cout << p1 << endl;
      cout << p1 << p1 << endl;
      cout << "--------" << endl;
  
      cout << "operator >>" << endl;
      Point p2;
      Point p3;
      cin >> p2 >> p3;
      cout << p2 << "\n" << p3 << endl;
      cout << "--------" << endl;
  
      return 0;
  }
  ```
  
- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\demo9> .\demo4    
  operator <<
  (10, 10)
  (10, 10)(10, 10)
  --------
  operator >>
  input m_x: 1
  input m_y: 1
  input m_x: 2
  input m_y: 2
  (1, 1)
  (2, 2)
  --------
  ```

  





#### 23.2 调用父类的运算符重载



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
  public:    
      int m_age;
  
      Person &operator=(const Person &person)
      {
          this->m_age = person.m_age;
          return *this;
      }
  };
  
  class Student : public Person
  {
  public: 
      int m_score;
  
      Student &operator=(const Student &student)
      {
          Person::operator=(student);
          this->m_score = student.m_score;
          return *this;
      }
  
      void showInfo()
      {
          cout << m_age << " " << m_score << endl;
      }
  };
  
  int main()
  {
      Student s1;
      s1.m_age = 10;
      s1.m_score = 20;
  
      Student s2 = s1;
      s2.showInfo();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\demo9> .\demo5
  10 20
  ```

  





#### 23.3 仿函数



- 定义：
  - 仿函数(`functor`)，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个`operator`这个类就有了类似函数的行为
  - 将一个对象，作为一个函数来使用
  - 对比普通的函数，仿函数可以保存状态



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Sum
  {
  private:
      int m_age;
  
  public:
      int operator()(int a = 0, int b = 0)
      {
          return a + b;
      }
  };
  
  int main()
  {
      Sum s1;
      cout << s1(10, 20) << endl;
      
      return 0;
  }
  ```

- 打印示例：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo10> .\demo1
  30
  ```









### 24. 模板



- 泛型：一种类型参数化以达到代码复用的技术
- 种类：`函数模板`，`类模板`
- 模板没有被使用，不会被实例化





#### 24.1 函数模板定义



- 代码示例：`函数模板`, `多参数函数模板`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Point
  {
  private:
      int m_x;
      int m_y;
  
      friend ostream &operator<<(ostream &cout, const Point &point);
  
  public:
      Point(int x = 0, int y = 0) : m_x(x), m_y(y){}
  
      Point operator+(const Point &point)
      {
          return Point(this->m_x + point.m_x, this->m_y + point.m_y);
      }         
  };
  
  ostream &operator<<(ostream &cout, const Point &point)
  {
      return cout << "(" << point.m_x << ", " << point.m_y << ")";
  }
  
  // 函数模板
  template<typename T>
  T add(T a, T b)
  {
      return a + b;
  }
  
  // 多参数函数模板
  template<typename T_int, typename T_double>
  T_double add(T_int a, T_double b)
  {
      return a + b;
  }
  
  int main()
  {
      cout << add<int>(1, 2) << endl;
      cout << add<int, double>(1, 2.1) << endl;
      cout << add<Point>(Point(1, 1), Point(2, 2)) << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo10> .\demo1
  3
  3.1
  (3, 3)
  ```








#### 24.2 函数模板分离



- 编译基本过程：
  - 先把`A.cpp`包含的`A.h`的内容复制到`A.cpp`中`(声明和实现回到同一个cpp文件中)`
  - 再编译`main.cpp`和`A.cpp`成`main.obj`和`A.obj`
  - 再通过`main.ilk`链接`main.cpp`和`A.cpp`
  - 修正了`main.cpp`中调用`A.cpp`中函数时，`call的函数地址`
  - 最后生成`main.exe`



- 代码示例：`模板的错误编译`

- `add.h`

  ```c++
  template<typename T>
  T add(T a, T b);
  ```

- `add.cpp`

  ```c++
  #include 'add.h'
  
  T add(T a, T b)
  {
      return a + b;
  }
  ```

- `main.cpp`

  ```c++
  #include <iostream>
  #include 'add.h'
  using namespace std;
  
  int main()
  {
      add(1, 2);
      return 0;
  }
  ```

- 以上代码编译不会报错，但`链接`报错，不会生成`.exe`

- 原因：

  - `模板没有被使用，不会被实例化`
  - 所以`add.cpp`在编译过程中，编译器未发现在`add.cpp`中有使用`add()`模板函数的地方
  - 于是，便将`add.h`和`add.cpp`中未被使用的`add()`模板函数优化了`(即便链接后，add()在main.cpp中被使用)`
  - 链接后，`main.cpp`中调用`add()`函数，得不到有效的`函数实现地址(此时main.cpp中是有函数声明的，因为包含了add.h)`，所以会报错



- 代码示例：`正确的写法`

- `add.h`

  ```c++
  template<typename T>
  T add(T a, T b)
  {
      return a + b;
  }
  ```

- `main.cpp`

  ```c++
  #include <iostream>
  #include 'add.h'
  using namespace std;
  
  int main()
  {
      add(1, 2);
      return 0;
  }
  ```

- 写模板函数时，不要进行声明实现分离，全部写在`.h`中，正规的方式是`.hpp`







#### 24.3 类模板的定义



- 注意：类模板中的友元函数声明
  - 需先声明类和友元函数的模板
  - 再实现友元函数
  - 且最好友元函数的模板参数和类模板的参数类型不同
  - 另一种方式：声明和实现中都要在`<<`后加入`<>`
    - `ostream &operator<< <>(ostream &cout, const Array<Arr> &arr);`



- 代码示例：

- `array.hpp`

  ```c++
  #pragma once
  
  #include <iostream>
  using namespace std;
  
  template<typename ArrItem>
  class Array;
  
  template<typename Arr>
  ostream &operator<<(ostream &cout, const Array<Arr> &arr);
  
  template<typename ArrItem>
  class Array
  {
  private:
      ArrItem *m_data;
      int m_size;
      int m_capacity;
  
  public:
      Array(int capacity);
        
      ~Array();
  
      void add(ArrItem value);
  
      ArrItem get(int index) const;
  
      ArrItem operator[](int index) const;
  
      int size() const;
  
      void remove(int index);
  
      template<typename Arr>
      friend ostream &operator<<(ostream &cout, const Array<Arr> &arr);
  };
  
  template<typename ArrItem>
  Array<ArrItem>::Array(int capacity)
  {
      m_capacity = (capacity > 0) ? capacity : 3;
      m_data = new ArrItem[m_capacity];
      m_size = 0;
  }        
  
  template<typename ArrItem>
  Array<ArrItem>::~Array()
  {
      if (m_data == nullptr){return;}
      delete[] m_data;
  }
  
  template<typename ArrItem>
  void Array<ArrItem>::add(ArrItem value)
  {
      if (m_size >= m_capacity)
      {
          // TODO 扩容
          cout << "size not free" << endl;
          return;
      }
      m_data[m_size] = value;
      ++m_size;
  }
  
  template<typename ArrItem>
  ArrItem Array<ArrItem>::get(int index) const
  {
      if (index < 0 || index >= m_size)
      {
          throw("<< !!! 数组下标越界 !!! >>");
      }
      return m_data[index];
  }
  
  template<typename ArrItem>
  ArrItem Array<ArrItem>::operator[](int index) const
  {
      return get(index);
  }
  
  template<typename ArrItem>
  int Array<ArrItem>::size() const
  {
      return m_size;
  }
  
  template<typename ArrItem>
  void Array<ArrItem>::remove(int index)
  {
      if (index < 0 || index >= m_size)
      {
          throw("<< !!! 数组下标越界 !!! >>");
      }
  }
  
  template<typename Arr>
  ostream &operator<<(ostream &cout, const Array<Arr> &arr)
  {
      int size = arr.size();
      cout << "[";
      for (int i = 0; i < size; ++i)
      {
          if (i != 0){cout << ", ";}
          cout << arr[i];
      }
      return cout << "]";
  }
  ```

- `demo2.cpp`

  ```c++
  #include "array.hpp"
  #include <iostream>
  using namespace std;
  
  class Point
  {
  private:
      int m_x;
      int m_y;
  
  public:
      Point(int x = 0, int y = 0) : m_x(x), m_y(y){}      
  
      friend ostream &operator<<(ostream &cout, const Point &point);
  };
  
  ostream &operator<<(ostream &cout, const Point &point)
  {
      return cout << "(" << point.m_x << ", " << point.m_y << ")";
  }
  
  int main()
  {
      cout << "----Array<int>----" << endl;
      Array<int> array(3);
      array.add(1);
      array.add(2);
      array.add(3);
      array.add(4);
      cout << "arr[0]: " << array.get(0) << endl;
      cout << "arr[1]: " << array[1] << endl;
      cout << "size: " << array.size() << endl;
      cout << "arr: " << array << endl;
      cout << "\n";
  
      cout << "----Array<Point>----" << endl;
      Array<Point> arr_Point(2);
      arr_Point.add(Point(1, 1));
      arr_Point.add(Point(2, 2));
      cout << "arr_Point: " << arr_Point << endl;
      cout << "\n";
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo10> .\demo2
  ----Array<int>----
  size not free
  arr[0]: 1
  arr[1]: 2
  size: 3
  arr: [1, 2, 3]
  
  ----Array<Point>----
  arr_Point: [(1, 1), (2, 2)]
  ```










### 25. 其它语法-特性





#### 25.1 类型转换



- C语言风格的类型转换符

  - `(type)expression`
  - `type(expression)`

- C++四种转换

  - `static_cast`

  - `dynamic_cast`

  - `reinterpret_cast`

  - `const_cast`

    使用格式：`xx_cast<type>(expression)`



##### 25.1.1 const_cast



- 一般用于去除`const`属性，将`const`转换成`非const`



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person{};
  
  int main()
  {
      const Person *p1 = new Person;
      // 两种写法完全等价
      Person *p2 = const_cast<Person *>(p1);
      Person *p3 = (Person *)p1;
      
      return 0;
  }
  ```

- 反汇编查看

  ```assembly
  // Person *p2 = const_cast<Person *>(p1);
  mov eax, dword ptr[p1]
  mov dword ptr[p2], eax
  
  // Person *p3 = (Person *)p1;
  mov eax, dword ptr[p1]
  mov dword ptr[p3], eax
  ```

  





##### 25.1.2 dynamic_cast



- 一般用于多态类型转换，有运行时的安全检测



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person
  {
      virtual void run();
  };
  
  class Student : public Person
  {};
  
  int main()
  {
      Person *p1 = new Person;
      Person *p2 = new Student;
  
      // 两种写法完全等价
      Student *s1 = (Student *)p1; // 不安全
      Student *s1 = dynamic_cast<Student *>(p1); // 不安全
      
      Student *s2 = dynamic_cast<Student *>(p2); // 安全
      
      return 0;
  }
  ```

- 反汇编查看：

  ```assembly
  // Student *s1 = dynamic_cast<Student *>(p1);
  mov eax, dword ptr[p1]
  call __RTDynamicCast(0C14ABh)
  mov dword ptr[s1], eax
  ```







##### 25.1.3 static_cast



- 对比`dynamic_cast`确实安全检测
- 不能交叉转换（不是同一继承体系的，无法转换）
- 常用于基本数据类型转换，`非const`转换`const`



- 代码示例：`交叉转换`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person{};
  
  class Car{};
  
  int main()
  {
      Person *p1 = new Person;
      
      // 两个类之间完全没有关系，强行转化：交叉转换
      Car *c1 = (Car *)p1;
      Car *c2 = dynamic_cast<Car *>(p1);
      
      return 0;
  }
  ```



- 代码示例：`非const`转换`const`

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person{};
  
  int main()
  {
      Person *p1 = new Person;
      const Person *p2 = static_cast<Person *>(p1);
      
      return 0;
  }
  ```







##### 25.1.4 reinterpret_cast



- 属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅只是简单的二进制数据拷贝



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  int main()
  {
      int a = 10;
      
      // C语言的隐式转换
      double b = a;
      
      double d = reinterpret_cast<double&>(a);
      
      return 0;
  }
  ```

- 内存分析：反汇编

  ```assembly
  int a = 10;
  // 二进制：00001010 00000000 00000000 00000000
  // 十六进制：0A 00 00 00
  // 小段模式：int类型4字节，从右往左读取
  
  double b = a;
  // 00 00 00 00 00 00 24 40
  // cvtsi2sd xmm0, dword ptr[a]
  // movsd mmword ptr[d], xmm0
  
  double d = reinterpret_cast<double&>(a);
  // 0A 00 00 00 cc cc cc cc
  // movsd xmm0, mmword ptr[a]
  // movsd mmword ptr[d], xmm0
  ```









#### 25.2 C++11特性



- `auto`：

  - 可以初始化表达式中推断出变量的类型，提高开发效率

  - 属于编译器特性，不影响最终的机器码质量，不影响运行效率

    ```c++
    auto i = 10; // int
    auto str = "c++"; // const char *
    auto p = new Person; // Person *
    ```

    

- `decltype`:

  - 可以获取变量的类型

    ```c++
    int a = 10;
    decltype(a) b = 20;
    ```



- `nullptr`:

  - 可以解决`NULL`的二义性问题

  - `NULL`本质是`define NULL 0`

  - 在`c++98`中`void fun(int){}``void fun(int *){}`时会遇到二义性，在`c++11`之后，默认为`0`

    ```c++
    #include <iostream>
    using namespace std;
    
    void func(int a){cout << "func(int): " << a << endl;}
    
    void func(int *a){cout << "func(int *): " << a << endl;}
    
    int main()
    {
        // func(NULL);
        func(nullptr);
    
        return 0;
    }
    ```

  - 打印结果：

    ```powershell
    PS C:\Users\Admin\Desktop\Project\Demo11> .\demo3
    func(int *): 0
    ```



- `快速遍历`：

  ```c++
  int arr[] = {};
  for (int a : arr){cout << a << endl;}
  ```





#### 25.3 Lambda表达式



- lambda表达式：
  - 本质是函数
  - 完整结构：`[capture list] (params list) mutable exception -> return type {function body};`
    - `capture list`：捕获外部变量列表
    - `params list`：形参列表，不能使用默认参数，不能省略参数名
    - `mutable`：用于说明是否可以修改捕获的变量
    - `exception `：异常设定
    - `return type`：返回值类型
    - `function body`：函数体
  - 省略的写法：
    - `[capture list] (params list) -> return type {function body};`
    - `[capture list] (params list){function body}; `
    - `[capture list]{function body}; `





##### 25.3.1 lambda基本用法



- 代码示例1：

  ```c++
  #include <iostream>
  using namespace std;
  
  int main()
  {
      // 无参，无返回值，默认调用
      ([]
      {
          cout << "func() - 1" << endl;
      })();
  
      // 可以用指针存储
      void (*p)() = []
      {
          cout << "func() - p" << endl;
      };
      p();
  
      // 直接用auto存储更方便
      auto p1 = []
      {
          cout << "func() - p1" << endl;
      };
      p1();
  
      // 有返回值和参数
      auto add1 = [](int a, int b) -> auto
      {
          return a + b;
      };
      cout << add1(1, 2) << endl;
  
      // 返回值类型也可省略
      auto add2 = [](int a, int b)
      {
          return a + b;
      };
      cout << add2(2, 3) << endl;
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo11> .\demo4
  func() - 1
  func() - p
  func() - p1
  3
  5
  ```



- 代码示例2：

  ```c++
  #include <iostream>
  using namespace std;
  
  void calculate(int a, int b, int (*func)(int, int))
  {
      cout << func(a, b) << endl;
  }
  
  int main()
  {
      calculate(1, 2, [](int a, int b){return a + b;});
      calculate(4, 2, [](int a, int b){return a - b;});
      calculate(8, 2, [](int a, int b){return a * b;});
      calculate(8, 2, [](int a, int b){return a / b;});
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo11> .\demo5
  3
  2
  16
  4
  ```





##### 25.3.2 lambda变量捕获



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  int main()
  {
      int a = 10;
      int b = 20;
  
      auto add1 = [a, b](int c, int d)
      {
          cout << a + b << "\n" << c + d << endl;
      };
      add1(1, 98);
  
      // 隐式捕获:（全捕获）
      // [=] 值类型
      // [&] 引用类型 
      auto add2 = [=]
      {
          cout << a + b << "\n";
      };
      add2();
      
      return 0;
  }
  ```







#### 25.4 C++14特性



- 泛型lambda表达式：

  ```c++
  auto func = [](auto a, auto b){return a + b;};
  ```



- 捕获的变量进行初始化

  ```c++
  int a = 9;
  auto func = [a = 10]{cout << a << endl;};
  func(); //打印结果：10
  
  cout << a << endl; // 打印结果：9
  ```







#### 25.5 C++17特性



- 可以进行初始化的`if`和`switch`语句



- 代码示例：`if`，`else if`

  ```c++
  if (int a = 10; a > 0)
  {
      cout << a << endl;
  }
  ```



- 代码示例：`switch`

  ```c++
  switch(int a = 1; a)
  {
      case 0:
          break;
      case 1:
          break;
      default:
          break;
  }
  ```

  







### 26. 异常



#### 26.1 异常基本用法



- 编程过程中常见的错误：
  - 语法错误
  - 逻辑错误
  - 异常
- 异常：一种程序运行过程中可能会发生的错误
  - 每次异常可能类型不同，不能确定
  - 异常没有处理，程序会直接中断或崩溃等等
- 异常处理过程：
  - `throw`异常后，会在当前函数中查找匹配的`catch`
  - 找不到就会终止当前的函数代码，去上一层函数中查找
  - 如果都找不到，程序直接终止



- 代码示例1：简单的异常演示

  ```c++
  #include <iostream>
  using namespace std;
  
  int main()
  {
      int i = 0;
      for (i ; i < 99999; ++i)
      {
          try
          {
              int *p = new int[999999];
          }
          catch(...)
          {
              cout << "for loop " << i << " error!" << endl;
              break;
          }
      }
      
      return 0;
  }
  ```

- 打印结果：多次打印（每次的异常结果可能不同）

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo1
  for loop 6176 error!
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo1
  for loop 6180 error!
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo1
  for loop 6182 error!
  ```

  



- 代码示例2：主动抛出异常

  ```c++
  #include <iostream>
  using namespace std;
  
  void divide(int a, int b)
  {
      if (b == 0)
      {
          throw 0;
      }
      cout << a / b << endl;
  }
  
  int main()
  {
      try
      {
          divide(10, 1);
          divide(10, 0);
          divide(10, 2);
      }
      catch(const int exc)
      {
          cout << "Divide Error " << exc << "\n";
      }
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo2
  10
  Divide Error 0
  ```

- 总结：`throw`后面的类型，要和`catch`里面接受的类型`保持一致`





- 代码示例3：异常处理过程

- 没有`catch`

  ```c++
  #include <iostream>
  using namespace std;
  
  void func1()
  {
      cout << "func1()-begin" << endl;
      throw 0; // 抛出异常，func1()中没有catch，向上层函数func2()中找
      cout << "func1()-end" << endl;
  }
  
  void func2()
  {
      cout << "func2()-begin" << endl;
      func1(); // throw 来到func2()，也没有发现catch，继续向上到main()
      cout << "func2()-end" << endl;
  }
  
  int main()
  {
      cout << "main()-begin" << endl;
      func2(); // throw来到main()中，依然没有发现catch，此时程序终止
      cout << "main()-end" << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo3
  main()-begin
  func2()-begin
  func1()-begin
  ```



- 有`catch`

  ```c++
  #include <iostream>
  using namespace std;
  
  void func1()
  {
      cout << "func1()-begin" << endl;
      try
      {
          throw 0;
      }
      catch(int exc)
      {
          cout << "Error " << exc << "\n";
      }
      
      cout << "func1()-end" << endl;
  }
  
  void func2()
  {
      cout << "func2()-begin" << endl;
      func1();
      cout << "func2()-end" << endl;
  }
  
  int main()
  {
      cout << "main()-begin" << endl;
      func2();
      cout << "main()-end" << endl;
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo3
  main()-begin
  func2()-begin
  func1()-begin
  Error 0
  func1()-end
  func2()-end
  main()-end
  ```

  





#### 26.2 异常抛出声明



- 为了增强可读性和方便团队协作，函数内部抛出异常，建议函数声明一下函数类型



- 代码示例：

  ```c++
  void func1() throw(){} // 不抛出异常
  void func2() throw(int, double){} // 可能抛出 int，double 类型的异常
  ```

  





#### 26.3 自定义异常类型



- 代码示例1：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Exception
  {
  public:    
      virtual const char *what() = 0;
  };
  
  class DivideException : public Exception
  {
  public:    
      const char *what(){return "Divide Error";}
  };
  
  void divide(int a, int b)
  {
      if (b == 0){throw DivideException();}
      cout << a / b << "\n";
  }
  
  int main()
  {
      try
      {
          divide(10, 0);
      }
      catch(DivideException e)
      {
          cout << e.what() << "\n";
      }
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo4
  Divide Error
  ```





- 代码示例2：

  ```c++
  #include <iostream>
  using namespace std;
  
  class Exception
  {
  public:    
      virtual const char *what() const = 0;
  };
  
  class DivideException : public Exception
  {
  public:    
      const char *what() const{return "Divide Error";}
  };
  
  void divide(int a, int b)
  {
      if (b == 0){throw DivideException();}
      cout << a / b << "\n";
  }
  
  int main()
  {
      try
      {
          divide(10, 0);
      }
      catch(const Exception &e)
      {
          cout << e.what() << "\n";
      }
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo12> .\demo4
  Divide Error
  ```

  







### 27. 智能指针



- 目的：改善传统指针存在的问题



- 传统指针存在的问题：
  - 需要手动管理内存
  - 容易发生内存泄漏
    - 忘记释放
    - 出现抛出异常
  - 释放后会变成野指针



- 智能指针的作用：
  - `auto_ptr`：C++98，存在缺陷，不能用于数组
  - `shared_ptr`：C++11
  - `unique_ptr`：C++11





#### 27.1 智能指针基本使用



- 代码示例：

  ```c++
  #include <iostream>
  #include <memory>
  using namespace std;
  
  class Person
  {
  private:
      int m_age;
  
  public:
      Person(int age) : m_age(age){cout << "Person::Person(int)" << endl;}
      ~Person(){cout << "Person::~Person()" << endl;}        
  
      void run(){cout << "Person::run() " << m_age << endl;}
  };
  
  void test1()
  {
      shared_ptr<Person> p(new Person(10));
      p->run();
  }
  
  int main()
  {
      test1();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo13> .\demo1
  Person::Person(int)
  Person::run() 10
  Person::~Person()





#### 27.2 自定义智能指针



- 代码示例：

  ```c++
  #include <iostream>
  using namespace std;
  
  template<typename class_T>
  class fh_ptr
  {
  private:
      class_T *obj_ptr;
  
  public:
      fh_ptr(class_T *ptr) : obj_ptr(ptr){}
      ~fh_ptr()
      {
          if (obj_ptr == nullptr){return;}
          delete obj_ptr;
          obj_ptr = nullptr;
      }    
  
      class_T *operator->(){return obj_ptr;}
  };
  
  class Person
  {
  private:
      int m_age;
  
  public:
      Person(int age) : m_age(age){cout << "Person::Person(int)" << endl;}
      ~Person(){cout << "Person::~Person()" << endl;}        
  
      void run(){cout << "Person::run() " << m_age << endl;}
  };
  
  void test1()
  {
      fh_ptr<Person> p(new Person(10));
      p->run();
  }
  
  int main()
  {
      test1();
      
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo13> .\demo2
  Person::Person(int)
  Person::run() 10
  Person::~Person()
  ```

  



#### 27.3 shared_ptr



##### 27.3.1 shared_ptr原理



- 一个`shared_ptr`会对一个对象产生强引用
- 每个对象都会有一个对应的强引用计数，记录着当前的对象被多少`shared_ptr`强引用
  - 可以通过`shared_ptr`的`use_count`函数获得强引用计数
- 当有一个新的`shared_ptr`指向对象时，对象的强引用计数会`加1`
- 当一个`shared_ptr`销毁时，对象的强引用计数`减1`
- 当一个对象的强引用计数`为0`时，对象就会自动销毁





##### 27.3.2 shared_ptr循环引用



###### 27.3.2.1 演示循环引用问题



- 循环引用的问题：

  - `shared_ptr`是`强引用`智能指针

  - 发生两个类的对象相互引用，产生循环引用

  - 循环引用会产生栈空间的智能指针对象销毁后，指向堆区的对象不会被销毁



- 代码示例：`演示循环引用的问题`

  ```c++
  #include <iostream>
  #include <memory>
  using namespace std;
  
  class Person;
  
  class Car
  {
  public:
      shared_ptr<Person> m_person;
      Car(){cout << "Car::Car()\n";}
      ~Car(){cout << "Car::~Car()\n";}
  };
  
  class Person
  {
  public:
      shared_ptr<Car> m_car;
      Person(){cout << "Person::Person()\n";}
      ~Person(){cout << "Person::~Person()\n";}
  };
  
  void test()
  {
      shared_ptr<Person> person(new Person);
      shared_ptr<Car> car(new Car);
  
      person->m_car = car;
      car->m_person = person;
  }
  
  int main()
  {
      test();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo13> .\demo3
  Person::Person()
  Car::Car()
  ```





###### 27.3.2.2 解决循环引用问题



- `weak_ptr`
  - 会对对象产生`弱引用`
  - 解决`shared_ptr`的循环引用问题



- 代码示例：`解决循环引用问题`

  ```c++
  #include <iostream>
  #include <memory>
  using namespace std;
  
  class Person;
  
  class Car
  {
  public:
      // 只需要其中一个 是 弱引用 即可
      weak_ptr<Person> m_person;
      Car(){cout << "Car::Car()\n";}
      ~Car(){cout << "Car::~Car()\n";}
  };
  
  class Person
  {
  public:
      shared_ptr<Car> m_car;
      Person(){cout << "Person::Person()\n";}
      ~Person(){cout << "Person::~Person()\n";}
  };
  
  void test()
  {
      shared_ptr<Person> person(new Person);
      shared_ptr<Car> car(new Car);
  
      person->m_car = car;
      car->m_person = person;
  }
  
  int main()
  {
      test();
  
      return 0;
  }
  ```

- 打印结果：

  ```powershell
  PS C:\Users\Admin\Desktop\Project\Demo13> .\demo3
  Person::Person()
  Car::Car()
  Person::~Person()
  Car::~Car()
  ```







#### 27.4 unique_ptr



- 同样是`强引用`，但可以确保同一时间只有`一个指针`指向对象

- 当`unique`销毁时，指向的对象也就自动销毁

- 使用`std::move`函数转移`unqiue_ptr`的所有权

  ```c++
  unique_ptr<A> a1;
  unique_ptr<A> a2(new A);
  a1 = std::move(a2)
  ```

  
