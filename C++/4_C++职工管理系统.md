# C++职工管理系统



### 1. 管理系统需求



系统需求：

- 职工管理系统可以用来管理公司内所有员工的信息
- 公司职工分三类：普通员工，经理，老板；
- 显示员工信息：显示职工编号，职工姓名，职工岗位
- 职责：
  - 普通员工职责：完成经理的任务
  - 经理职责：完成老板的任务
  - 老板：管理所有事务

管理系统需要的功能：

- 退出管理程序：退出当前管理系统
- 增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号，姓名，部门编号
- 显示职工信息：显示公司内部所有职工的信息
- 删除离职职工：按照编号删除指定的职工
- 修改职工信息：按照编号修改职工个人信息
- 查找职工信息：按照职工的编号或者职工的姓名进行查找相关人员信息
- 按照编号排序：按照职工编号，进行排序，排序规则由用户指定
- 清空所有文档：清空文件中记录的所有职工信息（清空前需要确认，防止误删）



### 2. 创建管理类



- 管理类的内容：
  - 用户的沟通菜单界面
  - 对职工增删改查的操作
  - 与文件的读写交互



#### 2.1 创建文件

- Clion中创建
  - 头文件：`workerManager.h`
  - 源文件：`workerManager.cpp`
  - 主文件：`StaffManagerSystem_Main.cpp`
  - `CMakeList.txt`



#### 2.2 创建管理类文件

- `CMakeList.txt`

  ```txt
  cmake_minimum_required(VERSION 3.19)
  project(StaffManagementSystem)
  
  set(CMAKE_CXX_STANDARD 14)
  
  add_executable(StaffManagementSystem StaffManagerSystem_Main.cpp workerManager.h workerManager.cpp)
  ```

- `workerManager.h`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H
  #define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H
  
  #include <iostream>
  
  using namespace std;
  
  class WorkerManager
  {
  public:
      WorkerManager();
      ~WorkerManager();
  };
  
  #endif //STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H
  ```

- `workerManager.cpp`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  #include "workerManager.h"
  
  WorkerManager::WorkerManager()
  {
  
  }
  
  WorkerManager::~WorkerManager()
  {
  
  }
  ```

- `StaffManagerSystem_Main.cpp`

  ```c++
  #include <iostream>
  #include "workerManager.h"
  
  int main()
  {
      cout << "Hello, World!" << endl;
      return 0;
  }
  ```

  



### 3. 菜单功能



- 功能描述：与用户沟通的界面



#### 3.1 添加成员函数



- 在`workerManager.h`中的`WorkerManager`类中添加成员函数：`void Show_Menu();`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #ifndef STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H
  #define STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H
  #define wm workerManager
  #include <iostream>
  
  using namespace std;
  
  class WorkerManager
  {
  public:
      WorkerManager();
      ~WorkerManager();
  
      // 显示菜单
      void Show_Menu();
  };
  
  #endif //STAFFMANAGEMENTSYSTEM_WORKERMANAGER_H
  ```



#### 3.2 菜单功能实现



- 在管理类 `workerManager.cpp` 中实现具体 `Show_Menu()` 函数

  ```c++
  void WorkerManager::Show_Menu()
  {
      cout << "======================" << endl;
      cout << "====员工管理系统主菜单====" << endl;
      cout << "=====0.退出管理系统=====" << endl;
      cout << "=====1.增加职工信息=====" << endl;
      cout << "=====2.显示职工信息=====" << endl;
      cout << "=====3.删除离职职工=====" << endl;
      cout << "=====4.修改职工信息=====" << endl;
      cout << "=====5.查找职工信息=====" << endl;
      cout << "=====6.按照编号排序=====" << endl;
      cout << "=====7.清空所有文档=====" << endl;
      cout << "======================" << endl;
      cout << endl;
  }
  ```



#### 3.3 测试菜单功能



- 在`StaffManagerSystem_Main.cpp`中进行测试

  ```c++
  #include <iostream>
  #include "workerManager.h"
  
  int main()
  {
      WorkerManager workerManager;
      wm.Show_Menu();
      return 0;
  }
  ```



### 4. 退出功能



#### 4.1 提供菜单功能接口



- 在main函数中提供分支选择，提供菜单界面每个功能的接口

- 先创建一个`StaffManagerSystem_Main.cpp`中的函数`showMenu(){};`

  ```c++
  #include <iostream>
  #include "workerManager.h"
  
  void showMenu()
  {
          // 初始选择
      int choice = 0;
  
      // 生成 管理界面 对象
      WorkerManager workerManager;
      // 调用 菜单界面
      ReShowMenu:
      wm.Show_Menu();
      cout << "功能选择 >> ";
      cin >> choice;
  
      // 菜单界面的功能选择分支
      switch (choice)
      {
          case 0: // 0.退出管理系统
              wm.exitSystem();
              break;
          case 1: // 1.增加职工信息
              break;
          case 2: // 2.显示职工信息
              break;
          case 3: // 3.删除离职职工
              break;
          case 4: // 4.修改职工信息
              break;
          case 5: // 5.查找职工信息
              break;
          case 6: // 6.按照编号排序
              break;
          case 7: // 7.清空所有文档
              break;
          default: // 0 ~ 7 之外任意值，清空，重来菜单界面
              system("cls");
              goto ReShowMenu;
      }
  }
  
  int main()
  {
      showMenu();
      return 0;
  }
  ```



#### 4.2 实现退出功能



- 在`workerManager.h`中提供退出系统的成员函数 `void exitSystem();`

- 在`workerManager.cpp`中具体实现功能

  ```c++
  // 0.退出管理系统
  void WorkerManager::exitSystem()
  {
      cout << "员工管理系统-退出" << endl;
      exit(0);
  }
  ```



### 5. 创建职工类



#### 5.1 创建职工抽象类



- 职工分类：
  - 普通员工
  - 经理
  - 老板
- 将三种职工抽象到一个类`Worker`中，利用多态管理不同职工类
- 职工的属性：
  - 职工编号
  - 职工姓名
  - 职工部门编号
- 职工行为：
  - 岗位职责信息描述
  - 获取岗位名称

- 创建头文件 `worker.h`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #ifndef STAFFMANAGEMENTSYSTEM_WORKER_H
  #define STAFFMANAGEMENTSYSTEM_WORKER_H
  
  #include <iostream>
  
  using namespace std;
  
  // 职工抽象类
  class Worker
  {
  public:
      int worker_ID; // 职工ID
      string worker_Name; // 职工姓名
      int worker_DepartID; // 职工部门编号
  
      // 获得 职工的信息
      virtual void getWorkerInfo() = 0;
  
      // 获得 职工部门的岗位名称
      virtual void getWorkerDepartName() = 0;
  };
  
  #endif //STAFFMANAGEMENTSYSTEM_WORKER_H
  ```



#### 5.2 创建普通员工类



- 普通员工继承职工抽象类，并重写父类中的纯虚函数
- 在头文件和源文件的文件夹中创建`employee.h`和`employee.cpp`



- `employee.h`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #ifndef STAFFMANAGEMENTSYSTEM_EMPLOYEE_H
  #define STAFFMANAGEMENTSYSTEM_EMPLOYEE_H
  
  #include "worker.h"
  #include <iostream>
  
  using namespace std;
  
  class Employee : public Worker
  {
  public:
      // 初始化 员工 构造函数
      Employee(int w_Id, string w_Name, int w_DepartId);
  
      // 获得员工个人信息
      void getWorkerInfo() override;
  
      // 获得员工部门岗位名称
      void getWorkerDepartName() override;
  };
  
  #endif //STAFFMANAGEMENTSYSTEM_EMPLOYEE_H
  ```

- `employee.cpp`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  #include "../Header/employee.h"
  
  Employee::Employee(int w_Id, string w_Name, int w_DepartId)
  {
      this->worker_ID = w_Id;
      this->worker_Name = w_Name;
      this->worker_DepartID = w_DepartId;
  }
  
  void Employee::getWorkerInfo()
  {
      cout << "职工编号：" << this->worker_ID
           << "\t职工姓名：" << this->worker_Name
           << "\t岗位：" << this->getWorkerDepartName()
           << "\t岗位职责：完成经理的任务" << endl;
  }
  
  string Employee::getWorkerDepartName()
  {
      return string("普通员工");
  }
  ```



#### 5.3 创建经理类



- 经理类继承职工抽象类，并重写父类中虚函数
- 在头文件和源文件文件夹内，创建`manager.h`和`manager.cpp`



- `manager.h`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #ifndef STAFFMANAGEMENTSYSTEM_MANAGER_H
  #define STAFFMANAGEMENTSYSTEM_MANAGER_H
  
  #include "worker.h"
  #include <iostream>
  
  using namespace std;
  
  // 经理类
  class Manager : public Worker
  {
  public:
      // 初始化 经理 构造函数
      Manager(int w_Id, string w_Name, int w_DepartId);
  
      // 获得经理个人信息
      void getWorkerInfo() override;
  
      // 获得经理部门岗位名称
      string getWorkerDepartName() override;
  };
  
  #endif //STAFFMANAGEMENTSYSTEM_MANAGER_H
  ```

- `manager.cpp`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #include "../Header/manager.h"
  
  // 构造函数 初始化 经理 信息
  Manager::Manager(int w_Id, string w_Name, int w_DepartId)
  {
      this->worker_ID = w_Id;
      this->worker_Name = w_Name;
      this->worker_DepartID = w_DepartId;
  }
  
  // 获得 职工信息
  void Manager::getWorkerInfo()
  {
      cout << "职工编号：" << this->worker_ID
           << "\t职工姓名：" << this->worker_Name
           << "\t岗位：" << this->getWorkerDepartName()
           << "\t岗位职责：完成老板的任务" << endl;
  }
  
  // 获得 职工 岗位信息
  string Manager::getWorkerDepartName()
  {
      return string("经理");
  }
  ```



#### 5.4 创建老板类



- 老板类继承职工抽象类，并重写父类中虚函数
- 在头文件和源文件文件夹内，创建`boss.h`和`boss.cpp`



- `boss.h`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #ifndef STAFFMANAGEMENTSYSTEM_BOSS_H
  #define STAFFMANAGEMENTSYSTEM_BOSS_H
  
  #include "worker.h"
  #include <iostream>
  
  using namespace std;
  
  // 老板类
  class Boss : public Worker
  {
  public:
      // 初始化 老板 构造函数
      Boss(int w_Id, string w_Name, int w_DepartId);
  
      // 获得老板个人信息
      void getWorkerInfo() override;
  
      // 获得老板部门岗位名称
      string getWorkerDepartName() override;
  };
  
  #endif //STAFFMANAGEMENTSYSTEM_BOSS_H
  ```

- `boss.cpp`

  ```c++
  //
  // Created by Admin on 2021/6/26.
  //
  
  #include "../Header/boss.h"
  
  // 构造函数 初始化 老板 信息
  Boss::Boss(int w_Id, string w_Name, int w_DepartId)
  {
      this->worker_ID = w_Id;
      this->worker_Name = w_Name;
      this->worker_DepartID = w_DepartId;
  }
  
  // 获得 职工信息
  void Boss::getWorkerInfo()
  {
      cout << "职工编号：" << this->worker_ID
           << "\t职工姓名：" << this->worker_Name
           << "\t岗位：" << this->getWorkerDepartName()
           << "\t岗位职责：管理所有事务" << endl;
  }
  
  // 获得 职工 岗位信息
  string Boss::getWorkerDepartName()
  {
      return string("老板");
  }
  ```



#### 5.5 测试多态



- 在`StaffManagerSystem_Main.cpp`中添加测试函数`void demo(){};`

- 测试代码：

  ```c++
  #include <iostream>
  #include "../Header/workerManager.h"
  #include "../Header/worker.h"
  #include "../Header/employee.h"
  #include "../Header/manager.h"
  #include "../Header/boss.h"
  
  void demo()
  {
      Worker *worker = nullptr;
      
      worker = new Employee(1, "Normal_A", 1);
      worker->getWorkerInfo();
      
      worker = new Manager(2, "Manager_A", 2);
      worker->getWorkerInfo();
      
      worker = new Boss(3, "Boss_A", 3);
      worker->getWorkerInfo();
  }
  
  int main()
  {
      demo();
      return 0;
  }
  ```






### 6. 添加职工



- 功能描述：批次添加职工，并保存到文件中



#### 6.1 功能分析



- 分析：
  1. 用户在批量创建时，可能创建不同种类的职工
  2. 如果想将所有不同种类的职工都放在一个数组中，可以将所有员工的指针维护到一个数租里
  3. 如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用`Worker **`维护
- 堆区开辟以`Worker`类型的数组：`Worker ** = new Worker*[];`



#### 6.2 功能实现



- 在`WorkerManager.h`添加成员属性

  ```c++
  // 记录文件中的人数
  int worker_EmpNum;
  
      // 员工数组指针
      Worker ** worker_EmpArray;
  ```



- 在`WorkerManager.cpp`中构造函数初始化属性

  ```c++
  WorkerManager::WorkerManager()
  {
      // 初始化人数
      this->worker_EmpNum = 0;
  
      // 初始化数组指针
      this->worker_EmpArray = nullptr;
  }
  ```



- 在`WorkerManager.h`添加成员函数

  ```c++
  // 1.增加职工信息
   void addEmployee();
  ```



- 在`WorkerManager.cpp`中实现`void addEmployee(){}`

  ```c++
  // 1.增加职工信息
  void WorkerManager::addEmployee()
  {
      cout << "输入增加职工数量：>>";
      int addNum = 0;
      cin >> addNum;
  
      if (addNum > 0)
      {
          // 计算需要的空间大小 = 已用的空间 + 新需要的空间
          int newSize = this->worker_EmpNum + addNum;
  
          // 在 堆区中开辟 计算好大小的内存空间
          Worker **newSpace = new Worker *[newSize];
  
          // 将已有空间的内容存在新的内村空间中
          if (this->worker_EmpArray != nullptr)
          {
              for (int i = 0; i < this->worker_EmpNum; i++)
              {
                  newSpace[i] = this->worker_EmpArray[i];
              }
          }
  
          // 再将 需要添加的新内容加入
          for (int j = 0; j < addNum; j++)
          {
              int worker_ID; // 职工ID
              string worker_Name; // 职工姓名
              int worker_DepartID; // 职工部门编号
  
              cout << "输入第" << j + 1 << "位员工信息:" << endl;
              cout << "职工编号>>";
              cin >> worker_ID;
  
              cout << "职工姓名>>";
              cin >> worker_Name;
  
              cout << "职工岗位_ 1.员工_2.经理_3.老板>>";
              cin >> worker_DepartID;
  
              Worker *worker = nullptr;
  
              switch (worker_DepartID)
              {
                  case 1:
                      worker = new Employee(worker_ID, worker_Name, 1);
                      break;
                  case 2:
                      worker = new Manager(worker_ID, worker_Name, 2);
                      break;
                  case 3:
                      worker = new Boss(worker_ID, worker_Name, 3);
                      break;
                  default:
                      break;
              }
  
              newSpace[this->worker_EmpNum + j] = worker;
          }
          // 释放原本的空间
          delete[] this->worker_EmpArray;
  
          // 更改新空间的指向
          this->worker_EmpArray = newSpace;
  
          // 更新 新的个数
          this->worker_EmpNum = newSize;
  
          // 提示信息
          cout << "添加成功" << addNum << "名新职工" << endl;
      }
      else
      {
          cout << "需输入正确的数字" << endl;
      }
  
      system("cls");
  }
  ```



#### 6.3 测试添加



- 部分修改：

  1. `workerManager.h`

     ```c++
     #include <iostream>
     #include "worker.h"
     #include "employee.h"
     #include "manager.h"
     #include "boss.h"
     ```

  2. `StaffManagerSystem_Main.cpp`

     ```c++
     #include <iostream>
     #include "../Header/workerManager.h"
     
     void showMenu()
     {
         // 初始选择
         int choice = 0;
     
         // 生成 管理界面 对象
         WorkerManager workerManager;
     
         // 调用 菜单界面
         while (true)
         {
             wm.Show_Menu();
             cout << "功能选择 >> ";
             cin >> choice;
     
             // 菜单界面的功能选择分支
             switch (choice)
             {
                 case 0: // 0.退出管理系统
                     wm.exitSystem();
                     break;
                 case 1: // 1.增加职工信息
                     wm.addEmployee();
                     break;
                 case 2: // 2.显示职工信息
                     break;
                 case 3: // 3.删除离职职工
                     break;
                 case 4: // 4.修改职工信息
                     break;
                 case 5: // 5.查找职工信息
                     break;
                 case 6: // 6.按照编号排序
                     break;
                 case 7: // 7.清空所有文档
                     break;
                 default: // 0 ~ 7 之外任意值，清空，重来菜单界面
                     system("cls");
                     break;
             }
         }
     }
     
     int main()
     {
         showMenu();
         return 0;
     }
     ```

  3. `workerManager.cpp`

     ```c++
     WorkerManager::~WorkerManager()
     {
         if (this->worker_EmpArray != nullptr)
         {
             delete[] this->worker_EmpArray;
             this->worker_EmpArray = nullptr;
         }
     }
     ```




#### 6.4 补充：职工ID唯一性



- 确保职工文件内，每个职工的`worker_ID`是唯一的

- 在`workerManager.h`中添加成员函数`bool isEmployeeIDExist(int workerID);`

  ```c++
  // 排查添加的新职工的编号在文件中是否存在
  bool isEmployeeIDExist(int workerID);
  ```

- 在`workerManager.cpp`中实现成员函数`bool isEmployeeIDExist(int workerID){}`

  ```c++
  // 排查添加的新职工的编号在文件中是否存在
  bool WorkerManager::isEmployeeIDExist(int workerID)
  {
      bool isIDExist = true;
      for (int i = 0; i < this->worker_EmpNum; i++)
      {
          if (this->worker_EmpArray[i]->worker_ID == workerID)
          {
              isIDExist = true;
              break;
          }
          else
          {
              isIDExist = false;
          }
      }
      return isIDExist;
  }
  ```

- 修改`workerManager.cpp`中的成员函数`void addEmployee(){}`

  ```c++
  // 1.增加职工信息
  void WorkerManager::addEmployee()
  {
      cout << "<-- 已录入职工数量：" << worker_EmpNum << " -->" << endl;
      cout << "输入增加职工数量：>> ";
      int addNum = 0;
      cin >> addNum;
  
      if (addNum > 0)
      {
          // 计算需要的空间大小 = 已用的空间 + 新需要的空间
          int newSize = this->worker_EmpNum + addNum;
  
          // 在 堆区中开辟 计算好大小的内存空间
          Worker **newSpace = new Worker *[newSize];
  
          // 将已有空间的内容存在新的内村空间中
          if (this->worker_EmpArray != nullptr)
          {
              for (int i = 0; i < this->worker_EmpNum; i++)
              {
                  newSpace[i] = this->worker_EmpArray[i];
              }
          }
  
          // 再将 需要添加的新内容加入
          for (int j = 0; j < addNum; j++)
          {
              int worker_ID; // 职工ID
              string worker_Name; // 职工姓名
              int worker_DepartID; // 职工部门编号
              bool isExistID = true; // 新增的变量，用于判断文件中是否已存在某个ID
  
              // 在输入职工ID的地方，进行了修改
              // 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在
              // 存在就继续循环该语句，不存在再继续执行
              while (true)
              {
                  cout << "输入第" << j + 1 << "位员工信息:" << endl;
                  cout << "职工编号>> ";
                  cin >> worker_ID;
                  isExistID = isEmployeeIDExist(worker_ID);
  
                  if (isExistID)
                  {
                      cout << "编号已经存在" << endl;
                      system("pause");
                      system("cls");
                  }
                  else
                  {
                      break;
                  }
              }
  
              cout << "职工姓名>> ";
              cin >> worker_Name;
  
              cout << "职工岗位_ 1.员工_2.经理_3.老板>> ";
              cin >> worker_DepartID;
              cout << endl;
  
              Worker *worker = nullptr;
  
              switch (worker_DepartID)
              {
                  case 1:
                      worker = new Employee(worker_ID, worker_Name, 1);
                      break;
                  case 2:
                      worker = new Manager(worker_ID, worker_Name, 2);
                      break;
                  case 3:
                      worker = new Boss(worker_ID, worker_Name, 3);
                      break;
                  default:
                      break;
              }
  
              newSpace[this->worker_EmpNum + j] = worker;
          }
          // 释放原本的空间
          delete[] this->worker_EmpArray;
  
          // 更改新空间的指向
          this->worker_EmpArray = newSpace;
  
          // 更新 新的个数
          this->worker_EmpNum = newSize;
  
          // 更新 文件不在为假
          this->isFileEmpty = false;
  
          // 提示信息
          cout << "添加成功" << addNum << "名新职工" << endl;
  
          // 保存录入的职工信息到文本文件中
          this->saveNewToFile();
      }
      else
      {
          cout << "需输入正确的数字" << endl;
      }
      system("pause");
      system("cls");
  }
  ```

  



### 7. 文件交互



#### 7.1 写文件



- 功能描述：对文件进行读写
  - 在上一个添加功能中，只完成了将数据添加到内存中，程序结束数据将被回收
  - 需求给项目的文件管理类添加一个文件交互功能，将数据保存到文本中，进行写操作



##### 7.1.1 设定文件路径



- 首先是设定文件路径

- 路径的选择最好是项目内，采用相对路径，在项目目录下创建文件夹 `File`

- 在`workerManager.h`中添加宏常量，并包含头文件`fstream.h`

  ```c++
  #define WORKER_FILENAME "../File/workerFile.txt"
  #include <fstream>
  ```



##### 7.1.2 成员函数声明



- 在`workerManager.h`中添加成员函数`void saveNewToFile();`

  ```c++
  // 保持录入职工的信息到文件
  void saveNewToFile();
  ```



##### 7.1.3 保存文件实现



`workerManager.cpp`

```c++
// 保持录入职工的信息到文件
void WorkerManager::saveNewToFile()
{
    ofstream ofs;
    ofs.open(WORKER_FILENAME, ios::out);

    for (int i = 0; i < this->worker_EmpNum; i++)
    {
        ofs << this->worker_EmpArray[i]->worker_ID << " "
            << this->worker_EmpArray[i]->worker_Name << " "
            << this->worker_EmpArray[i]->worker_DepartID << endl;
    }

    ofs.close();
}
```





##### 7.1.4 保存文件测速



- 在`workerManager.cpp`实现的添加职工功能打印成功后面，添加保存文件的函数`void saveNewToFile();`

  ```c++
   // 提示信息
  cout << "添加成功" << addNum << "名新职工" << endl;
  
  / 保存录入的职工信息到文本文件中
   this->saveNewToFile();
  ```

  



#### 7.2 读文件



- 功能描述：将文件中的内容读取到程序中
- 上一个功能完成了在程序中将堆中的数据保存到文本文件中，但还需要一个程序启动时，读取文本文件数据到堆中的功能
- 同时需要完成清空文本文件的功能



- 构造函数初始化数据的情况分三种：
  1. 第一次使用，文件未创建
  2. 文件存在，数据被清空
  3. 文件存在，数据也存在



##### 7.2.1 文件未创建



- 在`workerManager.h`中添加成员变量，`bool isFileEmpty;` 来标记文件是否为空

  ```c++
  // 判断文件是否为空
  bool isFileEmpty;
  ```




- 修改`workerManager.cpp`中的构造函数

  ```c++
  WorkerManager::WorkerManager()
  {
      // 初始化 读文件对象
      ifstream ifs;
      ifs.open(WORKER_FILENAME, ios::in);
  
      // 文件不存在的情况
      if (!ifs.is_open())
      {
          cout << "文件不存在" << endl;
          this->worker_EmpNum = 0;
          this->worker_EmpArray = nullptr;
          // 初始化 文件 是空
          this->isFileEmpty = true;
          ifs.close();
          return;
      }
      
      // 初始化人数
      this->worker_EmpNum = 0;
  
      // 初始化数组指针
      this->worker_EmpArray = nullptr;
  
      // 判断文件是否为空
      this->isFileEmpty = false;
  }
  ```

- 确保项目中，没有`workerFile.txt`文件存在，运行时，可以看到打印结果，同时完成初始化



##### 7.2.2 文件存在且数据为空



- `workerManager.cpp`中，在构造函数中加入代码

  ```c++
  WorkerManager::WorkerManager()
  {
      // 初始化 读文件对象
      ifstream ifs;
      ifs.open(WORKER_FILENAME, ios::in);
  
      // 文件不存在的情况
      if (!ifs.is_open())
      {
          cout << "<-- 提示：职工文件不存在 -->" << endl;
          this->worker_EmpNum = 0;
          this->worker_EmpArray = nullptr;
          // 初始化 文件 是空
          this->isFileEmpty = true;
          ifs.close();
          return;
      }
  
      // 文件存在 数据为空
      string str;
      ifs >> str;
      if (ifs.eof())
      {
          cout << "<-- 提示：职工文件为空 -->" << endl;
          this->worker_EmpNum = 0;
          this->worker_EmpArray = nullptr;
          this->isFileEmpty = true;
          ifs.close();
          return;
      }
  }
  ```

- 同时，在文件存在时，文件判空变量`isFileEmpty`需要修改为`false`；

- 在`workerManager.cpp`中的`void WorkerManager::addEmployee()`中，进行更改

  ```c++
  // 更改新空间的指向
  this->worker_EmpArray = newSpace;
  
  // 更新 新的个数
  this->worker_EmpNum = newSize;
  
  // 更新 文件不在为空
  this->isFileEmpty = false;
  
  // 提示信息
  cout << "添加成功" << addNum << "名新职工" << endl;
  ```

- 此时先创建项目文件，可以手动在`File`文件夹内直接新建`workerFile.txt`；

- 也可以先运行项目，添加职工信息后，手动删除文件内的内容，再进行测速上面的代码



##### 7.2.3 文件存在且有数据



###### 7.2.3.1 获取记录的职工人数



- 在`workerManager.h`中添加成员函数`int getEmpNum();`

  ```c++
  // 获得记录职工人数
  int getEmpNum();
  ```

- 在`workerMananger.cpp`中实现功能

  ```c++
  // 获得记录职工人数
  int WorkerManager::getEmpNum()
  {
      ifstream ifs;
      ifs.open(WORKER_FILENAME, ios::in);
  
      // 存入 读到的数据
      int worker_ID;
      string worker_Name;
      int worker_DepartID;
      // 初始化 记录人数
      int empNum = 0;
  
      // 当 读文件操作对象 返回为真
      while (ifs >> worker_ID && ifs >> worker_Name && ifs >> worker_DepartID)
      {
          // 记录人数 +1
          empNum++;
      }
      ifs.close();
      
      return empNum;
  }
  ```

- 在`workerManager.cpp`的构造函数中继续添加测试代码

  ```c++
  // 文件存在 有数据
  // 获得文件已记录人数
  int empNum = this->getEmpNum();
  // 更新 记录人数
  this->worker_EmpNum = empNum;
  cout << "<-- 职工数量: " << empNum << " -->" << endl;
  ```

- 此时可以运行项目，添加数个职工信息后，再重新启动项目，即可看到测试数据



###### 7.2.3.2 初始化职工信息数组



- 根据职工的数据以及职工数据，初始化`workerManager.h`中的`Worker ** worker_EmpArray;`指针

- 在`workerManager.h`中添加成员函数`void initEmployee();`

  ```c++
   // 初始化职工
  void initEmployee();
  ```
  
- 在`workerManager.cpp`中实现`void initEmployee(){}`

  ```c++
  // 初始化职工
  void WorkerManager::initEmployee()
  {
      ifstream ifs;
      ifs.open(WORKER_FILENAME, ios::in);
  
      // 存入 读到的数据
      int worker_ID;
      string worker_Name;
      int worker_DepartID;
      // 初始化 记录人数
      int index = 0;
  
      // 当 读文件操作对象 返回为真
      while (ifs >> worker_ID && ifs >> worker_Name && ifs >> worker_DepartID)
      {
          Worker *worker = nullptr;
  
          // 根据 DepartID，创建不同职工对象
          if (worker_DepartID == 1)
          {
              worker = new Employee(worker_ID, worker_Name, worker_DepartID);
          }
          else if (worker_DepartID == 2)
          {
              worker = new Manager(worker_ID, worker_Name, worker_DepartID);
          }
          else
          {
              worker = new Boss(worker_ID, worker_Name, worker_DepartID);
          }
          // 生成职工对象后，存入职工数组中
          this->worker_EmpArray[index] = worker;
          index++;
      }
      ifs.close();
  }
  ```

- 在`workerManager.cpp`的构造函数中继续添加代码

  ```c++
  // 根据职工数量创建数组
  this->worker_EmpArray = new Worker *[this->worker_EmpNum];
  this->initEmployee();
  // 测试代码
  for (int i = 0; i <worker_EmpNum; i++)
  {
  	cout << "<-- 职工编号：" << this->worker_EmpArray[i]->worker_ID
  		<< "职工姓名：" << this->worker_EmpArray[i]->worker_Name
  		<< "职工部门：" << this->worker_EmpArray[i]->worker_DepartID
  		<< " -->" << endl;
  }
  ```





### 8. 显示职工



- 功能描述：显示已录入职工文件内所有的职工信息



#### 8.1 显示职工函数声明



- 在`workerManager.h`中添加成员函数`void showEmployeeInfo();`

  ```c++
  // 2.显示职工信息
  void showEmployeeInfo();
  ```



#### 8.2 显示职工函数实现



- 在`workerManager.cpp`中实现函数`void showEmployeeInfo(){}`

  ```c++
  // 2.显示职工信息
  void WorkerManager::showEmployeeInfo()
  {
      if (this->isFileEmpty)
      {
          cout << "职工文件不存在或记录为空" << endl;
      }
      else
      {
          for (int i = 0; i < worker_EmpNum; i++)
          {
              // 利用多态调用接口
              this->worker_EmpArray[i]->getWorkerInfo();
          }
      }
      system("cls");
  }
  ```

- 在`StaffManagerSystem_Main.cpp`中的`void showMenu(){}`中补充调用`showEmployeeInfo()`的代码

  ```c++
  case 2: // 2.显示职工信息
      wm.showEmployeeInfo();
      break;
  ```





### 9. 删除职工



- 功能描述：按照职工的编号进行删除职工操作



#### 9.1 职工是否存在函数声明



- 删除，修改，查找职工功能都需要先检查文件中是否存在职工

- 在`workerManager.h`中添加成员函数`int IsEmployeeExist(int workerID);`

  ```c++
  // 职工是否存在
  int isEmployeeExist(int workerID);
  ```





#### 9.2 职工是否存在函数实现



- 在`workerManager.cpp`中实现成员函数`int isEmployeeExist(){}`

  ```c++
  // 职工是否存在
  int WorkerManager::isEmployeeExist(int workerID)
  {
      // 默认index为职工的编号，-1是不存在
      int index = -1;
      for (int i = 0; i < this->worker_EmpNum; i++)
      {
          if (this->worker_EmpArray[i]->worker_ID == workerID)
          {
              index = i;
              break;
          }
      }
      // 返回 -1 表示不存在这个职工，其他表示找到了对应职工的ID编号
      return index;
  }
  ```

  



#### 9.3 删除职工函数声明



- 在`workerManager.h`中添加成员函数`void deletEmployee();`

  ```c++
  // 3.删除离职职工
  void deletEmployee();
  ```





#### 9.4 删除职工函数实现



- 在`workerManager.cpp`中实现成员函数`void deletEmployee(){}`

  ```c++
  // 3.删除离职职工
  void WorkerManager::deletEmployee()
  {
      // 先判断是否存在职工文件
      if (this->isFileEmpty)
      {
          cout << "职工文件不存在或记录为空" << endl;
      }
      else
      {
          int workerID = 0;
          cout << "输入需要删除的职工编号>> ";
          cin >> workerID;
  
          // 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号
          int workerIndex = isEmployeeExist(workerID);
          if (workerIndex != -1)
          {
              // 删掉指定数据后，数组数据需要数据前移
              for (int i = workerIndex; i < this->worker_EmpNum -1; i++)
              {
                  this->worker_EmpArray[i] = this->worker_EmpArray[i + 1];
              }
              // 没移动一个数据，数组后面需要移动的数据就少一个
              this->worker_EmpNum--;
              // 修改数据后，将更新的数据保存到文件中
              this->saveNewToFile();
              cout << "编号:" << workerIndex + 1 << " 职工已删除" << endl;
          }
          else
          {
              cout << "删除失败，职工编号错误" << endl;
          }
      }
      system("cls");
  }
  ```

  

- 在`StaffManagerSystem_Main.cpp`中添加删除职工的接口

  ```c++
  case 3: // 3.删除离职职工
      wm.deletEmployee();
      break;
  ```





### 10. 修改职工



- 功能描述：输入职工编号，删除文件中对应的职工信息



#### 10.1 修改职工函数声明



- 在`workerManager.h`中添加成员函数`void modifyEmployeeInfo();`

  ```c++
  // 4.修改职工信息
  void modifyEmployeeInfo();
  ```

  



#### 10.2 修改职工函数实现



- 在`workerManager.cpp`中实现成员函数`void modifyEmployeeInfo(){}`

  ```c++
  // 4.修改职工信息
  void WorkerManager::modifyEmployeeInfo()
  {
      if (this->isFileEmpty)
      {
          cout << "职工文件不存在或记录为空" << endl;
      }
      else
      {
          int workerID = 0;
          cout << "输入需要修改的职工编号>> ";
          cin >> workerID;
  
          // 通过isEmployeeExit()，确定并返回一个存在且有效的职工编号
          int workerIndex = isEmployeeExit(workerID);
          if (workerIndex != -1)
          {
              // 找到存在且有效的职工编号后，删除数组中对应的信息
              delete this->worker_EmpArray[workerIndex];
  
              int newWorker_ID; // 职工ID
              string newWorker_Name; // 职工姓名
              int newWorker_DepartID; // 职工部门编号
  
              cout << "查的编号:" << workerID << " 的职工" << endl;
              cout << "新的职工编号>> ";
              cin >> newWorker_ID;
  
              cout << "新的职工姓名>> ";
              cin >> newWorker_Name;
  
              cout << "新的职工岗位_ 1.员工_2.经理_3.老板>> ";
              cin >> newWorker_DepartID;
              cout << endl;
  
              Worker *worker = nullptr;
  
              switch (newWorker_DepartID)
              {
                  case 1:
                      worker = new Employee(newWorker_ID, newWorker_Name, 1);
                      break;
                  case 2:
                      worker = new Manager(newWorker_ID, newWorker_Name, 2);
                      break;
                  case 3:
                      worker = new Boss(newWorker_ID, newWorker_Name, 3);
                      break;
                  default:
                      break;
              }
  
              // 更新数据到数组中对应的编号
              this->worker_EmpArray[workerIndex] = worker;
  
              cout << "新编号:" << newWorker_ID << " 职工的信息，修改完成"
                   << " 新部门编号:" << this->worker_EmpArray[workerIndex]->worker_DepartID << endl;
          }
          else
          {
              cout << "修改失败，职工编号错误或不存在" << endl;
          }
      }
      system("cls");
  }
  ```

- 在`StaffManagerSystem_Main.cpp`中添加修改职工的接口

  ```c++
  case 4: // 4.修改职工信息
      wm.modifyEmployeeInfo();
      break;
  ```





### 11. 查找职工



- 功能描述：提供两种查找方式
  1. 按职工编号查找
  2. 按职工姓名查找



#### 11.1 查找职工函数声明



- 在`workerManager.h`中添加成员函数`void findEmployee();`

  ```c++
  // 5.查找职工信息
  void findEmployee();
  ```

  



#### 11.2 查找职工函数实现



- 在`workerManager.cpp`中实现成员函数`void findEmployee(){};`

  ```c++
  // 5.查找职工信息
  void WorkerManager::findEmployee()
  {
      if (this->isFileEmpty)
      {
          cout << "职工文件不存在或记录为空" << endl;
      }
      else
      {
          int findSwitch = 0;
          cout << "查找选择_1.编号_2.姓名>> ";
          cin >> findSwitch;
  
          if (findSwitch == 1)
          {
              int findWorkerID;
              cout << "查找的职工编号>> ";
              cin >> findWorkerID;
  
              // 判断输入的编号有效性
              int workerIndex = isEmployeeExist(findWorkerID);
              if (workerIndex != -1)
              {
                  cout << "查找成功" << endl;
                  cout << "职工信息: ";
                  this->worker_EmpArray[workerIndex]->getWorkerInfo();
              }
              else
              {
                  cout << "查找失败，职工编号错误或不存在" << endl;
              }
          }
          else if (findSwitch == 2)
          {
              string findWorkerName;
              cout << "查找的职工姓名>> ";
              cin >> findWorkerName;
  
              bool isFindByName = false;
              for (int i = 0; i < this->worker_EmpNum; i++)
              {
                  if (this->worker_EmpArray[i]->worker_Name == findWorkerName)
                  {
                      isFindByName = true;
                      cout << "查到职工: " << findWorkerName << " 职工编号: " << worker_EmpArray[i]->worker_ID << endl;
                      cout << "职工信息: ";
                      worker_EmpArray[i]->getWorkerInfo();
                  }
              }
              if (!isFindByName)
              {
                  cout << "查找失败，职工编号、姓名错误或不存在" << endl;
              }
          }
          else
          {
              cout << "输入正确的选择" << endl;
          }
      }
      system("cls");
  }
  ```

- 在`StaffManagerSystem_Main.cpp`中添加查找职工的接口

  ```c++
  case 5: // 5.查找职工信息
      wm.findEmployee();
      break;
  ```





### 12. 排序职工



- 功能描述：按照职工编号排序，可以依据用户选择进行升序排列和降序排列



#### 12.1 排序函数声明



- 在`workerManager.h` 中添加成员函数`void sortEmployeeByID();`

  ```c++
  // 6.按照编号排序
  void sortEmployeeByID();
  ```

  



#### 12.2 排序函数实现



- 在`workerManager.cpp`中实现成员函数`void sortEmployeeByID(){}`

  ```c++
  // 6.按照编号排序
  void WorkerManager::sortEmployeeByID()
  {
      if (this->isFileEmpty)
      {
          cout << "职工文件不存在或记录为空" << endl;
          system("pause");
          system("cls");
      }
      else
      {
          int switchSort = 0;
          cout << "依据编号，选择排序方式_1.升序排列_2.降序排列>> ";
          cin >> switchSort;
  
          for (int i = 0; i < this->worker_EmpNum; ++i)
          {
              int maxOrmin = i;
              for (int j = i + 1; j < this->worker_EmpNum; ++j)
              {
                  // 升序排列
                  if (switchSort == 1)
                  {
                      // 升序排列，如是指定下标的值 大于 遍历出的最小值，说明指定的不是最小的，把遍历的下标赋值给变量
                      if (worker_EmpArray[maxOrmin]->worker_ID > worker_EmpArray[j]->worker_ID)
                      {
                          maxOrmin = j;
                      }
                  }
                      // 降序排列
                  else if (switchSort == 2)
                  {
                      // 降序排列，如是指定下标的值 小于 遍历出的最大值，说明指定的不是最大的，把遍历的下标赋值给变量
                      if (worker_EmpArray[maxOrmin]->worker_ID < worker_EmpArray[j]->worker_ID)
                      {
                          maxOrmin = j;
                      }
                  }
                  else
                  {
                      cout << "输入正确的选择" << endl;
                  }
              }
  
              // 交换数据
              if (maxOrmin != i)
              {
                  Worker *temp = worker_EmpArray[i];
                  worker_EmpArray[i] = worker_EmpArray[maxOrmin];
                  worker_EmpArray[maxOrmin] = temp;
              }
          }
          cout << "排序成功" << endl;
          this->saveNewToFile();
          this->showEmployeeInfo();
      }
  }
  ```
  
- 在`StaffManagerSystem_Main.cpp`这补充接口调用

  ```c++
  case 6: // 6.按照编号排序
      wm.sortEmployeeByID();
      break;
  ```





### 13. 清空文件



- 功能描述：将文件记录数据清空



#### 13.1 清空文件函数声明



- 在`workerManager.h`中添加成员函数`void toEmptyFile();`

  ```c++
  // 7.清空所有文档
  void toEmptyFile();
  ```

  



#### 13.2 清空文件函数实现



- 在`workerManager.h`中实现成员函数`void toEmptyFile(){}`

  ```c++
  // 7.清空所有文档
  void WorkerManager::toEmptyFile()
  {
      if (this->isFileEmpty)
      {
          cout << "职工文件不存在或记录为空" << endl;
          system("pause");
          system("cls");
      }
      else
      {
          int switchNum = 0;
          cout << "确认清空文件_1.确认_2.取消>> ";
          cin >> switchNum;
  
          if (switchNum == 1)
          {
              // 打开模式 ios::trunc 如果存在文件 删除后 重新生成
              ofstream ofs(WORKER_FILENAME, ios::trunc);
              ofs.close();
  
              // 判断内存中堆区的是否存在 存在需要释放
              if (this->worker_EmpArray != nullptr)
              {
                  for (int i = 0; i < this->worker_EmpNum; i++)
                  {
                      if (this->worker_EmpArray[i] != nullptr)
                      {
                          delete this->worker_EmpArray[i];
                      }
                  }
                  this->worker_EmpNum = 0;
                  delete[] worker_EmpArray;
                  this->worker_EmpArray = nullptr;
                  this->isFileEmpty = true;
              }
              cout << "职工文件清空完成" << endl;
          }
          else if (switchNum == 2)
          {
              cout << "已取消清空职工文件" << endl;
  
          }
          else
          {
              cout << "输入正确的选择" << endl;
          }
      }
      system("pause");
      system("cls");
  }
  ```





#### 13.3 析构函数修改完善



- 析构函数内，先判断数组属性是否存在，存在改为NULL，之后删除对象

  ```c++
  WorkerManager::~WorkerManager()
  {
      if (this->worker_EmpArray != nullptr)
      {
          for (int i= 0; i < this->worker_EmpNum; i++)
          {
              if (this->worker_EmpArray[i] != nullptr)
              {
                  delete this->worker_EmpArray[i];
              }
          }
          delete[] this->worker_EmpArray;
          this->worker_EmpArray = nullptr;
      }
  }
  ```

  



#### 13.4 清空文件函数测试



- 在`StaffManagerSystem_Main.cpp`这补充接口调用

  ```c++
  case 7: // 7.清空所有文档
      wm.toEmptyFile();
      break;
  ```





### 14. 后期bug修复





#### 14.1 职工编号存在判断失误

- bug描述：
  - 清空文件后，重新添加职工，输入任意编号，都会判断职工编号已经存在

- bug修复：

  - 在`workerManager.h`这添加成员变量

    ```c++
    // 判断文件是否存在某个编号
    bool isIDExist;
    ```

  - 在`workerManager.cpp`中修改`bool WorkerManager::isEmployeeIDExist(int workerID){}`

    ```c++
    // 排查添加的新职工的编号在文件中是否存在
    bool WorkerManager::isEmployeeIDExist(int workerID)
    {
        if (this->isFileEmpty)
        {
            this->isIDExist = false;
        }
        else
        {
            for (int i = 0; i < this->worker_EmpNum; i++)
            {
                if (this->worker_EmpArray[i]->worker_ID == workerID)
                {
                    this->isIDExist = true;
                    break;
                }
                else
                {
                    this->isIDExist = false;
                }
            }
        }
        return this->isIDExist;
    }
    ```

  - 在`workerManager.cpp`中修改`void WorkerManager::addEmployee(){}`

    ```c++
    // 1.增加职工信息
    void WorkerManager::addEmployee()
    {
        cout << "<-- 已录入职工数量：" << worker_EmpNum << " -->" << endl;
        cout << "输入增加职工数量：>> ";
        int addNum = 0;
        cin >> addNum;
    
        if (addNum > 0)
        {
            // 计算需要的空间大小 = 已用的空间 + 新需要的空间
            int newSize = this->worker_EmpNum + addNum;
    
            // 在 堆区中开辟 计算好大小的内存空间
            Worker **newSpace = new Worker *[newSize];
    
            // 将已有空间的内容存在新的内村空间中
            if (this->worker_EmpArray != nullptr)
            {
                for (int i = 0; i < this->worker_EmpNum; i++)
                {
                    newSpace[i] = this->worker_EmpArray[i];
                }
            }
    
            // 再将 需要添加的新内容加入
            for (int j = 0; j < addNum; j++)
            {
                int worker_ID; // 职工ID
                string worker_Name; // 职工姓名
                int worker_DepartID; // 职工部门编号
                bool isExistID = true; // 新增的变量，用于判断文件中是否已存在某个ID
    
                // 在输入职工ID的地方，进行了修改
                // 每次输入ID，都要判断一次，输入的ID在职工文件中是否已经存在
                // 存在就继续循环该语句，不存在再继续执行之后的语句
                while (true)
                {
                    cout << "输入第" << j + 1 << "位员工信息:" << endl;
                    cout << "职工编号>> ";
                    cin >> worker_ID;
                    this->isIDExist = isEmployeeIDExist(worker_ID);
    
                    if (this->isIDExist)
                    {
                        cout << "编号已经存在" << endl;
                        system("pause");
                        system("cls");
                    }
                    else
                    {
                        break;
                    }
                }
    
                cout << "职工姓名>> ";
                cin >> worker_Name;
    
                cout << "职工岗位_ 1.员工_2.经理_3.老板>> ";
                cin >> worker_DepartID;
                cout << endl;
    
                Worker *worker = nullptr;
    
                switch (worker_DepartID)
                {
                    case 1:
                        worker = new Employee(worker_ID, worker_Name, 1);
                        break;
                    case 2:
                        worker = new Manager(worker_ID, worker_Name, 2);
                        break;
                    case 3:
                        worker = new Boss(worker_ID, worker_Name, 3);
                        break;
                    default:
                        break;
                }
    
                newSpace[this->worker_EmpNum + j] = worker;
            }
            // 释放原本的空间
            delete[] this->worker_EmpArray;
    
            // 更改新空间的指向
            this->worker_EmpArray = newSpace;
    
            // 更新 新的个数
            this->worker_EmpNum = newSize;
    
            // 更新 文件不在为假
            this->isFileEmpty = false;
    
            // 提示信息
            cout << "添加成功" << addNum << "名新职工" << endl;
    
            // 保存录入的职工信息到文本文件中
            this->saveNewToFile();
        }
        else
        {
            cout << "需输入正确的数字" << endl;
        }
        system("pause");
        system("cls");
    }
    ```

  - 在`workerManager.cpp`中的`void WorkerManager::toEmptyFile(){}`修改

    ```c++
    cout << "职工文件清空完成" << endl;
    this->isIDExist = false;
    ```

    

