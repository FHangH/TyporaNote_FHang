# 软件构件



## 2016 A

一、选择题

\1. 设计模式一般是用来解决什么问题的（ D  ）。

A．需求获取中业务领域知识获取     

B．测试用例的设计

C．编码中如何组织代码         

**D．同一问题的不同表象**



\2. 开闭原则的含义是一个软件实体（ A  ）。

**A．应该对扩展开发，对修改关闭**     

B．对修改开放，对扩展关闭

C．在应用子类的地方可以使用父类代替 

 D．应该尽可能的使用大粒度的类实现



\3. 以下不属于创建型设计模式的是（ B  ）。

A．工厂模式             

 **B．Proxy模式**

C．抽象工厂              

D．Builder模式



\4. 在应用程序开发中那种设计模式可以用于分离出算法（ A  ）。

**A.策略模式**              

B.中介模式

C.组合模式             

 D.适配器模式



\5. 下列属于结构型设计模式的是（ C  ）。

A．工厂模式            

  B．中介模式

**C．组合模式**             

 D．命令模式



\6. 不和陌生人说话（ B  ）是的通俗表示表述。

A．接口隔离原则            

**B. 迪米特法则**

C. 开闭原则             

 D. 依赖倒置原则



\7. 下列属于面向对象基本原则的是（ C  ）

A. 继承             

 B. 封装

**C. 里氏代换**           

D. 都不是



\8. 要依赖于抽象，不要依赖具体。即针对接口编程，不要针对实现编程,是（ D  ）的表述。  

A. 开-闭原则           

 B. 接口隔离原则

C. 里氏代换原则        

  **D. 依赖倒转原则**



\9. 设计模式的两大主题是（ D  ）

A. 系统的维护与开发       

B. 对象组合与类的继承
 C. 系统架构与系统开发     

 **D. 系统复用与系统扩展**



\10. 以下对"开-闭"原则的一些描述错误的是? （ A ）

**A. "开-闭"原则与"对可变性的封装原则"没有相似性.**

B. 找到一个系统的可变元素,将它封装起来,叫"开-闭"原则

C. 对修改关闭: 是其原则之一

D. 从抽象层导出一个或多个新的具体类可以改变系统的行为,是其原则之一



\11. 以下意图那个是用来描述SINGLETON（单例模式）? （ B  ）

A. 将一个类的接口转换成客户希望的另外一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

**B. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。**

C. 定义一系列算法，并把他们分装起来， 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

D. 用一个中介对象来封装一系列的对象交互。



\12. 以下意图那个是用来描述COMPOSITE（组合模式）? （ C  ）

A. 为其他对象提供一种代理以控制对这个对象的访问。

B. 运用共享技术有效地支持大量细粒度的对象。

**C. 将对象组合成树形结构以表示 “部分-整体” 的层次结构。**

D. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。



\13. 以下意图那个是用来描述 FACADE（外观模式）?( A )

**A. 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。**

B. 定义一个用于创建对象的接口，让子类决定实例化哪一个类。

C. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

D. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。



\14. 以下意图那个是用来描述 VISITOR（访问者模式）?( B )

A. 定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**B. 表示一个作用于某对象结构中的各元素的操作。**

C. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

D. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。



\15. 设计模式的原理? ( C )

A. 面对实现编程           

B. 面向对象编程

**C. 面向接口编程**         

 D. 面向组合编程



二、填空题

 \1. 工厂模式分为 **简单工厂、工厂模式、抽象工厂** 三种类型。

 \2. 创立型模式的根本意图是要把（**对象的创建**）和（**使用分离**）的责任进行分离，从而降低系统的（耦合度）。

 \3. MVC模型的基本工作原理是基于（**观察者**）模式，实现是基于（**命令**）模式。

 \4. 设计模式的基本要素有： **名字、意图 、问题 、方案、参与者与协作者 、实现、一般性结构**

 \5. 接口是可以在整个模型中反复使用的一组行为，是一个没有（**属性**）而只有（**方法**）的类。

 \6. 软件体系结构是指一个系统的有目的的设计和规划，这个设计规划既不描述（**活动**），也不描述（**系统怎么开发**），它只描述系统的（**组成元素**）及其相互的交互协作。



三、简答题

 \1. 什么是设计模式？设计模式目标是什么？

**设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。**

**使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码可靠性**

 

 \2. 设计模式中一般都遵循的原则有什么？

**开闭原则、根据场景进行设计原则、优先组合原则、包容变化原则**



 \3. 在MVC模型中M、V、C分别指什么？简述它们之间的关系？

**M: 模型(Model), V:视图(View) C:控制Controller)。**

**Model层实现系统中的业务逻辑，通常可以用JavaBean或EJB来实现。 View层用于与用户的交互，通常用JSP来实现。 Controller层是Model与View之间沟通的桥梁，它可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。**

 

 \4. 面向对象系统中功能复用的两种最常用技术是什么？

**类继承和对象组合**

 

 \5. 只根据抽象类中定义的接口来操纵对象有什么好处？

   **客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口**

   **客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。**

 

四、应用题

 \1. 画出工厂方法模式的结构图。什么情况下适合使用工厂方发模式？（8分）  

 > Interface Product
 >
 >​    Interface ConcreteProduct 实现 Product
 >
 >​    Class Creator --> product FactoryMethod()
 >
 >​                 		 -->  void AnOperation()
 >
 >​    ConcreteCreator 继承 Creator à concreteproduct FactoryMethod() overide

 

**其中product：为工厂模式所要创建的对象类型定义一个接口。**

**Concrete product:实现product接口。**

**Creator：声明工厂方法（factory method）返回值为product的一个对象。**

**Concrete creator：覆写factory Method()，返回值为concrete product 的一个具体实例。**



1) **当客户程序不需要知道要使用对象的创建过程。** 

2) **客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。**

 

\2. 请用命令设计模式实现下图所示系统（12分）

题目：发送者（开关）--- 命令（电线）-- 接收者（电灯）



```java
public abstract class Command 
{
  protected Appliance appliance;

  public Command(Appliance appliance)
  {
      this.appliance=appliance;
  }

  abstract public void excute();
} 
```



```java
interface Appliance 
{
  public void on();
  public void off();
}
```



## 2016 B

一、选择题

\1. 对于依赖倒转的表述错误的是（ D ）

A. 依赖于抽象而不依赖于具体，也就是针对接口编程。
 B. 依赖倒转的接口并非语法意义上的接口，而是，一个类对其他对象进行调用时，所知道的方法集合。
 C. 从选项B的角度论述，一个对象可以有多个接口。
 **D. 此题没有正确答案。**



\2. 以下意图那个是用来描述桥接模式? （ B  ）

A. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**B. 将抽象部分与它的实现部分分离，使它们都可以独立地变化。**

C. 将一个复杂对象的构建与它的表示分离，使得同样构建过程可以创建不同的表示。

D. 动态地给一个对象添加一些额外的职责。



\3. 以下属于属于创建型设计模式的是（ C  ）。

A．外观模式               

B．中介模式

**C．抽象工厂**              

 D．命令模式



\4. 对象组合的有点表述不当的是（ D  ）

A. 容器类仅能通过被包含对象的接口来对其进行访问。

B. “黑盒” 复用，封装性好，因为被包含对象的内部细节对外是不可见。

C. 通过获取指向其它的具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合

**D.造成极其严重的依赖关系。**



\5. 在应用程序开发中那种设计模式可以用于分离出算法（ A  ）。

**A. 策略模式**               

B. 中介模式

C. 组合模式             

 D. 适配器模式



\6. 下列不属于结构型设计模式的是（ A  ）。

**A．命令模式**               

B．适配器模式

C．组合模式             

 D．外观模式



\7. 当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用（ A  ）模式。

 **A.创建型**               

B.结构型

 C行为型               

 D.以上都可以



\8. 在观察者模式中，表述错误的是（ C  ）

A.观察者角色的更新是被动的。

B.被观察者可以通知观察者进行更新

**C.观察者可以改变被观察者的状态，再由被观察者通知所有观察者依据被观察者的状态进行**。

D.以上表述全部错误。



\9. 开闭原则的含义是一个软件实体（ A ）。

**A．应该对扩展开发，对修改关闭**      

B．对修改开放，对扩展关闭

C．在应用子类的地方可以使用父类代替 

  D．应该尽可能的使用大粒度的类实现



\10. 关于继承表述错误的是：（ D  ）

A.继承是一种通过扩展一个已有对象的实现，从而获得新功能的复用方法。

B.泛化类（超类）可以显式地捕获那些公共的属性和方法。特殊类（子类）则通过附加属性和方法来进行实现的扩展。

C.破坏了封装性，因为这会将父类的实现细节暴露给子类。

**D.继承本质上是“白盒复用”，对父类的修改，不会影响到子类。**



\11. 设计模式一般是用来解决什么问题的（ A  ）。

**A．同一问题的不同表象**        

 B．测试用例的设计

C．编码中如何组织代码          

D． 需求获取中业务领域知识获取的问题



\12. 以下意图那个是用来描述 ITERATOR(迭代器)? （ C  ）

A.使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。

B.用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**C.提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。**

D.运用共享技术有效地支持大量细粒度的对象。



\13. 下图结构图描述的是那种 模式? （ A  ）

**A.  ABSTRACT FACTORY（抽象工厂）**

B. FACTORY METHOD（工厂方法）
 C. BUILDER（生成器）

D. BRIDGE（桥接）



\14. 下图结构图描述的是那种模式? （ C  ）

A.  STRATEGY(策略)

B.  OBSERVER（观察者）

**C.  ADAPTER（适配器）**

D. BUILDER（生成器）



\15. 下列模式中,属于行为模式的是（ B  ）

 A. 工厂模式           

 **B. 观察者**

 C. 适配器            

 D. 以上都是



二、填空题

\1. 工厂模式分为 **简单工厂，工厂模式，抽象工厂** 三种类型。

\2. 创立型模式的根本意图是要把 **对象的创建** 和 **使用分离** 的责任进行分离，从而降低系统的 耦合度。

\3. 面向对象的七条基本原则包括： **开闭原则，里式代换原则，合成聚合原则，依赖倒转，迪米特法则，单一原则，接口隔离**

\4. 在存在继承关系的情况下，方法向 **超类** 方向集中，而数据向 **子类** 方向集中。

\5. 适配器模式，分为类的适配器和对象的适配器两种实现。其中类的适配器采用的是 **继承** 关系，而对象适配器采用的是 **组合聚合** 关系。

6． **单例模式** 模式确保某一个类仅有一个实例，并自行实例化并向整个系统提供这个实例。

7．**组合模式** 模式将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。

8．**外观模式** 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，为子系统中的一组接口提供一个一致的界面。

 

三、简答题

 \1. 设计模式具有哪三大特点？ 

  **可重用性, 可传授性, 名称，每个设计模式都有名称。**

 

 \2. 为什么面向对象的分析和设计中优先使用组合，而非继承？

  **继承关系有很多缺点，如果合理使用组合则可以有效的避免这些缺点，使用组合关系将系统对变化的适应力从静态提升到动态，而且由于组合将已有对象组合到了新对象中，因此新对象可以调用已有对象的功能。**

 

 3．单例模式的两种实现方法，并说明优缺点？

**懒汉式，在类被加载时，唯一的实例已经被创建。这个模式在java中很容易实现，在其他语言中很难.**

  **饿汉式，在类加载的时候不创建单例实体。只有在第一次请求实例的时候创建，并且只在第一次创建后不再创佳该类的实例**

 

 \4. 简述依赖例转原则的基本思想。请举出一个使用了软件依赖原则的软件设计模式，其中何处体现了依赖原则。

  **高层模块不应该依赖于低层模块，二者都应该依赖于抽象**

**抽象不应该依赖于细节，细节应该不依赖于抽象**

 

 \5. 列举两个可以使我们在程序中不必使用if…else结构的软件设计模式。使用软件设计模式是如何做到这一点的？
   **策略模式（strategy）和状态模式（state）**

  **策略模式是将不同算法（处理方法）封装到stategy类中，状态模式是将不同状态封装到state类中。二者都是通过，类中的子类，实现不同情况的调用，从而有效的替换充满在程序中的 if else 语句。**

 

四、综合题

 \1. 我们经常碰到这种需求：通过公共场合传递文件，文件是用明文写的，凡是拿到这个文件都能看懂，传递过程中又不希望别人能看懂，于希望对文件内容进行加密。因为信息是不是军事机密，我们仅仅是想不被别人看明白，外传递过程中，传递人几乎不懂计算机的加密算法，那么很简单了，我们选择简单的字符移位的方法来实现加密。

  请用外观模式实现这个文件传递过程，分别封装外观类，加密和解密类，文件存取类，客户端类。（Java语言或者类Java语言描述，语法可以不完全正确，但业务逻辑流程必须正确）



```java
public class FileWriter 
{
  public void write(String encryptStr,String fileNameDes) throws IOException, FileNotFoundException
  {
   System.out.println("处理后的文件");
   File fs=new File(fileNameDes);
      
   OutputStream outputStream=null;
   if (!fs.exists())fs.createNewFile();
      
   outputStream=new FileOutputStream(fs)
   byte[] str=encryptStr.getBytes();
      
   outputStream.write(str);
   outputStream.flush();
   outputStream.close();

  }
```



```java
public class FileReader 
{
  public String read(String fileNameSrc) throws FileNotFoundException, IOException
  {
   System.out.println("以字节为单位读取文件内容，一次读一个字节：");
   File fs=new File(fileNameSrc);

   String result = null;
   InputStream in=null;
   in= new FileInputStream(fs);
   byte[] bs=new byte[(int) fs.length()];

   in.read(bs);
   result=new String(bs);
   in.close();
   System.out.println(result);
   return result;
  }
}
```

 

```java
public class EncryptFacade
{
  	private FileReader reader;
  	private EncryptDencrypt enDencrypt;
  	private FileWriter writer;
  	public EncryptFacade() {
  	super();

   	this.reader = new FileReader();
   	this.enDencrypt = new EncryptDencrypt();
   	this.writer = new FileWriter();

	public void fileEncrypt(String fileNameSrc,String fileNameDes) throws IOException 
	{
   		String plainStr=reader.read(fileNameSrc);
   		String encryptStr=enDencrypt.encrypt(plainStr);
   		writer.write(encryptStr, fileNameDes);
	}

	public void fileDencrypt(String fileNameEncode,String fileNameDecode) throws IOException 
	{
   		String encryptText=reader.read(fileNameEncode);
   		String plainStr=enDencrypt.deencrypyt(encryptText);
   		writer.write(plainStr, fileNameDecode);
  	}
}
```



```java
public class EncryptDencrypt 
{
  public String encrypt(String plainText)
  {
      System.out.println("数据加密，将明文转换为密文:");
      String esString="";
      char[] chars=plainText.toCharArray();
      for (char c : chars)
      {
          char temp=(char)(Integer.valueOf(c)-5);
          esString=esString+temp;
      }
      System.out.println(esString);
      return esString;
  }

  public String deencrypyt(String encryptText) 
  {
      System.out.println("数据解密，将密文转换为明文:");
	String deString="";
	char[] chars=encryptText.toCharArray();
	for (char c : chars) 
    {
        char temp=(char)(Integer.valueOf(c)+5);
        deString=deString+temp;
    }
      System.out.println(deString);
      return deString;
  }
}
```



```java
public class Client 
{
   public static void main(String[] args) throws IOException {
   EncryptFacade f=new EncryptFacade();
   System.out.println("加密文件：");
   f.fileEncrypt("src.txt", "des.txt");
       
   System.out.println("解密文件：");
   f.fileDencrypt("des.txt", "dsrc.txt");
  }
}
```