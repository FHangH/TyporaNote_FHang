# 软件中间件



### 选择题（均是多选）

1、完整实现 EJB 规范的产品有（ BC ）。
A、Spring
**B、GlassFish**
**C、Tomee**
D、MyBatis

2、Spring中用于处理 HTTP 方法的资源注解是（ ACD ）。
**A、@PostMapping**
B、@ID
**C、@RequestBody**
**D、@PatchMapping**

3、Java NIO 中，下列哪个可供选择器监控的通道 IO 事件类型：（ A ）。
**A、SelectionKey.OP_READ**
B、SelectionKey.DENY
C、SelectionKey.CONNECT
D、SelectionKey.WRITE

4、Java 反射机制 API 的关键类是（C）
A、java.lang.Object
B、java.lang.reflect.Method
**C、java.lang.Class**
D、java.lang.reflect.Constructor

5、下列那些字段可以使得 HTTP GET 请求就具体化为条件获取（ C ）。
A、If-Recive-Since
B、If-Unmodified-Content
**C、If-Match**
D、If-Match-Date

6、Java Servlet 中用于声明一个类为 Servlet 的注解是（ A）。
**A、@WebServlet**
C、@Get
B、@Controller
D、@Post

7、 HTML DOM 模型中，获取网页中元素的方法有（ ABCD）。
**A、getElementById()**
**B、getElementsByName()**
**C、getElementByclassName()**
**D、getElementByTagName()**

8、下列属于 Java 通道类型的是（ BD）。
A、ServerBootstrap
**B、NioSocketChannel**
C、NioEventLoop
**D、AsynchronousSocketChannel**

9、 在 HTTP 响应消息中，下列哪种状态码可以表示请求资源状态未改变（D ）。
A、302
B、204
C、102
**D、304**

10、下列说法正确的是（ A ）。
**A、HTTP/2.0 的消息的以二进制数据进行传输的，结构比复杂。**
B、SOAP 协议的依托协议是 HTTP/2。
C、Netty 不能采用阻塞方式工作。
D、gRPC 协议是明文的，在消息传递过程中，结构比较简单。

11、属于消息中间件产品的是（ AB）。
**A、ActiveMQ**
**B、RocketMQ**
C、Dubbo3
D、MyBatis

12、下列那组件实现了 TCP/IP协议规范（ ABC）。
**A、Socket**
**B、Java Socket**
**C、WinSock**
D、Jfinal

13、Java 声明自定义注解的关键字是（ A ）。
**A、@interface**
B、class
C、interface
D、final

14、下面哪个属于 HTTP/1.1 协议的标准 METHOD（ AD ）。
**A、OPTIONS**
B、SELECT
C、UPDATE
**D、PUT**

15、指明 HTTP 响应中包含托挂的关键字是（D）。
A、CheckNum
B、ExtraInfo
C、Content-Trail
**D、Trailer**

16、JavaNIO 中，实现服务器的核心组件是（B）。
A、ServerSocket
**B、ServerSocketChanel**
C、Socket
D、SocketChanel

17、HTTP/1.1 协议 Request 的首行不包括哪类字段（B ）。
A、Method
**B、Status-Code**
C、Request-URI
D、HTTP-Version

18、HTTP 协议的消息主体内容编码有（ AB）。
**A、gzip**
**B、compress**
C、utf-8
D、en

19、实现跨域请求的方式有（ CD）。
A、隧道协议
B、PPTP
**C、JSONP**
**D、Web 代理**

20、实现 Java Servlet 规范的产品有（ AB）。
**A、TOMEE**
**B、GlassFish**
C、Apache2
D、nginx

21、属于数据库中间件产品的是（ BD）。
A、ActiveMQ
**B、SQLAlchemy**
C、MTS
**D、MyBatis**

22、在三层结构的分布式系统中，包含了系统的核心业务逻辑的是（D ）。
A、数据层
B、表示层
C、客户层
**D、中间层**

23、Java 接口文件的不应该出现内容是：（ C）。
A、interface
B、public
**C、函数的实现**
D、String

24、下面哪一个不属于 HTTP/1.1 协议的标准 METHOD（C ）。
A、OPTIONS
B、CONNECT
**C、UPDATE**
D、PUT

25、下面属于 RPC 技术和框架有（ AC ）。
**A、Dubbo/Dubbox**
B、SOAP
**C、Finagle**
D、MINA

26、Java 8 版本的 Java SE 提供 11 种内置注解，请问下列哪些不再其中（D ）。
A、@Runtime
B、@FuntionInterface
C、@SuppressWarnings
**D、@Table**

27、HTTP/1.1 协议 Response 的状态行不包括哪类字段（ AC ）。
**A、Method**
B、Status-Code
**C、Request-URI**
D、HTTP-Version

28、关于反射机制下列描述不正确的是（ D）。
A、在运行时判断任意一个对象所属的类
B、在运行时判断任意一个类所具有的成员变量和方法
C、生成动态代理
**D、Java 反射的主要实现包含在 javax.lang.reflect 包中**

29、下列哪种不是 Java I/O 的标准实现方式（ C）。
A、BIO
B、AIO
**C、Netty**
D、NIO

30、下列说法正确的是（ CD ）。
A、RPC 不能采用 UDP 作为其底层通信协议
B、SOAP 协议的底层协议是 TCP/IP
**C、RPC 是一种技术思想而非一种规范或协议**
**D、RPC 服务器启动时主动向注册中心登记自己的服务种类、服务方法、版本**

31、实现 Java Servlet 规范的产品有（ BC ）。
A、Hibernate
**B、GlassFish**
**C、Tomee**
D、MyBatis

32、Spring中可以处理指定 URL 中包含的一个或多个参数的注解是（ A ）。
**A、@PathVariable**
B、@ID
C、@RequestBody
D、@Data

33、属于 Java AIO 中核心的类是：（ A）。
**A、CompletionHandler**
B、ServerSocket
C、HashMap
D、Socket

34、下面哪一个不属于标准 HTTP/1.1 协议头的参数的是（ D）。
A、Last-Modified
B、User-Agent
C、Connection
**D、Length**

35、下面不属于 RPC 框架的是（D）。
A、Dubbo/Dubbox
B、gRPC
C、Finagle
**D、MINA**

36、Java 8 版本的 Java SE 提供 5 种内置注解，请问下列哪些是正确的（ BC ）。
A、@Runtime
**B、@Funtioninterface**
**C、@SuppressWarnings**
D、@Table

38、下列属于 Netty 通道类型的是（B）。
A、ServerBootstrap
**B、NioSocketChannel**
C、NioEventLoop
D、AsynchronousSocketChannel

39、在 HTTP 响应消息中，下列哪种状态码可以表示请求已经成功处理（ B）。
A、302
**B、204**
C、102
D、201

40、下列说法正确的是（B ）。
A、HTTP/1.1 的消息的以二进制数据进行传输的，结构比复杂。
**B、SOAP 协议的依托协议是 HTTP。**
C、Netty 不能采用阻塞方式工作。
D、HTTP/2 协议是明文的，在消息传递过程中，结构比较简单。

### 填空题

1、 软件的三大类型：**<单机>、<CS>、<BS>**。

2、 反射（Reflection）是程序的**<自我分析能力>**,通过反射可以确定类有哪些方法、有哪些构造方法以及有哪些成员变量。Java 语言提供了反射机制，通过反射机制能够**<动态读取一个类的信息>**；能够在运行时动态加载类，而不是在**<编译期>**。反射可以应用于框架开发，它能够从配置文件中读取配置信息动态加载类、**<创建对象>**，以及调用方法和成员变量。

3、 HTTP/1.1 协议的响应消息由**<响应行>、<响应头>、<响应体>**组成。

4、 实现 ORM 中间件重点处理**<从实体类生成数据库表>、<从数据库表生成实体类>、<实体类和数据库表中数据的自动转换>**自动化。
 
5、 Java NIO 的三个核心组件是：**<Channel（通道）>, <Buffer（缓冲区）>, <Selector（选择器）>**

6、在 HTTP/1.1 协议中，处理多事务的连接的方式有：**<并行连接>、<Keep-Alive>、<持久连接>、<管道>**。

7、常见的五种基本 I/O 模型，分别是：阻塞 I/O 模型、非阻塞 I/O 模型、**<IO 复用模型>、<信号驱动的 IO 模型和异步 IO 模型>**

8、Java 8 提供的元注解包括：@Documented、@Target、@Retention、**<@Inherited>、<@Repeatable>**

9、一个 HTTP 事务由一条**<请求消息>**和一条**<响应消息>**构成。

10、Reactor 模式由**<Reactor>和 <Handler>**两大角色组成。

11、 I/O 通信模型有：**<阻塞 I/O 模型>、<非阻塞 I/O 模型>、<IO 复用模型>、<信号驱动的 IO 模型>、<异步 IO 模型>**

12、Java BIO 和 NIO 的本质区别是，Java BIO 是面向**<流>**，NIO 是面向**<缓存区>**

13、Java NIO 的核心组件分别是: **<Selector>，<Channel>，<Buffer>**组成。

14、HTTP 响应的状态行由**<HTTP 协议版本号>，<状态码>, <状态消息>**构成。

15、Netty 的 Handler 分为两大类：**<Inbound> <Outbound>**。

16、在 HTTP/1.1 协议中，处理多事务的连接的方式有：**<并行连接>、<Keep-Alive>、<持久连接>、<管道>**

19、浏览器将 CORS 请求分成两类：**<简单请求>和 <非简单请求>**。

简答
1、 在 Java 中，NIO 和 BIO 的区别主要体现在那三个方面？

- BIO 是面向流的，NIO 是面向缓冲区的
- Java BIO 的各种流是阻塞的，Java NIO是非阻塞模式
- BIO 无选择器，NIO 有



2、 RESTful 架构风格背后的主要思想是什么？

- 统一接口：组件之间有统一的接口。
- RESTful web 服务是基于客户机/服务器的，不存储状态。
- 从客户机到服务器的请求的结果可以缓存在客户机中。
- 它具有基于超媒体的统一接口，具有自描述消息。
- 而且客户机和服务器并不知道它们之间的中间连接。



3、 AJAX 中包括哪些技术？

- HTML、css、dom、XMLHttpRequest、javascript
- 基于 Web 标准(XHTML + CSS)的展示
- 使用 DOM 进行动态显示和交互
- 使用 XMLHttpRequest 进行数据交换和相关操作
- 用 JS 可以控制 XMLHttpRequest 对象向服务器提出请求并处理响应，而不影响用户对页面的正常访问



4、 请简述 HTTP/1.1 协议 300 型响应码中几个重要的响应码，含义是什么？

- 300 同样的一个 URI，可以对应多个实际的资源
- 301 请求的 URL 已移走
- 302 请求的 URL 临时移走
- 303 此状态码也是重定向
- 307 此状态码也是重定向响应



5、 “序列化”和“反序列化”会涉及 POJO 的编码和格式化（Encoding & Format），目前
我们可选择的编码方式有几种？评价一个序列化框架的优缺点应该从那些方面着手？

1. 4 种，使用 JSON、基于 XML、使用 Java 内置的编码和序列化机制、开源的二进制的序列化/反序列化框架
2. 结果数据大小，原则上说，序列化后的数据尺寸越小，传输效率越高
3. 结构复杂度，这会影响序列化/反序列化的效率，结构越复杂，越耗时



6、简述 HTTP 协议请求的八个方法的名称及其功能。

- GET 表示我们要请求一个由 URI 指定的在服务器上的资源。
- PUT 方法 表示如果指定 URL 资源不存在就创建它，否则就修改它。
- POST 方法 表示要创建一个新的子资源，或者更新一个存在的资源。
- DELETE 表示我们要删除一个由 URI 指定的资源。
- HEAD 和 GET 一样，但是仅仅返回指定资源响应的头部分，而不必返回响应主体
- OPTIONS 查询目标资源支持 method 的清单。
- TRACE 查询到目标资源经过的中间节点。用于测试。
- CONNECT 建立一个到 URI 指定的服务器的隧道。



7、简述 java.lang.reflect 包中提供反射处理能力的几个类并说明其作用。

- Constructor 类：提供类的构造方法信息。
- Field 类：提供类或接口中成员变量信息。
- Method 类：提供类或接口成员方法信息。
- Array 类：提供了动态创建和访问 Java 数组的方法。
- Modifier 类：提供类和成员访问修饰符信息。



8、简述目前 Java 中常见的几种实现 RESTful 技术方案。

- 使用 Spring 的 RestTemplate
- 通过 Servlet 实现
- JAX-RS
- JAX-RS 即 Java API for RESTful Web Services



9、请简述 java.lang.Class 类和 java.lang.Object 的作用和区别。

- Class 类也是类的一种，只是名字和 class 关键字高度相似，用于 java 反射机制。
- Class 类的对象不能像普通类一样，以 new 的方式创建，它的对象只能由 JVM 创建，因为这个类没有 public 构造函数
- Class 类的作用是运行时提供或获得某个对象的类型信息，这些信息也可用于反射。
- Object 类是一切 java 类的父类，对于普通的 java 类，即便不声明，也是默认继承了 Object类。
- Object 类位于 java.lang 包中，java.lang 包包含着 Java 最基础和核心的类，在编译时会自动导入
- Object 类定义了线程同步与交互的一系列方法



11 简述 Java NIO 中使用 Buffer 类的基本步骤？

- （1）使用创建子类实例对象的 allocate()方法，创建一个 Buffer 类的实例对象。
- （2）调用 put 方法，将数据写入到缓冲区中。
- （3）写入完成后，在开始读取数据前，调用 Buffer.flip()方法，将缓冲区转换为读模式。
- （4）调用 get 方法，从缓冲区中读取数据。
- （5）读取完成后，调用 Buffer.clear()方法，将缓冲区转换为写入模式。



13、 请简述 HTTP/1.1 协议 200 型响应码中几个重要的响应码，含义是什么？

- 200 请求已经成功完成
- 201 指明请求成功且创建了一个资源
- 202 已接受请求，但尚未处理。
- 203 已成功处理了请求，但返回的信息可能来自另一来源。
- 204 成功处理了请求，但没有返回任何内容。
- 205 成功处理了请求，但没有返回任何内容。
- 206 为了支持大文件的分段下载



14、 简述 Reactor 模式的优点和缺点

- 优点:解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制
- 缺点：模型复杂



16、简述 Java 反射机制中获取 Java 类构造方法的函数，并说明其作用。

- 在 java 反射机制中，可以使用 Class 类的 getConstructors()函数来获取 java 类构造方法。
- 这个函数可以返回一个 Constructor 对象数组，可以用来查找、访问和调用 java 类的构造函数，从而实现对 java 类的动态构造和实例化。



18、列出 Java NIO 通道类中我们常用的文件处理和网络通信常用的通道类，并说明起作用。

- FileChannel：文件通道，用于文件的数据读写。
- SocketChannel：套接字通道，用于套接字 TCP 连接的数据读写。
- ServerSocketChannel：服务器套接字通道（或服务器监听通道），允许我们监听TCP 连接请求，为每个监听到的请求创建一个 SocketChannel 通道。
- DatagramChannel：数据报通道，用于 UDP 的数据读写。



19、简述哪些 HTTP 请求会产使用到 CORS 机制。

- 使用 XMLHttpRequest 或 Fetch API 进行跨站请求
- 网页字体
- WebGL 纹理
- 以 drawImage 绘制到 Canvas 画布上的图形
- CSS 样式表
- 指令码



### 程序综合题



1、补齐 HTTP Response 类程序中的缺失的代码。 ！！！！[]为答案！！！

```java
public int code = [200]; // 答案 200

this.len = html.getBytes().length;
[setHead()];// 答案 setHead()
bw.append(headInfo.toString());

switch (code)
case 200:
headInfo.append("[OK]");// 答案 "OK"
break;
case 404:
headInfo.append("[NOT FOUND]");// 答案 "NOT FOUND"
break;
case 505:
headInfo.append("[Server ERROR]");// 答案 "Server ERROR"
break;
headInfo.append([CRLF]);// 答案 CRLF
headInfo.append("[Date:]").append(LocalDateTime.now()).append(CRLF);// 答案 Date
headInfo.append("[Content-Type]:text/html;charset=UTF-8").append(CRLF);// 答案 Content-Type
headInfo.append("[Content-Length:]").append(space).append(this.len).append(CRLF).append(CRLF);// 答案 Content-Length

public void setCode(int code)
[this.code] = code;// 答案 this.code
```



2、  下面代码是 HTTP Request 解析类，请根据协议要求，补齐空格中必须填入的代码，注意合理利用已定义变量：  

```java
private final String CRLF = ["\n"];// 答案 "\n"

byte[] arr = new byte[20000];
int len = [this.is.read(arr)];// 答案 this.is.read(arr)

String requestInfo = [new String(arr, 0, len)];// 答案 new String(arr, 0, len)

String[] arr = url.split("\\?");
this.url = [arr[0]];// 答案 arr[0]
param = [arr[1]];// 答案 arr[1]

StringTokenizer token = new StringTokenizer(param,["&"]);// 答案 "&"

String key_value = (String) token.nextElement();
String[] ks = key_value.split(["="]);// 答案 "="

ks = Arrays.copyOf(ks, 2);
ks[1] = [null];// 答案 null

if (values == null)
return null;
else
return[values[0]];// 答案 values[0]

public String getUrl()
return [this.url];// 答案 this.url
```



3、补齐通用服务线程池 ServicePool 程序中的缺失的代码

```java
public class ServicePool<Job extends [Runnable]>// 答案 Runnable
    
private AtomicLong threadNum = [new AtomicLong()];// 答案 new AtomicLong()

for (int i = 0; i < workerNum; i++) {
MyWorker worker = new MyWorker();
[workerList.add(worker)];// 答案 workerList.add(worker)

jobsList.addLast(job);
System.out.println("剩余待处理请求个数：" + ServicePool.this.getJobsize());
[jobsList.notify()];// 答案 jobsList.notify()

public int getJobsize() {
return [jobsList.size()];// 答案 jobsList.size()

private class MyWorker implements Runnable {
private [volatile] boolean isRunning = true;// 答案 volatile

public void run() {
while ([isRunning]) {// 答案 isRunning
Job job = null;

try {
[jobsList.wait()];// 答案 jobsList.wait()
} catch (InterruptedException e) 

System.out.println("正在处理请求");
[job.run()];// 答案 job.run()
```



### 分析题

详述说明 RPC 框架中每个部分的功能

- **RPC** 架构主要包括三部分：  

1.   服务注册中心：负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。  服务提供者，提供服务接口定义与服务实现类。  
2.   服务消费者：通过远程代理对象调用远程服务。  
3.   服务提供者：启动后主动向服务注册中心**(Registry)**注册机器 **IP**、端口以及提供的服务列表：  服务消费者启动时向服务注册中心**(Registry)**获取服务提供方地址列表。  
4. 服务注册中心**(Registry).**可实现负载均衡和故障切换。