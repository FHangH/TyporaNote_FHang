# UE4 联网和多人游戏



**复制Replication**：在客户端服务器间同步数据和调用程序的过程



### 1. 网络概述



#### 1.1 尽早规划多人游戏



- 若项目可能需要多人游戏功能，则从项目开始阶段起，构建所有gameplay时都应将多人游戏功能考虑在内，便于进行调试和维护，且支持单人
- 若是单人游戏改为多人，重构无网络情况下编译的基本代码需要梳理整个项目，几乎所有gameplay都需要重新编写





#### 1.2 客户端-服务器模型



- **单人游戏或本地多人游戏**：

  - 游戏在 `独立`游戏上本地运行。玩家将输入连接到一台计算机，直接控制其上所有内容，而包括Actor、场景和各玩家的用户界面在内的所有游戏项目均存在于这台本地机器上

    

- **网络多人游戏**：

  - 虚幻引擎使用 `客户端-服务器`模型

  - 网络中的一台计算机作为 `服务器` 主持多人游戏会话，而所有其他玩家的计算机作为 `客户端` 连接到该服务器。然后，服务器与连接的客户端分享游戏状态信息，并提供一种客户端之间通信的方法

    

    **客户端和服务端**：

    - 在网络多人游戏中，游戏将在服务器（1）与多个与之连接的客户端（2）之间进行。服务器处理gameplay，客户端向用户显示游戏
    - 服务器是多人游戏实际发生的地方
    - 客户端会远程控制其在服务器上各自拥有的 `Pawn`， 发送过程调用以使其执行游戏操作
    - 服务器不会将视觉效果直接流送至客户端显示器。服务器会将游戏状态信息 **复制** 到各客户端，告知应存在的Actor、此类Actor的行为，以及不同变量应拥有的值
    - 客户端使用此信息，对服务器上正在发生的情况进行高度模拟





##### 1.2.1 客户端-服务器游戏范例



- 分别以`本地游戏`和`多人游戏`为范例，说明`GamePlay`的处理逻辑
- 本地游戏：玩家1
- 多人游戏：玩家2



| 本地游戏                                                     | 网络游戏                                                     |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| ![本地运行范例](https://docs.unrealengine.com/4.27/Images/InteractiveExperiences/Networking/Overview/LocalMultiplayerExample.jpg) | ![网络运行范例2](https://docs.unrealengine.com/4.27/Images/InteractiveExperiences/Networking/Overview/ClientServerExample.jpg) |
| `玩家1按下输入以发射武器`<br />玩家1的Pawn将发射其当前武器以响应此操作。<br />玩家1的武器生成发射物，并播放附带音效和视觉效果。 | `玩家1在本地机器上按下输入以发射武器`<br />玩家1的本地Pawn将武器发射命令传送给服务器上对应的Pawn。<br />玩家1在服务器上的武器生成发射物。<br />服务器告知所有连接的客户端各自生成玩家1发射物的副本。<br />玩家1在服务器上的武器告知所有客户端播放武器发射音效和视觉效果。 |
| `玩家1的发射物从武器中射出并前移`                            | `玩家1的发射物从在服务器上的武器中射出并前移`<br />此时，服务器告知所有客户端复制玩家1发射物发生的移动，因此各客户端上的玩家1发射物便相应移动。 |
| `玩家1的发射物撞击玩家2的Pawn`<br />碰撞将触发摧毁玩家1发射物的函数，对玩家2的Pawn造成伤害，并播放附带音效和视觉效果。<br />玩家2播放画面效果，作为对伤害的响应。 | `玩家1在服务器上的发射物撞击玩家2的Pawn`<br />碰撞触发摧毁服务器上玩家1发射物的函数。<br />服务器自动告知所有客户端各自摧毁玩家1发射物副本。<br />碰撞触发告知所有客户端播放附带碰撞音效和视觉效果的函数。<br />玩家2在服务器上的Pawn承受发射物碰撞造成的伤害。<br />玩家2在服务器上的Pawn告知玩家2客户端播放画面效果，作为对伤害的响应。 |



- **网络游戏中**：
  - 此类交互发生在多个不同场景，这一过程将在基础游戏交互（碰撞、移动、伤害）、美化效果（视觉效果和音效）和私人玩家信息（HUD更新）间进行划分。这三者各自与网络中的特定机器或机组关联
  - 此信息的复制过程并非完全自动，游戏编程时须指定要复制的信息和接收副本的机器
  - 主要的难点在于选择应复制的信息及方式，以向所有玩家提供一致的游戏体验，同时需最小化信息复制量，尽可能减少网络带宽占用率







#### 1.3 基本网络概念



##### 1.3.1 网络模式和服务器类型



- **网络模式**：
  - 描述了计算机与网络多人游戏会话的关系
  - 游戏实例可采用以下任意网络模式



| 网络模式     | 说明                                                         |
| :----------- | ------------------------------------------------------------ |
| `独立`       | 游戏作为服务器运行，不接受远程客户端连接<br />参与游戏的玩家必须为本地玩家<br />此模式用于单人游戏和本地多人游戏<br />其将运行本地玩家适用的服务器逻辑和客户端逻辑 |
| `客户端`     | 游戏作为网络多人游戏会话中与服务器连接的客户端运行<br />其不会运行服务器逻辑 |
| `聆听服务器` | 游戏作为主持网络多人游戏会话的服务器运行<br />其接受远程客户端中的连接，且直接在服务器上拥有本地玩家<br />此模式通常用于临时合作和竞技多人游戏 |
| `专属服务器` | 游戏作为主持网络多人游戏会话的服务器运行<br />其接受远程客户端中的连接，但无本地玩家，因此为了高效运行，其将废弃图形、音效、输入和其他面向玩家的功能<br />此模式常用于需要更固定、安全和大型多人功能的游戏 |



- 独立游戏服务器可同时作为服务器和客户端，为多人游戏创建的逻辑可在无需额外工作的情况下，在单人游戏中运行





##### 1.3.2 Actor复制



- **描述**：
  - 复制是指在网络会话中的不同机器间复制游戏状态信息
  - 若正确设置复制，将可同步不同机器的游戏实例
  - 在C++ Actor类中设置 `bReplicates` 变量，或将Actor蓝图的 `复制（Replicates）`设置设为 `true`，可启用给定类的Actor复制



###### 1.3.2.1 常见复制功能



| 复制功能                | 说明                                                         |
| :---------------------- | :----------------------------------------------------------- |
| **创建和销毁**          | 服务器上生成复制Actor的授权版本时，其会在所有连接客户端上自动生成远程代理。<br />其之后会将信息复制到这些远程代理。<br />若销毁授权Actor，则将自动销毁所有连接客户端上的远程代理。 |
| **移动复制**            | 若授权Actor启用了 **复制移动**，或将C++中的 `bReplicateMovement` 设为 `true`，其将自动复制位置、旋转和速度。 |
| **变量复制**            | 在指定为复制变量的值变更时，其将自动从授权Actor复制到其远程代理。 |
| **组件复制**            | Actor组件复制为其所属Actor的一部分。<br />组件内指定为复制变量将复制，而组件内调用的RPC将与Actor类中调用的RPC保持一致。 |
| **远程过程调用（RPC）** | RPC是传输到网络游戏中特定机器的特殊函数。<br />无论初始调用RPC的是哪台机器，其的实现仅在目标机器上运行。<br />此类RPC可指定为服务器（仅在服务器上运行）、客户端（仅在Actor的拥有客户端上运行）或NetMulticast（在连接会话的所有机器上运行，包括服务器）。 |



- 虽然创建、销毁和移动等常见使用可自动处理，但即使启用复制，其他所有gameplay功能也不会默认自动复制
- 必须根据游戏的需求明确指定要复制的变量和函数



`Actor`、`Pawn`和`角色`的部分常用功能不会复制：

- **骨架网格体** 和 **静态网格体** 组件
- **材质**
- **动画蓝图**
- **粒子系统**
- **音效发射器**
- **物理对象**





###### 1.3.2.2 网络角色和授权



- **描述**：
  - Actor的 **网络角色** 将决定网络游戏期间控制Actor的机器
  - **授权** Actor被认为可控制Actor的状态，并可将信息复制到网络多人游戏会话中的其他机器上
  - **远程代理** 是该Actor在远程机器上的副本，其将接收授权Actor中的复制信息，由 **Local Role** 和 **Remote Role** 变量进行追踪



| 网络角色     | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| **无**       | Actor在网络游戏中无角色，不会复制。                          |
| **授权**     | Actor为授权状态，会将其信息复制到其他机器上的远程代理。      |
| **模拟代理** | Actor为远程代理，由另一台机器上的授权Actor完全控制。<br />网络游戏中如拾取物、发射物或交互对象等多数Actor将在远程客户端上显示为模拟代理。 |
| **自主代理** | Actor为远程代理，能够本地执行部分功能，但会接收授权Actor中的矫正。<br />自主代理通常为玩家直接控制的actor所保留，如pawn。 |



- 虚幻引擎使用的默认模型是 **服务器授权**，意味着服务器对游戏状态固定具有权限，而信息固定从服务器复制到客户端
- 服务器上的Actor应具有授权的本地角色，而其在远程客户端上的对应Actor应具有模拟或自主代理的本地角色





###### 1.3.2.3 客户端拥有权



- 特定客户端机器上的 **PlayerController** 拥有网络游戏中的pawn
- Pawn调用纯客户端函数时，其将无视调用函数的机器，而仅指向拥有玩家的机器
- 将Actor的 **Owner** 变量设为特定Pawn，则通关关联，该Actor属于该Pawn的拥有客户端，并将纯客户端函数指向其拥有者的机器
- C++中的 `IsLocallyControlled` 函数，或蓝图中的 **Is Locally Controlled** 节点，以决定Pawn是否在其拥有客户端上
- 由于构造期间Pawn可能未指定控制器，因此避免在自定义Pawn类的构造函数中使用 `IsLocallyControlled`





###### 1.3.2.4 相关性和优先级



- **相关性**：用于决定是否需要在多人游戏期间复制Actor

  - 复制期间将剔除被认为不相关的actor，此操作可节约带宽，以便相关Actor可更加高效地复制
  - 若Actor未被玩家拥有，且不在玩家附近，将其被视为不相关，而不会进行复制
  - 不相关Actor会存在于服务器上，且会影响授权游戏状态，但在玩家靠近前不会向客户端发送信息
  - 覆盖 `IsNetRelevantFor` 函数以手动控制相关性，并可使用 `NetCullDistanceSquared` 属性决定成为相关Actor所需距离

  

- **优先级**：有时在游戏单帧内，没有足够带宽供复制所有相关Actor，因此，Actor拥有 **优先级(Priority)** 值，用于决定优先复制的Actor

  - Pawn和PlayerController的 `NetPriority` 默认为 **3.0**，从而使其成为游戏中最高优先级的Actor，基础Actor的 `NetPriority` 为 **1.0**
  - Actor在被复制前经历的时间越久，每次成功通过时所处的优先级便越高





##### 1.3.3 变量复制



- **描述**：授权Actor上复制变量的值变更时，其信息将自动从授权Actor发送到连接会话的远程代理

  - C++中使用对应 `UPROPERTY` 宏内的 `Replicated` 或 `ReplicateUsing` 说明符

  - 蓝图的细节面板中将它们指定为已复制，可将复制添加到变量和对象引用





###### 1.3.3.1 RepNotify



- **描述**：可指定在Actor成功接收特定变量的复制信息时要调用的 **RepNotify** 函数

  - RepNotify仅在变量更新时本地触发
  - 触发gameplay逻辑响应授权Actor上的变量更改时，使用RepNotify可减少开销
  - 在C++中使用变量的 `UPROPERTY` 宏的 `ReplicatedUsing` 说明符可访问此功能
  - 蓝图中变量的复制设置以使用RepNotify

  

- **补充**：由于RepNotify可添加到需复制的变量中，而无需考虑其他gameplay功能，创建额外网络调用时刻节约大量带宽，因此RepNotify比RPC或复制函数更加好用







##### 1.3.4 远程过程调用(RPC)



- **描述**：远程过程调用也称为复制函数
  - 可在任何机器上进行调用，但会指示其的实现在与网络会话连接的特定机器上发生
  - 有三种类型的RPC



| RPC类型          | 说明                                                         |
| :--------------- | :----------------------------------------------------------- |
| **Server**       | 仅在主持游戏的服务器上调用。                                 |
| **Client**       | 仅在拥有该函数所属Actor的客户端上调用。若Actor无拥有连接，将不会执行此逻辑。 |
| **NetMulticast** | 在与服务器连接的所有客户端及服务器本身上调用。               |



**蓝图：**

- CustomEvent 的 Replicates 选项设置为其中一个
  - Run On Server
  - Run On Owning Client
  - Net MultiCast
- 要勾选`Reliable`



**C++：**

- 将一个自定义的函数声明为RPC，需要添加反射`UFUNCTION()`
  - Server
  - Client
  - NetMultiCast
- 额外添加`Reliable`
- 其代码将在代码实现中使用后缀 `_Implementation`



- **ExampleClass.h**

  ```c++
  //服务器RPC MyFunction的声明。
  UFUNCTION(Server, Reliable, WithValidation)
  void MyFunction(int myInt);
  ```

- **ExampleClass.cpp**

  ```c++
  //服务器RPC MyFunction的实现。
  void AExampleClass::MyFunction_Implementation(int myInt)
  {
      //游戏代码在此。
  }
  ```

  



###### 1.3.4.1 可靠性



- **描述**：必须将RPC指定为 **可靠** 或 **不可靠**

  - **不可靠**：

    - 不可靠RPC无法保证必会到达预定目的地，但其发送速度和频率高于可靠的RPC
    - 最适用于对gameplay而言不重要或经常调用的函数
    - 例如，由于Actor移动每帧都可能变换，因此使用不可靠RPC复制该Actor移动

  - **可靠**：

    - 可靠的RPC保证到达预定目的地，并在成功接收之前一直保留在队列中
    - 最适合用于对gameplay很关键或者不经常调用的函数
    - 相关例子包括碰撞事件、武器发射的开始或结束，或生成Actor

    

- **注意**：

  - 滥用可靠函数可能导致其队列溢出，此操作将强制断开连接
  - 若逐帧调用复制函数，应将其设为不可靠
  - 若拥有与玩家输入绑定的可靠函数，应限制玩家调用该函数的频率





###### 1.3.4.2 验证



- **描述**：`WithValidation` 说明符表明除函数的实现外，还有可验证传入函数调用的数据的函数
  - 此验证函数与其负责的函数使用同一签名，但其将返回布尔而非原本返回值
  - 若返回 `true`，则其允许执行RPC的 `Implementation`；若返回 `false`，则防止执行



- **ExampleClass.cpp**

  ```c++
  //服务器RPC MyFunction的验证
  bool AExampleClass::MyFunction_Validation(int myInt)
  {
      /* 
          若myInt的值为负，建议不允许运行MyFunction_Implementation。 
          因此仅在myInt大于零时返回true。
      */
      return myInt >= 0;
  }
  ```







### 2. 提示和深入阅读



- **描述**：戏中实现高效、稳定多人游戏系统的基本指南





#### 2.1 基本复制Actor清单



- 将Actor的复制设置设为True
- 若复制Actor需要移动，将复制移动（Replicates Movement）设为True
- 生成或销毁复制Actor时，确保在服务器上执行该操作
- 设置必须在机器间共享的变量，以便进行复制。这通常适用于以gameplay为基础的变量
- 尽量使用虚幻引擎的预制移动组件，其已针对复制进行构建
- 若使用服务器授权模型，需确保玩家可执行的新操作均由服务器函数触发





#### 2.2 网络提示



- 尽可能少用RPC或复制蓝图函数。在合适情况下改用RepNotify
- 组播函数会导致会话中各连接客户端的额外网络流量，需尤其少用
- 若能保证非复制函数仅在服务器上执行，则服务器RPC中无需包含纯服务器逻辑
- 将可靠RPC绑定到玩家输入时需谨慎。玩家可能会快速反复点击按钮，导致可靠RPC队列溢出。应采取措施限制玩家激活此项的频率
- 若游戏频繁调用RPC或复制函数，如tick时，则应将其设为不可靠
- 部分函数可重复使用。调用其响应游戏逻辑，然后调用其响应RepNotify，确保客户端和服务器拥有并列执行即可
- 检查Actor的网络角色可查看其是否为 `ROLE_Authority`。此方法适用于过滤函数中的执行，该函数同时在服务器和客户端上激活
- 使用C++中的 `IsLocallyControlled` 函数或蓝图中的Is Locally Controlled函数，可检查Pawn是否受本地控制。基于执行是否与拥有客户端相关来过滤函数时，此方法十分有用
- 构造期间Pawn可能未被指定控制器，因此避免在构造函数脚本中使用 `IsLocallyControlled`







### 3. Actor 复制



Actor 主要通过两种方式进行更新：

- 属性更新
- RPC （远程过程调用）
- 属性更新和 RPC 的主要区别在于，属性可以在发生变化时随时自动更新，而 RPC 只能在被执行时获得调用更新



复制例子：Actor 的健康值

- 当健康值发生变化时，您通常都希望告知客户端。如果健康值没有变化，则不会发送任何数据
- 即使这个属性没有变化（因此不消耗任何带宽），它仍然会消耗 CPU 资源来判断这个值是否发生变化
- 适合那些经常变化的属性



RPC例子：同一场爆炸

- 可以以位置和半径为参数的 RPC 函数，同时在每次发生爆炸时调用它
- 也可以将此存储为一组属性，通过同步的方式将其传达给客户端
- 这种做法会损失一些效率，因为爆炸出现的频繁度也许不会高得有必要将它们作为属性





#### 3.1 组件复制



##### 3.1.1 组件复制介绍



介绍：

- 虚幻引擎 4 支持组件复制
- 大多数组件都不会复制
- 多数游戏逻辑都是在 Actor 类和组件中完成，而它们 通常只代表了构成 Actor 的零散部分
- 实际复制的是 Actor 中的游戏逻辑，而这样做的结果，有时会调用/更改组件
- 有些情况下，组件本身的属性或事件必须要直接复制
- 一旦复制了 Actor，它就可以复制自身组件
- 这些组件 可以按 Actor 的方式复制属性和 RPC
- 组件必须以 Actor 的方式实施 `::GetLifetimeReplicatedProps (...)` 函数



组件复制涉及两大类组件：

- 静态组件：一种是随 Actor 一起创建的组件

  - 在客户端或服务器上生成 所属 Actor 时，这些组件也会同时生成，与组件是否被复制无关
  - 服务器不会告知客户端显式生成这些组件
  - 静态组件无需通过复制存在于客户端
  - 只有在属性或事件需要在服务器和客户端之间自动同步时，才需要进行复制

  

- 动态组件：运行时在服务器上生成的组件种，其创建和删除操作也将被复制到客户端

  - 运行方式与 Actor 极为一致
  - 动态组件需通过复制的方式存在于所有客户端
  - 客户端可以生成自己的本地非复制组件，当那些在服务器上触发的 属性或事件需要自动同步到客户端时，才会出现复制行为





##### 3.1.2 使用方式



- 在组件上设置属性和 RPC 的过程与 Actor 并无区别
- 将一个类设置为具有复本后，这些组件的实际实例也必须经过设置后才能复制



- C++

- 调用 `AActorComponent::SetIsReplicated(true)` 即可

- 如果组件是一个默认子对象，就应当在生成组件之后通过类构造函数来完成此调用

- 示例：

  ```c++
  ACharacter::ACharacter()
  {
      // Etc...
  
      CharacterMovement = CreateDefaultSubobject<UMovementComp_Character>(TEXT("CharMoveComp"));
      if (CharacterMovement)
      {
          CharacterMovement->UpdatedComponent = CapsuleComponent;
  
          CharacterMovement->GetNavAgentProperties()->bCanJump = true;
          CharacterMovement->GetNavAgentProperties()->bCanWalk = true;
          CharacterMovement->SetJumpAllowed(true);
          CharacterMovement->SetNetAddressable(); // Make DSO components net addressable
          CharacterMovement->SetIsReplicated(true); // Enable replication by default
  
      }
  }
  ```



- 蓝图

- 要进行静态蓝图组件复制，只需在组件默认设置中切换 **Replicates** 布尔变量

- 静态组件需要在客户端和服务器上隐式创建

- 并非所有组件都会如此显示，必须要支持某种复制形式才会显示

  ![components_checkbox.png](https://docs.unrealengine.com/4.27/Images/InteractiveExperiences/Networking/Actors/Components/components_checkbox.jpg)

- 通过动态生成的组件来实现这一点，可以调用 **SetIsReplicated** 函数

  ![components_function.png](https://docs.unrealengine.com/4.27/Images/InteractiveExperiences/Networking/Actors/Components/components_function.jpg)





##### 3.1.3 时间轴



- 时间轴必须通过其属性中的 Replicated 选项来启用复制
- 会将服务器控制的运行位置、速率和方向复制到客户端
- 大多数时间轴都无需复制
- 时间轴复本只应当在服务器上直接 操作 (start/stop etc)
- 客户端只应当查看运行位置的复本，而不应尝试改变时间轴本身
- 在进行复制更新的间歇，客户端将推测 运行位置





##### 3.1.4 带宽开销



- 复制组件时的资源开销是比较低的
- 复制的 Actor 中的每个组件都需要添加一个额外的 NetGUID（4 字节）"标头"和一个大约 1 字节的"标脚"（footer） 及其属性
- 在 CPU 层面上，基于 Actor 的属性复制与基于组件的复制之间应当有一个最小差异





##### 3.1.5 一般性子对象复制



- 所有 Actor 子对象都可以复制，而不只限于组件



- 对于希望复制非 ActorComponent 子对象的类，应当实施三种方法

  ```c++
  /** FActory 方法，用于对模板化 TobjectReplicator 类进行实例化，以便实现子对象复制 */
  virtual class FObjectReplicatorBase * InstantiateReplicatorForSubObject(UClass *SubobjClass);
  
  /** 能让 Actor 在其 Actor 通道上复制子对象的方法 */
  virtual bool ReplicateSubobjects(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags);
  
  /** 通过复制来动态创建新的子对象时，在 Actor 上进行调用 */
  virtual void OnSubobjectCreatedFromReplication(UObject *NewSubobject);
  ```





###### 3.1.5.1 使用情形



- 能在 Actor 通道的层面上使用 UObject 和多态（polymorphism）
- 之前用于复杂数据结构的复制方法只适合那些 在 Actor 类中对类型进行静态定义的结构
- 利用子对象复制，建立一个道具栏系统，使其中的每个物品作为一个从基本道具栏类扩展而来的类， 也可以进行完整复制，同时无需让这些项成为 Actor（资源负担太大）





###### 3.1.5.2 优化



- 有很多子对象需要复制，Actor 只需了解哪些子对象（如存在）最近发生过变化且需要复制，从而节省了大量时间

- 通过访问器（accessor）函数来持续跟踪子对象的更改情况

- 所用的接口位于 UActorChannel 中

  ```c++
  bool KeyNeedsToReplicate(int32 ObjID, int32 RepKey);
  ```

- 该函数应当由 Actor 在其 `::ReplicateSubobjects` 实施中调用

- Actor 类可以设置一个任意的对象 ID 和复制键，供复制系统跟踪每个客户端

- 对象 ID 和复制键完全是任意指定的

- 对象 ID 仅用于引用"事情"

  - 可以是整个子对象列表、部分列表或单个对象

- 复制键同样可以任意指定

  - 可以是一个在对象 ID 跟踪变化时递增的计数器







#### 3.2 Actor及其所属连接



##### 3.2.1 连接



- 每个连接都有一个专门为其创建的 PlayerController
- 确定一个 actor 是否归某一连接所有，您可以查询这个 actor 最外围的所有者
- 所有者是一个 PlayerController，则这个 actor 同样归属于拥有 PlayerController 的那个连接





##### 3.2.2 确定连接



- 在确定所属连接方面，组件有一些特殊之处
  - 首先确定组件所有者，方法是遍历组件的"外链"，直到找出所属的 actor
  - 确定这个 actor 的所属连接，像上面那样继续下去
  - 连接所有权是以下情形中的重要因素：
    - RPC 需要确定哪个客户端将执行运行于客户端的 RPC
    - Actor 复制与连接相关性
    - 在涉及所有者时的 Actor 属性复制条件



##### 3.2.3 连接的作用



- 连接所有权对于 RPC 这样的机制至关重要，因为当您在 actor 上调用 RPC 函数时
- 除非 RPC 被标记为多播，否则就需要知道要在哪个客户端上执行该 RPC
- 它可以查找所属连接来确定将 RPC 发送到哪条连接



- 连接所有权会在 actor 复制期间使用，用于确定各个 actor 上有哪些连接获得了更新
- 对于那些将 bOnlyRelevantToOwner 设置为 true 的 actor，只有拥有此 actor 的连接才会接收这个 actor 的属性更新
- 默认情况下，所有 PlayerController 都设置了此标志，正因如此，客户端才只会收到它们拥有的 PlayerController 的更新
- 最主要的是防止玩家作弊和提高效率



- 对于那些要用到所有者的 [需要复制属性的情形](https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/Properties/Conditions) 来说，连接所有权具有重要意义：
  - 当使用 `COND_OnlyOwner` 时，只有此 actor 的所有者才会收到这些属性更新
- 所属连接对那些作为自治代理的 actor（角色为 `ROLE_AutonomousProxy`）来说也很重要
  - 这些 actor 的角色会降级为 `ROLE_SimulatedProxy`，其属性则被复制到不拥有这些 actor 的连接中